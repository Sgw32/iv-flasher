
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
        return style.sheet;
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.wholeText !== data)
            text.data = data;
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            managed_styles.forEach(info => {
                const { ownerNode } = info.stylesheet;
                // there is no ownerNode if it runs on jsdom.
                if (ownerNode)
                    detach(ownerNode);
            });
            managed_styles.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    const REPLY_MODE = 'reply_mode';
    const BAUDRATE = 'baudrate';
    const MCUTYPE = 'mcutype';
    const START_ADDRESS = 'start_address';
    const MODBUS = 'modbus';

    class Settings {
        constructor() {
            this._replyMode = localStorage.getItem(REPLY_MODE) === "true" || false;
            this._baudrate = localStorage.getItem(BAUDRATE) || "9600";
            this._mcutype = localStorage.getItem(MCUTYPE) || "Artery";
            this._startAddress = localStorage.getItem(START_ADDRESS) || "0x8000000";
            this._modbus = localStorage.getItem(MODBUS) === "true" || false;
        }

        set replyMode(reply) {
            this._replyMode = reply;
            this.commit();
        }

        get replyMode() {
            return this._replyMode;
        }

        set modbus(mdbs) {
            this._modbus = mdbs;
            this.commit();
        }

        get modbus() {
            return this._modbus;
        }

        set baudrate(baudrate) {
            this._baudrate = baudrate;
            this.commit();
        }

        get baudrate() {
            return this._baudrate;
        }

        set mcutype(mcutype) {
            this._mcutype = mcutype;
            this.commit();
        }

        get mcutype() {
            return this._mcutype;
        }

        get startAddress() {
            return this._startAddress;
        }

        set startAddress(address) {
            this._startAddress = address;
            this.commit();
        }

        commit() {
            localStorage.setItem(REPLY_MODE, this._replyMode);
            localStorage.setItem(BAUDRATE, this._baudrate);
            localStorage.setItem(START_ADDRESS, this._startAddress);
            localStorage.setItem(MODBUS, this._modbus);
        }
    }

    const settings = new Settings();

    class Logger {
        constructor() {
            this.allLogger = [];
        }

        registerLogger(logger) {
            this.allLogger.push(logger);
        }

        log(...args) {
            this.allLogger.forEach((logger) => {
                logger.log.apply(null, args);
            });
        }
    }

    const logger = new Logger();

    var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t$1=function(r){return "string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return (r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return {r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o$1=function(r){return {r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return {h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return {r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return {h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return {h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e;},c=function(r){return {h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u;},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t$1(n)&&t$1(e)&&t$1(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t$1(n)||!t$1(e)||!t$1(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t$1(n)||!t$1(a)||!t$1(o))return null;var h=function(r){return {h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return [e,t[n][1]]}return [null,void 0]},x=function(r){return "string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},M=function(r,t){var n=c(r);return {h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return (299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return {h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1};}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o$1(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i;},r.prototype.toRgb=function(){return o$1(this.rgba)},r.prototype.toRgbString=function(){return r=o$1(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u;},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u;},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r;},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r;},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return "number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t;},r.prototype.hue=function(r){var t=c(this.rgba);return "number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r));});};

    var o=function(o){var t=o/255;return t<.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)},t=function(t){return .2126*o(t.r)+.7152*o(t.g)+.0722*o(t.b)};function a11yPlugin(o){o.prototype.luminance=function(){return o=t(this.rgba),void 0===(r=2)&&(r=0),void 0===n&&(n=Math.pow(10,r)),Math.round(n*o)/n+0;var o,r,n;},o.prototype.contrast=function(r){void 0===r&&(r="#FFF");var n,a,i,e,v,u,d,c=r instanceof o?r:new o(r);return e=this.rgba,v=c.toRgb(),u=t(e),d=t(v),n=u>d?(u+.05)/(d+.05):(d+.05)/(u+.05),void 0===(a=2)&&(a=0),void 0===i&&(i=Math.pow(10,a)),Math.floor(i*n)/i+0},o.prototype.isReadable=function(o,t){return void 0===o&&(o="#FFF"),void 0===t&&(t={}),this.contrast(o)>=(e=void 0===(i=(r=t).size)?"normal":i,"AAA"===(a=void 0===(n=r.level)?"AA":n)&&"normal"===e?7:"AA"===a&&"large"===e?3:4.5);var r,n,a,i,e;};}

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    /**
     * Store that keeps track of the keys pressed, updated by the ArrowKeyHandler component
     */
    const keyPressed = writable({
        ArrowLeft: 0,
        ArrowUp: 0,
        ArrowRight: 0,
        ArrowDown: 0
    });
    /**
     * Store that keeps track of the keys pressed, with utility horizontal / vertical attributes
     * updated by the ArrowKeyHandler component
     */
    const keyPressedCustom = derived(keyPressed, ($keyPressed) => {
        return {
            ...$keyPressed,
            ArrowV: $keyPressed.ArrowUp + $keyPressed.ArrowDown,
            ArrowH: $keyPressed.ArrowLeft + $keyPressed.ArrowRight,
            ArrowVH: $keyPressed.ArrowUp + $keyPressed.ArrowDown + $keyPressed.ArrowLeft + $keyPressed.ArrowRight
        };
    });

    /**
     * Ease in out sin base function
     * @param x - param, between 1 and infinity
     * @param min - starting return value, default .001
     * @param max ending return value, default .01
     * @returns a number between min and max
     */
    function easeInOutSin(x, min = 0.001, max = 0.01) {
        /**
         * after the delay, the ease in starts (i.e. after x = DELAY)*
         */
        const DELAY = 50;
        /**
         * Duration of the transition (i.e. bewteen x = DELAY and x = DELAY + DURATION)
         */
        const DURATION = 50;
        const X = Math.min(1, Math.max(1, x - DELAY) / DURATION);
        return min + ((max - min) / 2) * (1 - Math.cos(Math.PI * X));
    }

    /* node_modules\svelte-awesome-color-picker\components\Picker.svelte generated by Svelte v3.50.1 */

    const { window: window_1$2 } = globals;

    function create_default_slot$3(ctx) {
    	let div;
    	let switch_instance;
    	let div_aria_valuetext_value;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*components*/ ctx[2].pickerIndicator;

    	function switch_props(ctx) {
    		return {
    			props: {
    				pos: /*pos*/ ctx[9],
    				isDark: /*isDark*/ ctx[5],
    				hex: w({
    					h: /*h*/ ctx[3],
    					s: /*s*/ ctx[0],
    					v: /*v*/ ctx[1],
    					a: 1
    				}).toHex()
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr(div, "class", "picker svelte-uiwgvv");
    			attr(div, "tabindex", "0");
    			set_style(div, "--color-bg", /*colorBg*/ ctx[8]);
    			attr(div, "aria-label", "saturation and brightness picker (arrow keyboard navigation)");
    			attr(div, "aria-valuemin", 0);
    			attr(div, "aria-valuemax", 100);
    			attr(div, "aria-valuetext", div_aria_valuetext_value = "saturation " + /*pos*/ ctx[9].x?.toFixed() + "%, brightness " + /*pos*/ ctx[9].y?.toFixed() + "%");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			/*div_binding*/ ctx[18](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(div, "mousedown", prevent_default(/*pickerMousedown*/ ctx[10])),
    					listen(div, "touchstart", /*touch*/ ctx[16]),
    					listen(div, "touchmove", prevent_default(/*touch*/ ctx[16])),
    					listen(div, "touchend", /*touch*/ ctx[16])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*pos*/ 512) switch_instance_changes.pos = /*pos*/ ctx[9];
    			if (dirty & /*isDark*/ 32) switch_instance_changes.isDark = /*isDark*/ ctx[5];

    			if (dirty & /*h, s, v*/ 11) switch_instance_changes.hex = w({
    				h: /*h*/ ctx[3],
    				s: /*s*/ ctx[0],
    				v: /*v*/ ctx[1],
    				a: 1
    			}).toHex();

    			if (switch_value !== (switch_value = /*components*/ ctx[2].pickerIndicator)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (!current || dirty & /*colorBg*/ 256) {
    				set_style(div, "--color-bg", /*colorBg*/ ctx[8]);
    			}

    			if (!current || dirty & /*pos*/ 512 && div_aria_valuetext_value !== (div_aria_valuetext_value = "saturation " + /*pos*/ ctx[9].x?.toFixed() + "%, brightness " + /*pos*/ ctx[9].y?.toFixed() + "%")) {
    				attr(div, "aria-valuetext", div_aria_valuetext_value);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (switch_instance) destroy_component(switch_instance);
    			/*div_binding*/ ctx[18](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function create_fragment$n(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*components*/ ctx[2].pickerWrapper;

    	function switch_props(ctx) {
    		return {
    			props: {
    				focused: /*focused*/ ctx[7],
    				toRight: /*toRight*/ ctx[4],
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(window_1$2, "mouseup", /*mouseUp*/ ctx[11]),
    					listen(window_1$2, "mousedown", /*mouseDown*/ ctx[13]),
    					listen(window_1$2, "mousemove", /*mouseMove*/ ctx[12]),
    					listen(window_1$2, "keyup", /*keyup*/ ctx[14]),
    					listen(window_1$2, "keydown", /*keydown*/ ctx[15])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*focused*/ 128) switch_instance_changes.focused = /*focused*/ ctx[7];
    			if (dirty & /*toRight*/ 16) switch_instance_changes.toRight = /*toRight*/ ctx[4];

    			if (dirty & /*$$scope, colorBg, pos, picker, components, isDark, h, s, v*/ 67109743) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*components*/ ctx[2].pickerWrapper)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function clamp(value, min, max) {
    	return Math.min(Math.max(min, value), max);
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $keyPressed;
    	let $keyPressedCustom;
    	component_subscribe($$self, keyPressed, $$value => $$invalidate(22, $keyPressed = $$value));
    	component_subscribe($$self, keyPressedCustom, $$value => $$invalidate(23, $keyPressedCustom = $$value));
    	let { components } = $$props;
    	let { h } = $$props;
    	let { s } = $$props;
    	let { v } = $$props;
    	let { isOpen } = $$props;
    	let { toRight } = $$props;
    	let { isDark } = $$props;
    	let picker;
    	let isMouseDown = false;
    	let focused = false;
    	let focusMovementIntervalId;
    	let focusMovementCounter;
    	let colorBg;
    	let pos = { x: 100, y: 0 };

    	function onClick(e) {
    		let mouse = { x: e.offsetX, y: e.offsetY };
    		let width = picker.getBoundingClientRect().width;
    		let height = picker.getBoundingClientRect().height;
    		$$invalidate(0, s = clamp(mouse.x / width, 0, 1) * 100);
    		$$invalidate(1, v = clamp((height - mouse.y) / height, 0, 1) * 100);
    	}

    	function pickerMousedown(e) {
    		if (e.button === 0) {
    			isMouseDown = true;
    			onClick(e);
    		}
    	}

    	function mouseUp() {
    		isMouseDown = false;
    	}

    	function mouseMove(e) {
    		if (isMouseDown) onClick({
    			offsetX: Math.max(0, Math.min(picker.getBoundingClientRect().width, e.clientX - picker.getBoundingClientRect().left)),
    			offsetY: Math.max(0, Math.min(picker.getBoundingClientRect().height, e.clientY - picker.getBoundingClientRect().top))
    		});
    	}

    	function mouseDown(e) {
    		if (!e.target.isSameNode(picker)) $$invalidate(7, focused = false);
    	}

    	function keyup(e) {
    		if (e.key === 'Tab') $$invalidate(7, focused = !!document.activeElement?.isSameNode(picker));
    		if (!e.repeat && focused) move();
    	}

    	function keydown(e) {
    		if (focused && $keyPressedCustom.ArrowVH) {
    			e.preventDefault();
    			if (!e.repeat) move();
    		}
    	}

    	function move() {
    		if ($keyPressedCustom.ArrowVH) {
    			if (!focusMovementIntervalId) {
    				focusMovementCounter = 0;

    				focusMovementIntervalId = window.setInterval(
    					() => {
    						let focusMovementFactor = easeInOutSin(++focusMovementCounter);
    						$$invalidate(0, s = Math.min(100, Math.max(0, s + ($keyPressed.ArrowRight - $keyPressed.ArrowLeft) * focusMovementFactor * 100)));
    						$$invalidate(1, v = Math.min(100, Math.max(0, v + ($keyPressed.ArrowUp - $keyPressed.ArrowDown) * focusMovementFactor * 100)));
    					},
    					10
    				);
    			}
    		} else if (focusMovementIntervalId) {
    			clearInterval(focusMovementIntervalId);
    			focusMovementIntervalId = undefined;
    		}
    	}

    	function touch(e) {
    		e.preventDefault();

    		onClick({
    			offsetX: e.changedTouches[0].clientX - picker.getBoundingClientRect().left,
    			offsetY: e.changedTouches[0].clientY - picker.getBoundingClientRect().top
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			picker = $$value;
    			$$invalidate(6, picker);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('components' in $$props) $$invalidate(2, components = $$props.components);
    		if ('h' in $$props) $$invalidate(3, h = $$props.h);
    		if ('s' in $$props) $$invalidate(0, s = $$props.s);
    		if ('v' in $$props) $$invalidate(1, v = $$props.v);
    		if ('isOpen' in $$props) $$invalidate(17, isOpen = $$props.isOpen);
    		if ('toRight' in $$props) $$invalidate(4, toRight = $$props.toRight);
    		if ('isDark' in $$props) $$invalidate(5, isDark = $$props.isDark);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*h*/ 8) {
    			if (typeof h === 'number') $$invalidate(8, colorBg = w({ h, s: 100, v: 100, a: 1 }).toHex());
    		}

    		if ($$self.$$.dirty & /*s, v, picker*/ 67) {
    			if (typeof s === 'number' && typeof v === 'number' && picker) $$invalidate(9, pos = { x: s, y: 100 - v });
    		}
    	};

    	return [
    		s,
    		v,
    		components,
    		h,
    		toRight,
    		isDark,
    		picker,
    		focused,
    		colorBg,
    		pos,
    		pickerMousedown,
    		mouseUp,
    		mouseMove,
    		mouseDown,
    		keyup,
    		keydown,
    		touch,
    		isOpen,
    		div_binding
    	];
    }

    class Picker extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$m, create_fragment$n, safe_not_equal, {
    			components: 2,
    			h: 3,
    			s: 0,
    			v: 1,
    			isOpen: 17,
    			toRight: 4,
    			isDark: 5
    		});
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\Slider.svelte generated by Svelte v3.50.1 */

    const { window: window_1$1 } = globals;

    function create_default_slot$2(ctx) {
    	let div;
    	let switch_instance;
    	let div_aria_valuenow_value;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*components*/ ctx[1].sliderIndicator;

    	function switch_props(ctx) {
    		return {
    			props: {
    				pos: /*pos*/ ctx[4],
    				toRight: /*toRight*/ ctx[2]
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr(div, "class", "slider svelte-14nweqy");
    			attr(div, "tabindex", "0");
    			attr(div, "aria-label", "hue picker (arrow keyboard navigation)");
    			attr(div, "aria-valuemin", 0);
    			attr(div, "aria-valuemax", 360);
    			attr(div, "aria-valuenow", div_aria_valuenow_value = Math.round(/*h*/ ctx[0]));
    			toggle_class(div, "to-right", /*toRight*/ ctx[2]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			/*div_binding*/ ctx[12](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(div, "mousedown", prevent_default(/*mouseDown*/ ctx[6])),
    					listen(div, "touchstart", /*touch*/ ctx[11]),
    					listen(div, "touchmove", prevent_default(/*touch*/ ctx[11])),
    					listen(div, "touchend", /*touch*/ ctx[11])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*pos*/ 16) switch_instance_changes.pos = /*pos*/ ctx[4];
    			if (dirty & /*toRight*/ 4) switch_instance_changes.toRight = /*toRight*/ ctx[2];

    			if (switch_value !== (switch_value = /*components*/ ctx[1].sliderIndicator)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (!current || dirty & /*h*/ 1 && div_aria_valuenow_value !== (div_aria_valuenow_value = Math.round(/*h*/ ctx[0]))) {
    				attr(div, "aria-valuenow", div_aria_valuenow_value);
    			}

    			if (!current || dirty & /*toRight*/ 4) {
    				toggle_class(div, "to-right", /*toRight*/ ctx[2]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (switch_instance) destroy_component(switch_instance);
    			/*div_binding*/ ctx[12](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function create_fragment$m(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*components*/ ctx[1].sliderWrapper;

    	function switch_props(ctx) {
    		return {
    			props: {
    				focused: /*focused*/ ctx[5],
    				toRight: /*toRight*/ ctx[2],
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(window_1$1, "mouseup", /*mouseUp*/ ctx[7]),
    					listen(window_1$1, "mousemove", /*mouseMove*/ ctx[8]),
    					listen(window_1$1, "keyup", /*keyup*/ ctx[9]),
    					listen(window_1$1, "keydown", /*keydown*/ ctx[10])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*focused*/ 32) switch_instance_changes.focused = /*focused*/ ctx[5];
    			if (dirty & /*toRight*/ 4) switch_instance_changes.toRight = /*toRight*/ ctx[2];

    			if (dirty & /*$$scope, h, slider, toRight, components, pos*/ 1048607) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*components*/ ctx[1].sliderWrapper)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $keyPressed;
    	let $keyPressedCustom;
    	component_subscribe($$self, keyPressed, $$value => $$invalidate(16, $keyPressed = $$value));
    	component_subscribe($$self, keyPressedCustom, $$value => $$invalidate(17, $keyPressedCustom = $$value));
    	let { components } = $$props;
    	let { toRight } = $$props;
    	let slider;
    	let isMouseDown = false;
    	let { h } = $$props;
    	let pos = 0;
    	let focused = false;
    	let focusMovementIntervalId;
    	let focusMovementCounter;

    	function onClick(pos) {
    		const size = toRight
    		? slider.getBoundingClientRect().width
    		: slider.getBoundingClientRect().height;

    		const boundedPos = Math.max(0, Math.min(size, pos));
    		$$invalidate(0, h = boundedPos / size * 360);
    	}

    	function mouseDown(e) {
    		if (e.button === 0) {
    			isMouseDown = true;
    			onClick(toRight ? e.offsetX : e.offsetY);
    		}
    	}

    	function mouseUp() {
    		isMouseDown = false;
    	}

    	function mouseMove(e) {
    		if (isMouseDown) onClick(toRight
    		? e.clientX - slider.getBoundingClientRect().left
    		: e.clientY - slider.getBoundingClientRect().top);
    	}

    	function keyup(e) {
    		if (e.key === 'Tab') $$invalidate(5, focused = !!document.activeElement?.isSameNode(slider));
    		if (!e.repeat && focused) move();
    	}

    	function keydown(e) {
    		if (focused && $keyPressedCustom.ArrowVH) {
    			e.preventDefault();
    			if (!e.repeat) move();
    		}
    	}

    	function move() {
    		if ($keyPressedCustom.ArrowVH) {
    			if (!focusMovementIntervalId) {
    				focusMovementCounter = 0;

    				focusMovementIntervalId = window.setInterval(
    					() => {
    						const focusMovementFactor = easeInOutSin(++focusMovementCounter);

    						const movement = toRight
    						? $keyPressed.ArrowRight - $keyPressed.ArrowLeft
    						: $keyPressed.ArrowDown - $keyPressed.ArrowUp;

    						$$invalidate(0, h = Math.min(360, Math.max(0, h + movement * 360 * focusMovementFactor)));
    					},
    					10
    				);
    			}
    		} else if (focusMovementIntervalId) {
    			clearInterval(focusMovementIntervalId);
    			focusMovementIntervalId = undefined;
    		}
    	}

    	function touch(e) {
    		e.preventDefault();

    		onClick(toRight
    		? e.changedTouches[0].clientX - slider.getBoundingClientRect().left
    		: e.changedTouches[0].clientY - slider.getBoundingClientRect().top);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			slider = $$value;
    			$$invalidate(3, slider);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('components' in $$props) $$invalidate(1, components = $$props.components);
    		if ('toRight' in $$props) $$invalidate(2, toRight = $$props.toRight);
    		if ('h' in $$props) $$invalidate(0, h = $$props.h);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*h, slider*/ 9) {
    			if (typeof h === 'number' && slider) $$invalidate(4, pos = 100 * h / 360);
    		}
    	};

    	return [
    		h,
    		components,
    		toRight,
    		slider,
    		pos,
    		focused,
    		mouseDown,
    		mouseUp,
    		mouseMove,
    		keyup,
    		keydown,
    		touch,
    		div_binding
    	];
    }

    class Slider extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$l, create_fragment$m, safe_not_equal, { components: 1, toRight: 2, h: 0 });
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\Alpha.svelte generated by Svelte v3.50.1 */

    const { window: window_1 } = globals;

    function create_default_slot$1(ctx) {
    	let div;
    	let switch_instance;
    	let div_aria_valuenow_value;
    	let div_aria_valuetext_value;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*components*/ ctx[0].alphaIndicator;

    	function switch_props(ctx) {
    		return {
    			props: {
    				pos: /*pos*/ ctx[5],
    				toRight: /*toRight*/ ctx[2]
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr(div, "class", "alpha svelte-f2vq53");
    			attr(div, "tabindex", "0");
    			set_style(div, "--alpha-color", /*hex*/ ctx[1]?.substring(0, 7));
    			attr(div, "aria-label", "transparency picker (arrow keyboard navigation)");
    			attr(div, "aria-valuemin", 0);
    			attr(div, "aria-valuemax", 100);
    			attr(div, "aria-valuenow", div_aria_valuenow_value = Math.round(/*pos*/ ctx[5]));
    			attr(div, "aria-valuetext", div_aria_valuetext_value = "" + (/*pos*/ ctx[5]?.toFixed() + "%"));
    			toggle_class(div, "to-right", /*toRight*/ ctx[2]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			/*div_binding*/ ctx[14](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(div, "mousedown", prevent_default(/*mouseDown*/ ctx[6])),
    					listen(div, "touchstart", /*touch*/ ctx[11]),
    					listen(div, "touchmove", prevent_default(/*touch*/ ctx[11])),
    					listen(div, "touchend", /*touch*/ ctx[11])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*pos*/ 32) switch_instance_changes.pos = /*pos*/ ctx[5];
    			if (dirty & /*toRight*/ 4) switch_instance_changes.toRight = /*toRight*/ ctx[2];

    			if (switch_value !== (switch_value = /*components*/ ctx[0].alphaIndicator)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (!current || dirty & /*hex*/ 2) {
    				set_style(div, "--alpha-color", /*hex*/ ctx[1]?.substring(0, 7));
    			}

    			if (!current || dirty & /*pos*/ 32 && div_aria_valuenow_value !== (div_aria_valuenow_value = Math.round(/*pos*/ ctx[5]))) {
    				attr(div, "aria-valuenow", div_aria_valuenow_value);
    			}

    			if (!current || dirty & /*pos*/ 32 && div_aria_valuetext_value !== (div_aria_valuetext_value = "" + (/*pos*/ ctx[5]?.toFixed() + "%"))) {
    				attr(div, "aria-valuetext", div_aria_valuetext_value);
    			}

    			if (!current || dirty & /*toRight*/ 4) {
    				toggle_class(div, "to-right", /*toRight*/ ctx[2]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (switch_instance) destroy_component(switch_instance);
    			/*div_binding*/ ctx[14](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function create_fragment$l(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*components*/ ctx[0].alphaWrapper;

    	function switch_props(ctx) {
    		return {
    			props: {
    				focused: /*focused*/ ctx[4],
    				toRight: /*toRight*/ ctx[2],
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(window_1, "mouseup", /*mouseUp*/ ctx[7]),
    					listen(window_1, "mousemove", /*mouseMove*/ ctx[8]),
    					listen(window_1, "keyup", /*keyup*/ ctx[9]),
    					listen(window_1, "keydown", /*keydown*/ ctx[10])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*focused*/ 16) switch_instance_changes.focused = /*focused*/ ctx[4];
    			if (dirty & /*toRight*/ 4) switch_instance_changes.toRight = /*toRight*/ ctx[2];

    			if (dirty & /*$$scope, hex, pos, alpha, toRight, components*/ 4194351) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*components*/ ctx[0].alphaWrapper)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $keyPressed;
    	let $keyPressedCustom;
    	component_subscribe($$self, keyPressed, $$value => $$invalidate(18, $keyPressed = $$value));
    	component_subscribe($$self, keyPressedCustom, $$value => $$invalidate(19, $keyPressedCustom = $$value));
    	let { components } = $$props;
    	let { isOpen } = $$props;
    	let { a = 1 } = $$props;
    	let { hex } = $$props;
    	let { toRight } = $$props;
    	let alpha;
    	let isMouseDown = false;
    	let focused = false;
    	let focusMovementIntervalId;
    	let focusMovementCounter;
    	let pos;

    	function onClick(pos) {
    		const size = toRight
    		? alpha.getBoundingClientRect().width
    		: alpha.getBoundingClientRect().height;

    		const boundedPos = Math.max(0, Math.min(size, pos));
    		$$invalidate(12, a = boundedPos / size);
    	}

    	function mouseDown(e) {
    		if (e.button === 0) {
    			isMouseDown = true;
    			onClick(toRight ? e.offsetX : e.offsetY);
    		}
    	}

    	function mouseUp() {
    		isMouseDown = false;
    	}

    	function mouseMove(e) {
    		if (isMouseDown) onClick(toRight
    		? e.clientX - alpha.getBoundingClientRect().left
    		: e.clientY - alpha.getBoundingClientRect().top);
    	}

    	function keyup(e) {
    		if (e.key === 'Tab') $$invalidate(4, focused = !!document.activeElement?.isSameNode(alpha));
    		if (!e.repeat && focused) move();
    	}

    	function keydown(e) {
    		if (focused && $keyPressedCustom.ArrowVH) {
    			e.preventDefault();
    			if (!e.repeat) move();
    		}
    	}

    	function move() {
    		if ($keyPressedCustom.ArrowVH) {
    			if (!focusMovementIntervalId) {
    				focusMovementCounter = 0;

    				focusMovementIntervalId = window.setInterval(
    					() => {
    						const focusMovementFactor = easeInOutSin(++focusMovementCounter);

    						const movement = toRight
    						? $keyPressed.ArrowRight - $keyPressed.ArrowLeft
    						: $keyPressed.ArrowDown - $keyPressed.ArrowUp;

    						$$invalidate(12, a = Math.min(1, Math.max(0, a + movement * focusMovementFactor)));
    					},
    					10
    				);
    			}
    		} else if (focusMovementIntervalId) {
    			clearInterval(focusMovementIntervalId);
    			focusMovementIntervalId = undefined;
    		}
    	}

    	function touch(e) {
    		e.preventDefault();

    		onClick(toRight
    		? e.changedTouches[0].clientX - alpha.getBoundingClientRect().left
    		: e.changedTouches[0].clientY - alpha.getBoundingClientRect().top);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			alpha = $$value;
    			$$invalidate(3, alpha);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('components' in $$props) $$invalidate(0, components = $$props.components);
    		if ('isOpen' in $$props) $$invalidate(13, isOpen = $$props.isOpen);
    		if ('a' in $$props) $$invalidate(12, a = $$props.a);
    		if ('hex' in $$props) $$invalidate(1, hex = $$props.hex);
    		if ('toRight' in $$props) $$invalidate(2, toRight = $$props.toRight);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*a, alpha*/ 4104) {
    			if (typeof a === 'number' && alpha) $$invalidate(5, pos = 100 * a);
    		}
    	};

    	return [
    		components,
    		hex,
    		toRight,
    		alpha,
    		focused,
    		pos,
    		mouseDown,
    		mouseUp,
    		mouseMove,
    		keyup,
    		keydown,
    		touch,
    		a,
    		isOpen,
    		div_binding
    	];
    }

    class Alpha extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$k, create_fragment$l, safe_not_equal, {
    			components: 0,
    			isOpen: 13,
    			a: 12,
    			hex: 1,
    			toRight: 2
    		});
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\default\TextInput.svelte generated by Svelte v3.50.1 */

    function create_else_block$1(ctx) {
    	let div;
    	let input0;
    	let t0;
    	let input1;
    	let t1;
    	let input2;
    	let t2;
    	let mounted;
    	let dispose;
    	let if_block = /*isAlpha*/ ctx[2] && create_if_block_5(ctx);

    	return {
    		c() {
    			div = element("div");
    			input0 = element("input");
    			t0 = space();
    			input1 = element("input");
    			t1 = space();
    			input2 = element("input");
    			t2 = space();
    			if (if_block) if_block.c();
    			attr(input0, "aria-label", "hue chanel color");
    			input0.value = /*h*/ ctx[8];
    			attr(input0, "type", "number");
    			attr(input0, "min", "0");
    			attr(input0, "max", "360");
    			attr(input0, "class", "svelte-11z4jba");
    			attr(input1, "aria-label", "saturation chanel color");
    			input1.value = /*s*/ ctx[7];
    			attr(input1, "type", "number");
    			attr(input1, "min", "0");
    			attr(input1, "max", "100");
    			attr(input1, "class", "svelte-11z4jba");
    			attr(input2, "aria-label", "brightness chanel color");
    			input2.value = /*v*/ ctx[6];
    			attr(input2, "type", "number");
    			attr(input2, "min", "0");
    			attr(input2, "max", "100");
    			attr(input2, "class", "svelte-11z4jba");
    			attr(div, "class", "input-container svelte-11z4jba");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, input0);
    			append(div, t0);
    			append(div, input1);
    			append(div, t1);
    			append(div, input2);
    			append(div, t2);
    			if (if_block) if_block.m(div, null);

    			if (!mounted) {
    				dispose = [
    					listen(input0, "input", /*updateHsv*/ ctx[12]('h')),
    					listen(input1, "input", /*updateHsv*/ ctx[12]('s')),
    					listen(input2, "input", /*updateHsv*/ ctx[12]('v'))
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*h*/ 256 && input0.value !== /*h*/ ctx[8]) {
    				input0.value = /*h*/ ctx[8];
    			}

    			if (dirty & /*s*/ 128 && input1.value !== /*s*/ ctx[7]) {
    				input1.value = /*s*/ ctx[7];
    			}

    			if (dirty & /*v*/ 64 && input2.value !== /*v*/ ctx[6]) {
    				input2.value = /*v*/ ctx[6];
    			}

    			if (/*isAlpha*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_5(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    // (47:22) 
    function create_if_block_3$2(ctx) {
    	let div;
    	let input0;
    	let input0_value_value;
    	let t0;
    	let input1;
    	let input1_value_value;
    	let t1;
    	let input2;
    	let input2_value_value;
    	let t2;
    	let mounted;
    	let dispose;
    	let if_block = /*isAlpha*/ ctx[2] && create_if_block_4$1(ctx);

    	return {
    		c() {
    			div = element("div");
    			input0 = element("input");
    			t0 = space();
    			input1 = element("input");
    			t1 = space();
    			input2 = element("input");
    			t2 = space();
    			if (if_block) if_block.c();
    			attr(input0, "aria-label", "red chanel color");
    			input0.value = input0_value_value = /*rgb*/ ctx[0].r;
    			attr(input0, "type", "number");
    			attr(input0, "min", "0");
    			attr(input0, "max", "255");
    			attr(input0, "class", "svelte-11z4jba");
    			attr(input1, "aria-label", "green chanel color");
    			input1.value = input1_value_value = /*rgb*/ ctx[0].g;
    			attr(input1, "type", "number");
    			attr(input1, "min", "0");
    			attr(input1, "max", "255");
    			attr(input1, "class", "svelte-11z4jba");
    			attr(input2, "aria-label", "blue chanel color");
    			input2.value = input2_value_value = /*rgb*/ ctx[0].b;
    			attr(input2, "type", "number");
    			attr(input2, "min", "0");
    			attr(input2, "max", "255");
    			attr(input2, "class", "svelte-11z4jba");
    			attr(div, "class", "input-container svelte-11z4jba");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, input0);
    			append(div, t0);
    			append(div, input1);
    			append(div, t1);
    			append(div, input2);
    			append(div, t2);
    			if (if_block) if_block.m(div, null);

    			if (!mounted) {
    				dispose = [
    					listen(input0, "input", /*updateRgb*/ ctx[11]('r')),
    					listen(input1, "input", /*updateRgb*/ ctx[11]('g')),
    					listen(input2, "input", /*updateRgb*/ ctx[11]('b'))
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*rgb*/ 1 && input0_value_value !== (input0_value_value = /*rgb*/ ctx[0].r) && input0.value !== input0_value_value) {
    				input0.value = input0_value_value;
    			}

    			if (dirty & /*rgb*/ 1 && input1_value_value !== (input1_value_value = /*rgb*/ ctx[0].g) && input1.value !== input1_value_value) {
    				input1.value = input1_value_value;
    			}

    			if (dirty & /*rgb*/ 1 && input2_value_value !== (input2_value_value = /*rgb*/ ctx[0].b) && input2.value !== input2_value_value) {
    				input2.value = input2_value_value;
    			}

    			if (/*isAlpha*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$1(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    // (32:1) {#if mode === 0}
    function create_if_block_1$2(ctx) {
    	let div;
    	let input;
    	let t;
    	let mounted;
    	let dispose;
    	let if_block = /*isAlpha*/ ctx[2] && create_if_block_2$2(ctx);

    	return {
    		c() {
    			div = element("div");
    			input = element("input");
    			t = space();
    			if (if_block) if_block.c();
    			input.value = /*hex*/ ctx[1];
    			set_style(input, "flex", "3");
    			attr(input, "class", "svelte-11z4jba");
    			attr(div, "class", "input-container svelte-11z4jba");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, input);
    			append(div, t);
    			if (if_block) if_block.m(div, null);

    			if (!mounted) {
    				dispose = listen(input, "input", /*updateHex*/ ctx[10]);
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*hex*/ 2 && input.value !== /*hex*/ ctx[1]) {
    				input.value = /*hex*/ ctx[1];
    			}

    			if (/*isAlpha*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$2(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (111:3) {#if isAlpha}
    function create_if_block_5(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			input = element("input");
    			attr(input, "aria-label", "transparency chanel color");
    			input.value = /*a*/ ctx[5];
    			attr(input, "type", "number");
    			attr(input, "min", "0");
    			attr(input, "max", "1");
    			attr(input, "step", "0.01");
    			attr(input, "class", "svelte-11z4jba");
    		},
    		m(target, anchor) {
    			insert(target, input, anchor);

    			if (!mounted) {
    				dispose = listen(input, "input", /*updateHsv*/ ctx[12]('a'));
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*a*/ 32 && input.value !== /*a*/ ctx[5]) {
    				input.value = /*a*/ ctx[5];
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(input);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (73:3) {#if isAlpha}
    function create_if_block_4$1(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			input = element("input");
    			attr(input, "aria-label", "transparency chanel color");
    			input.value = /*a*/ ctx[5];
    			attr(input, "type", "number");
    			attr(input, "min", "0");
    			attr(input, "max", "1");
    			attr(input, "step", "0.01");
    			attr(input, "class", "svelte-11z4jba");
    		},
    		m(target, anchor) {
    			insert(target, input, anchor);

    			if (!mounted) {
    				dispose = listen(input, "input", /*updateRgb*/ ctx[11]('a'));
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*a*/ 32 && input.value !== /*a*/ ctx[5]) {
    				input.value = /*a*/ ctx[5];
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(input);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (35:3) {#if isAlpha}
    function create_if_block_2$2(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			input = element("input");
    			attr(input, "aria-label", "hexadecimal color");
    			input.value = /*a*/ ctx[5];
    			attr(input, "type", "number");
    			attr(input, "min", "0");
    			attr(input, "max", "1");
    			attr(input, "step", "0.01");
    			attr(input, "class", "svelte-11z4jba");
    		},
    		m(target, anchor) {
    			insert(target, input, anchor);

    			if (!mounted) {
    				dispose = listen(input, "input", /*updateRgb*/ ctx[11]('a'));
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*a*/ 32 && input.value !== /*a*/ ctx[5]) {
    				input.value = /*a*/ ctx[5];
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(input);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (125:1) {#if canChangeMode}
    function create_if_block$4(ctx) {
    	let button;
    	let t_value = /*modes*/ ctx[9][/*mode*/ ctx[4]] + "";
    	let t;
    	let button_aria_label_value;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			t = text(t_value);
    			attr(button, "aria-label", button_aria_label_value = "change inputs to " + /*modes*/ ctx[9][(/*mode*/ ctx[4] + 1) % 3]);
    			attr(button, "class", "svelte-11z4jba");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, t);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[14]);
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*mode*/ 16 && t_value !== (t_value = /*modes*/ ctx[9][/*mode*/ ctx[4]] + "")) set_data(t, t_value);

    			if (dirty & /*mode*/ 16 && button_aria_label_value !== (button_aria_label_value = "change inputs to " + /*modes*/ ctx[9][(/*mode*/ ctx[4] + 1) % 3])) {
    				attr(button, "aria-label", button_aria_label_value);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function create_fragment$k(ctx) {
    	let div;
    	let t;

    	function select_block_type(ctx, dirty) {
    		if (/*mode*/ ctx[4] === 0) return create_if_block_1$2;
    		if (/*mode*/ ctx[4] === 1) return create_if_block_3$2;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*canChangeMode*/ ctx[3] && create_if_block$4(ctx);

    	return {
    		c() {
    			div = element("div");
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr(div, "class", "text-input svelte-11z4jba");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			if_block0.m(div, null);
    			append(div, t);
    			if (if_block1) if_block1.m(div, null);
    		},
    		p(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div, t);
    				}
    			}

    			if (/*canChangeMode*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$4(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};
    }

    const HEX_COLOR_REGEX = /^#?([A-F0-9]{6}|[A-F0-9]{8})$/i;

    function instance$j($$self, $$props, $$invalidate) {
    	let h;
    	let s;
    	let v;
    	let a;
    	let { isAlpha } = $$props;
    	let { rgb } = $$props;
    	let { hsv } = $$props;
    	let { hex } = $$props;
    	let { canChangeMode } = $$props;
    	const modes = ['HEX', 'RGB', 'HSV'];
    	let mode = 0;

    	function updateHex(e) {
    		const target = e.target;

    		if (HEX_COLOR_REGEX.test(target.value)) {
    			$$invalidate(1, hex = target.value);
    		}
    	}

    	function updateRgb(property) {
    		return function (e) {
    			$$invalidate(0, rgb = {
    				...rgb,
    				[property]: parseFloat(e.target.value)
    			});
    		};
    	}

    	function updateHsv(property) {
    		return function (e) {
    			$$invalidate(13, hsv = {
    				...hsv,
    				[property]: parseFloat(e.target.value)
    			});
    		};
    	}

    	const click_handler = () => $$invalidate(4, mode = (mode + 1) % 3);

    	$$self.$$set = $$props => {
    		if ('isAlpha' in $$props) $$invalidate(2, isAlpha = $$props.isAlpha);
    		if ('rgb' in $$props) $$invalidate(0, rgb = $$props.rgb);
    		if ('hsv' in $$props) $$invalidate(13, hsv = $$props.hsv);
    		if ('hex' in $$props) $$invalidate(1, hex = $$props.hex);
    		if ('canChangeMode' in $$props) $$invalidate(3, canChangeMode = $$props.canChangeMode);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*hsv*/ 8192) {
    			$$invalidate(8, h = Math.round(hsv.h));
    		}

    		if ($$self.$$.dirty & /*hsv*/ 8192) {
    			$$invalidate(7, s = Math.round(hsv.s));
    		}

    		if ($$self.$$.dirty & /*hsv*/ 8192) {
    			$$invalidate(6, v = Math.round(hsv.v));
    		}

    		if ($$self.$$.dirty & /*hsv*/ 8192) {
    			$$invalidate(5, a = hsv.a === undefined ? 1 : Math.round(hsv.a * 100) / 100);
    		}
    	};

    	return [
    		rgb,
    		hex,
    		isAlpha,
    		canChangeMode,
    		mode,
    		a,
    		v,
    		s,
    		h,
    		modes,
    		updateHex,
    		updateRgb,
    		updateHsv,
    		hsv,
    		click_handler
    	];
    }

    class TextInput extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$j, create_fragment$k, safe_not_equal, {
    			isAlpha: 2,
    			rgb: 0,
    			hsv: 13,
    			hex: 1,
    			canChangeMode: 3
    		});
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\default\SliderIndicator.svelte generated by Svelte v3.50.1 */

    function create_fragment$j(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "slider-indicator svelte-13znx8u");
    			set_style(div, "top", /*top*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*top*/ 1) {
    				set_style(div, "top", /*top*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let top;
    	let { pos } = $$props;
    	let { toRight } = $$props;

    	$$self.$$set = $$props => {
    		if ('pos' in $$props) $$invalidate(1, pos = $$props.pos);
    		if ('toRight' in $$props) $$invalidate(2, toRight = $$props.toRight);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*pos*/ 2) {
    			$$invalidate(0, top = `calc(${pos} * (var(--picker-height, 200px) - 14px) / 100 + 2px)`);
    		}
    	};

    	return [top, pos, toRight];
    }

    class SliderIndicator$1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$i, create_fragment$j, safe_not_equal, { pos: 1, toRight: 2 });
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\default\PickerIndicator.svelte generated by Svelte v3.50.1 */

    function create_fragment$i(ctx) {
    	let div;
    	let div_style_value;

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "picker-indicator svelte-1nw247x");
    			attr(div, "style", div_style_value = `left: ${/*left*/ ctx[2]}; top: ${/*top*/ ctx[1]}; box-shadow: 0 0 4px ${/*isDark*/ ctx[0] ? 'white' : 'black'};`);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*left, top, isDark*/ 7 && div_style_value !== (div_style_value = `left: ${/*left*/ ctx[2]}; top: ${/*top*/ ctx[1]}; box-shadow: 0 0 4px ${/*isDark*/ ctx[0] ? 'white' : 'black'};`)) {
    				attr(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let left;
    	let top;
    	let { pos } = $$props;
    	let { hex } = $$props;
    	let { isDark } = $$props;

    	$$self.$$set = $$props => {
    		if ('pos' in $$props) $$invalidate(3, pos = $$props.pos);
    		if ('hex' in $$props) $$invalidate(4, hex = $$props.hex);
    		if ('isDark' in $$props) $$invalidate(0, isDark = $$props.isDark);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*pos*/ 8) {
    			$$invalidate(2, left = `calc(${pos.x} * (var(--picker-width, 200px) - 14px) / 100 + 2px)`);
    		}

    		if ($$self.$$.dirty & /*pos*/ 8) {
    			$$invalidate(1, top = `calc(${pos.y} * (var(--picker-height, 200px) - 14px) / 100 + 2px)`);
    		}
    	};

    	return [isDark, top, left, pos, hex];
    }

    class PickerIndicator$1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$h, create_fragment$i, safe_not_equal, { pos: 3, hex: 4, isDark: 0 });
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\ArrowKeyHandler.svelte generated by Svelte v3.50.1 */

    function create_fragment$h(ctx) {
    	let mounted;
    	let dispose;

    	return {
    		c: noop,
    		m(target, anchor) {
    			if (!mounted) {
    				dispose = [
    					listen(window, "keyup", /*keyup*/ ctx[0]),
    					listen(window, "keydown", /*keydown*/ ctx[1])
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $keyPressed;
    	component_subscribe($$self, keyPressed, $$value => $$invalidate(2, $keyPressed = $$value));

    	function keyup(e) {
    		if (['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].includes(e.key)) {
    			set_store_value(keyPressed, $keyPressed[e.key] = 0, $keyPressed);
    			keyPressed.set($keyPressed);
    		}
    	}

    	function keydown(e) {
    		if (['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].includes(e.key)) {
    			if (!e.repeat) {
    				set_store_value(keyPressed, $keyPressed[e.key] = 1, $keyPressed);
    				keyPressed.set($keyPressed);
    			}
    		}
    	}

    	return [keyup, keydown];
    }

    class ArrowKeyHandler extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$g, create_fragment$h, safe_not_equal, {});
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\default\PickerWrapper.svelte generated by Svelte v3.50.1 */

    function create_fragment$g(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	return {
    		c() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr(div, "class", "picker-wrapper svelte-1hhmcjg");
    			toggle_class(div, "focused", /*focused*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*focused*/ 1) {
    				toggle_class(div, "focused", /*focused*/ ctx[0]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { focused } = $$props;
    	let { toRight } = $$props;

    	$$self.$$set = $$props => {
    		if ('focused' in $$props) $$invalidate(0, focused = $$props.focused);
    		if ('toRight' in $$props) $$invalidate(1, toRight = $$props.toRight);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	return [focused, toRight, $$scope, slots];
    }

    class PickerWrapper$1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$f, create_fragment$g, safe_not_equal, { focused: 0, toRight: 1 });
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\default\SliderWrapper.svelte generated by Svelte v3.50.1 */

    function create_fragment$f(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	return {
    		c() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr(div, "class", "slider-wrapper svelte-1udewng");
    			toggle_class(div, "focused", /*focused*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*focused*/ 1) {
    				toggle_class(div, "focused", /*focused*/ ctx[0]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { focused } = $$props;
    	let { toRight } = $$props;

    	$$self.$$set = $$props => {
    		if ('focused' in $$props) $$invalidate(0, focused = $$props.focused);
    		if ('toRight' in $$props) $$invalidate(1, toRight = $$props.toRight);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	return [focused, toRight, $$scope, slots];
    }

    class SliderWrapper$1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$e, create_fragment$f, safe_not_equal, { focused: 0, toRight: 1 });
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\default\Input.svelte generated by Svelte v3.50.1 */

    function create_fragment$e(ctx) {
    	let label_1;
    	let div2;
    	let input;
    	let t0;
    	let div0;
    	let t1;
    	let div1;
    	let t2;
    	let t3;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			label_1 = element("label");
    			div2 = element("div");
    			input = element("input");
    			t0 = space();
    			div0 = element("div");
    			t1 = space();
    			div1 = element("div");
    			t2 = space();
    			t3 = text(/*label*/ ctx[2]);
    			attr(input, "type", "color");
    			input.value = /*hex*/ ctx[1];
    			attr(input, "aria-haspopup", "dialog");
    			attr(input, "class", "svelte-2ybi8r");
    			attr(div0, "class", "alpha svelte-2ybi8r");
    			attr(div1, "class", "color svelte-2ybi8r");
    			set_style(div1, "background", /*hex*/ ctx[1]);
    			attr(div2, "class", "container svelte-2ybi8r");
    			attr(label_1, "class", "svelte-2ybi8r");
    		},
    		m(target, anchor) {
    			insert(target, label_1, anchor);
    			append(label_1, div2);
    			append(div2, input);
    			append(div2, t0);
    			append(div2, div0);
    			append(div2, t1);
    			append(div2, div1);
    			append(label_1, t2);
    			append(label_1, t3);
    			/*label_1_binding*/ ctx[4](label_1);

    			if (!mounted) {
    				dispose = [
    					listen(input, "click", prevent_default(click_handler)),
    					listen(input, "mousedown", prevent_default(mousedown_handler)),
    					listen(label_1, "click", prevent_default(click_handler_1)),
    					listen(label_1, "mousedown", prevent_default(mousedown_handler_1))
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*hex*/ 2) {
    				input.value = /*hex*/ ctx[1];
    			}

    			if (dirty & /*hex*/ 2) {
    				set_style(div1, "background", /*hex*/ ctx[1]);
    			}

    			if (dirty & /*label*/ 4) set_data(t3, /*label*/ ctx[2]);
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(label_1);
    			/*label_1_binding*/ ctx[4](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    const click_handler = () => {
    	
    }; /* prevent default behavior on most browsers */

    const mousedown_handler = () => {
    	
    }; /* prevent default behavior on safari */

    const click_handler_1 = () => {
    	
    }; /* prevent default behavior on safari */

    const mousedown_handler_1 = () => {
    	
    }; /* prevent default behavior on safari */

    function instance$d($$self, $$props, $$invalidate) {
    	let { labelWrapper } = $$props;
    	let { hex } = $$props;
    	let { label } = $$props;
    	let { isOpen } = $$props;

    	function label_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			labelWrapper = $$value;
    			$$invalidate(0, labelWrapper);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('labelWrapper' in $$props) $$invalidate(0, labelWrapper = $$props.labelWrapper);
    		if ('hex' in $$props) $$invalidate(1, hex = $$props.hex);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    		if ('isOpen' in $$props) $$invalidate(3, isOpen = $$props.isOpen);
    	};

    	return [labelWrapper, hex, label, isOpen, label_1_binding];
    }

    class Input extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$d, create_fragment$e, safe_not_equal, {
    			labelWrapper: 0,
    			hex: 1,
    			label: 2,
    			isOpen: 3
    		});
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\default\Wrapper.svelte generated by Svelte v3.50.1 */

    function create_fragment$d(ctx) {
    	let div;
    	let div_role_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	return {
    		c() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr(div, "class", "wrapper svelte-6lhts");
    			attr(div, "role", div_role_value = /*isPopup*/ ctx[2] ? 'dialog' : undefined);
    			attr(div, "aria-label", "color picker");
    			toggle_class(div, "isOpen", /*isOpen*/ ctx[1]);
    			toggle_class(div, "isPopup", /*isPopup*/ ctx[2]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[6](div);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*isPopup*/ 4 && div_role_value !== (div_role_value = /*isPopup*/ ctx[2] ? 'dialog' : undefined)) {
    				attr(div, "role", div_role_value);
    			}

    			if (!current || dirty & /*isOpen*/ 2) {
    				toggle_class(div, "isOpen", /*isOpen*/ ctx[1]);
    			}

    			if (!current || dirty & /*isPopup*/ 4) {
    				toggle_class(div, "isPopup", /*isPopup*/ ctx[2]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[6](null);
    		}
    	};
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { wrapper } = $$props;
    	let { isOpen } = $$props;
    	let { isPopup } = $$props;
    	let { toRight } = $$props;

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			wrapper = $$value;
    			$$invalidate(0, wrapper);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('wrapper' in $$props) $$invalidate(0, wrapper = $$props.wrapper);
    		if ('isOpen' in $$props) $$invalidate(1, isOpen = $$props.isOpen);
    		if ('isPopup' in $$props) $$invalidate(2, isPopup = $$props.isPopup);
    		if ('toRight' in $$props) $$invalidate(3, toRight = $$props.toRight);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	return [wrapper, isOpen, isPopup, toRight, $$scope, slots, div_binding];
    }

    class Wrapper$1 extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$c, create_fragment$d, safe_not_equal, {
    			wrapper: 0,
    			isOpen: 1,
    			isPopup: 2,
    			toRight: 3
    		});
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\default\A11yNotice.svelte generated by Svelte v3.50.1 */

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i].contrast;
    	child_ctx[10] = list[i].hex;
    	child_ctx[11] = list[i].placeholder;
    	child_ctx[12] = list[i].reverse;
    	child_ctx[13] = list[i].size;
    	return child_ctx;
    }

    // (20:2) {#each _a11yColors as { contrast, hex: a11yHex, placeholder, reverse, size }}
    function create_each_block$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*components*/ ctx[0].a11ySingleNotice;

    	function switch_props(ctx) {
    		return {
    			props: {
    				contrast: /*contrast*/ ctx[9],
    				textColor: /*reverse*/ ctx[12]
    				? /*a11yHex*/ ctx[10]
    				: /*hex*/ ctx[1],
    				bgColor: /*reverse*/ ctx[12]
    				? /*hex*/ ctx[1]
    				: /*a11yHex*/ ctx[10],
    				placeholder: /*placeholder*/ ctx[11],
    				size: /*size*/ ctx[13]
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*_a11yColors*/ 16) switch_instance_changes.contrast = /*contrast*/ ctx[9];

    			if (dirty & /*_a11yColors, hex*/ 18) switch_instance_changes.textColor = /*reverse*/ ctx[12]
    			? /*a11yHex*/ ctx[10]
    			: /*hex*/ ctx[1];

    			if (dirty & /*_a11yColors, hex*/ 18) switch_instance_changes.bgColor = /*reverse*/ ctx[12]
    			? /*hex*/ ctx[1]
    			: /*a11yHex*/ ctx[10];

    			if (dirty & /*_a11yColors*/ 16) switch_instance_changes.placeholder = /*placeholder*/ ctx[11];
    			if (dirty & /*_a11yColors*/ 16) switch_instance_changes.size = /*size*/ ctx[13];

    			if (switch_value !== (switch_value = /*components*/ ctx[0].a11ySingleNotice)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (30:2) {#if a11yGuidelines}
    function create_if_block$3(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			attr(span, "class", "svelte-1s4dluu");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    			span.innerHTML = /*a11yGuidelines*/ ctx[2];
    		},
    		p(ctx, dirty) {
    			if (dirty & /*a11yGuidelines*/ 4) span.innerHTML = /*a11yGuidelines*/ ctx[2];		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    function create_fragment$c(ctx) {
    	let details;
    	let summary;
    	let switch_instance;
    	let summary_tabindex_value;
    	let t0;
    	let div;
    	let t1;
    	let details_class_value;
    	let current;
    	var switch_value = /*components*/ ctx[0].a11ySummary;

    	function switch_props(ctx) {
    		return {
    			props: {
    				a11yColors: /*_a11yColors*/ ctx[4],
    				hex: /*hex*/ ctx[1]
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	let each_value = /*_a11yColors*/ ctx[4];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let if_block = /*a11yGuidelines*/ ctx[2] && create_if_block$3(ctx);

    	return {
    		c() {
    			details = element("details");
    			summary = element("summary");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t0 = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			if (if_block) if_block.c();
    			attr(summary, "tabindex", summary_tabindex_value = /*closable*/ ctx[5] ? -1 : undefined);
    			attr(summary, "class", "svelte-1s4dluu");
    			attr(div, "class", "svelte-1s4dluu");
    			attr(details, "class", details_class_value = "a11y-notice " + (/*closable*/ ctx[5] ? 'not-closable' : '') + " svelte-1s4dluu");
    			details.open = /*isA11yOpen*/ ctx[3];
    		},
    		m(target, anchor) {
    			insert(target, details, anchor);
    			append(details, summary);

    			if (switch_instance) {
    				mount_component(switch_instance, summary, null);
    			}

    			append(details, t0);
    			append(details, div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append(div, t1);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*_a11yColors*/ 16) switch_instance_changes.a11yColors = /*_a11yColors*/ ctx[4];
    			if (dirty & /*hex*/ 2) switch_instance_changes.hex = /*hex*/ ctx[1];

    			if (switch_value !== (switch_value = /*components*/ ctx[0].a11ySummary)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, summary, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (!current || dirty & /*closable*/ 32 && summary_tabindex_value !== (summary_tabindex_value = /*closable*/ ctx[5] ? -1 : undefined)) {
    				attr(summary, "tabindex", summary_tabindex_value);
    			}

    			if (dirty & /*components, _a11yColors, hex*/ 19) {
    				each_value = /*_a11yColors*/ ctx[4];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, t1);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (/*a11yGuidelines*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty & /*closable*/ 32 && details_class_value !== (details_class_value = "a11y-notice " + (/*closable*/ ctx[5] ? 'not-closable' : '') + " svelte-1s4dluu")) {
    				attr(details, "class", details_class_value);
    			}

    			if (!current || dirty & /*isA11yOpen*/ 8) {
    				details.open = /*isA11yOpen*/ ctx[3];
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(details);
    			if (switch_instance) destroy_component(switch_instance);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    		}
    	};
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let closable;
    	let _a11yColors;
    	let { components } = $$props;
    	let { a11yColors } = $$props;
    	let { hex } = $$props;
    	let { color } = $$props;
    	let { a11yGuidelines } = $$props;
    	let { isA11yOpen } = $$props;
    	let { isA11yClosable } = $$props;

    	$$self.$$set = $$props => {
    		if ('components' in $$props) $$invalidate(0, components = $$props.components);
    		if ('a11yColors' in $$props) $$invalidate(6, a11yColors = $$props.a11yColors);
    		if ('hex' in $$props) $$invalidate(1, hex = $$props.hex);
    		if ('color' in $$props) $$invalidate(7, color = $$props.color);
    		if ('a11yGuidelines' in $$props) $$invalidate(2, a11yGuidelines = $$props.a11yGuidelines);
    		if ('isA11yOpen' in $$props) $$invalidate(3, isA11yOpen = $$props.isA11yOpen);
    		if ('isA11yClosable' in $$props) $$invalidate(8, isA11yClosable = $$props.isA11yClosable);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isA11yOpen, isA11yClosable*/ 264) {
    			$$invalidate(5, closable = isA11yOpen && !isA11yClosable);
    		}

    		if ($$self.$$.dirty & /*a11yColors, color*/ 192) {
    			$$invalidate(4, _a11yColors = a11yColors.map(a11yColor => ({
    				...a11yColor,
    				contrast: color?.contrast(a11yColor.hex)
    			})));
    		}
    	};

    	return [
    		components,
    		hex,
    		a11yGuidelines,
    		isA11yOpen,
    		_a11yColors,
    		closable,
    		a11yColors,
    		color,
    		isA11yClosable
    	];
    }

    class A11yNotice extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$b, create_fragment$c, safe_not_equal, {
    			components: 0,
    			a11yColors: 6,
    			hex: 1,
    			color: 7,
    			a11yGuidelines: 2,
    			isA11yOpen: 3,
    			isA11yClosable: 8
    		});
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\default\A11ySingleNotice.svelte generated by Svelte v3.50.1 */

    function create_fragment$b(ctx) {
    	let div1;
    	let p0;
    	let t0_value = (/*placeholder*/ ctx[2] || 'Lorem Ipsum') + "";
    	let t0;
    	let p0_class_value;
    	let t1;
    	let div0;
    	let p1;
    	let t2;

    	let t3_value = (/*contrast*/ ctx[3] >= 10
    	? /*contrast*/ ctx[3].toFixed(1)
    	: /*contrast*/ ctx[3]) + "";

    	let t3;
    	let t4;
    	let span0;
    	let t6;
    	let span1;

    	return {
    		c() {
    			div1 = element("div");
    			p0 = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			div0 = element("div");
    			p1 = element("p");
    			t2 = text("contrast: ");
    			t3 = text(t3_value);
    			t4 = space();
    			span0 = element("span");
    			span0.textContent = "AA";
    			t6 = space();
    			span1 = element("span");
    			span1.textContent = "AAA";
    			attr(p0, "class", p0_class_value = "lorem " + (/*size*/ ctx[4] === 'large' && 'large') + " svelte-obnxge");
    			set_style(p0, "color", /*textColor*/ ctx[0]);
    			set_style(p0, "background-color", /*bgColor*/ ctx[1]);
    			attr(p1, "class", "svelte-obnxge");
    			attr(span0, "class", "grade svelte-obnxge");
    			toggle_class(span0, "grade-ok", /*contrast*/ ctx[3] > (/*size*/ ctx[4] === 'large' ? 3 : 4.5));
    			attr(span1, "class", "grade svelte-obnxge");
    			toggle_class(span1, "grade-ok", /*contrast*/ ctx[3] > (/*size*/ ctx[4] === 'large' ? 4.5 : 7));
    			attr(div0, "class", "score svelte-obnxge");
    			attr(div1, "class", "a11y-single-notice svelte-obnxge");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, p0);
    			append(p0, t0);
    			append(div1, t1);
    			append(div1, div0);
    			append(div0, p1);
    			append(p1, t2);
    			append(p1, t3);
    			append(div0, t4);
    			append(div0, span0);
    			append(div0, t6);
    			append(div0, span1);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*placeholder*/ 4 && t0_value !== (t0_value = (/*placeholder*/ ctx[2] || 'Lorem Ipsum') + "")) set_data(t0, t0_value);

    			if (dirty & /*size*/ 16 && p0_class_value !== (p0_class_value = "lorem " + (/*size*/ ctx[4] === 'large' && 'large') + " svelte-obnxge")) {
    				attr(p0, "class", p0_class_value);
    			}

    			if (dirty & /*textColor*/ 1) {
    				set_style(p0, "color", /*textColor*/ ctx[0]);
    			}

    			if (dirty & /*bgColor*/ 2) {
    				set_style(p0, "background-color", /*bgColor*/ ctx[1]);
    			}

    			if (dirty & /*contrast*/ 8 && t3_value !== (t3_value = (/*contrast*/ ctx[3] >= 10
    			? /*contrast*/ ctx[3].toFixed(1)
    			: /*contrast*/ ctx[3]) + "")) set_data(t3, t3_value);

    			if (dirty & /*contrast, size*/ 24) {
    				toggle_class(span0, "grade-ok", /*contrast*/ ctx[3] > (/*size*/ ctx[4] === 'large' ? 3 : 4.5));
    			}

    			if (dirty & /*contrast, size*/ 24) {
    				toggle_class(span1, "grade-ok", /*contrast*/ ctx[3] > (/*size*/ ctx[4] === 'large' ? 4.5 : 7));
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div1);
    		}
    	};
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { textColor } = $$props;
    	let { bgColor } = $$props;
    	let { placeholder = undefined } = $$props;
    	let { contrast = 1 } = $$props;
    	let { size = undefined } = $$props;

    	$$self.$$set = $$props => {
    		if ('textColor' in $$props) $$invalidate(0, textColor = $$props.textColor);
    		if ('bgColor' in $$props) $$invalidate(1, bgColor = $$props.bgColor);
    		if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ('contrast' in $$props) $$invalidate(3, contrast = $$props.contrast);
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    	};

    	return [textColor, bgColor, placeholder, contrast, size];
    }

    class A11ySingleNotice extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$a, create_fragment$b, safe_not_equal, {
    			textColor: 0,
    			bgColor: 1,
    			placeholder: 2,
    			contrast: 3,
    			size: 4
    		});
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\default\A11ySummary.svelte generated by Svelte v3.50.1 */

    function create_fragment$a(ctx) {
    	let t;

    	return {
    		c() {
    			t = text(/*message*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*message*/ 1) set_data(t, /*message*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    function getNumberOfGradeFailed({ contrast, size }) {
    	if (!contrast) {
    		return 1;
    	}

    	if (size === 'large') {
    		return contrast < 3 ? 2 : contrast < 4.5 ? 1 : 0;
    	} else {
    		return contrast < 4.5 ? 2 : contrast < 7 ? 1 : 0;
    	}
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let count;
    	let message;
    	let { a11yColors } = $$props;
    	let { hex } = $$props;

    	$$self.$$set = $$props => {
    		if ('a11yColors' in $$props) $$invalidate(1, a11yColors = $$props.a11yColors);
    		if ('hex' in $$props) $$invalidate(2, hex = $$props.hex);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*a11yColors*/ 2) {
    			$$invalidate(3, count = a11yColors.map(getNumberOfGradeFailed).reduce((acc, c) => acc + c));
    		}

    		if ($$self.$$.dirty & /*count*/ 8) {
    			$$invalidate(0, message = count
    			? ` ${count} contrast grade${count && 's'} fail`
    			: 'Contrast grade information');
    		}
    	};

    	return [message, a11yColors, hex, count];
    }

    class A11ySummary extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$9, create_fragment$a, safe_not_equal, { a11yColors: 1, hex: 2 });
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\ColorPicker.svelte generated by Svelte v3.50.1 */

    function create_else_block(ctx) {
    	let input;

    	return {
    		c() {
    			input = element("input");
    			attr(input, "type", "hidden");
    			input.value = /*hex*/ ctx[2];
    		},
    		m(target, anchor) {
    			insert(target, input, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*hex*/ 4) {
    				input.value = /*hex*/ ctx[2];
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(input);
    		}
    	};
    }

    // (154:1) {#if isInput}
    function create_if_block_3$1(ctx) {
    	let switch_instance;
    	let updating_labelWrapper;
    	let updating_isOpen;
    	let switch_instance_anchor;
    	let current;

    	function switch_instance_labelWrapper_binding(value) {
    		/*switch_instance_labelWrapper_binding*/ ctx[26](value);
    	}

    	function switch_instance_isOpen_binding(value) {
    		/*switch_instance_isOpen_binding*/ ctx[27](value);
    	}

    	var switch_value = /*getComponents*/ ctx[21]().input;

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			hex: /*hex*/ ctx[2],
    			label: /*label*/ ctx[6]
    		};

    		if (/*labelWrapper*/ ctx[19] !== void 0) {
    			switch_instance_props.labelWrapper = /*labelWrapper*/ ctx[19];
    		}

    		if (/*isOpen*/ ctx[3] !== void 0) {
    			switch_instance_props.isOpen = /*isOpen*/ ctx[3];
    		}

    		return { props: switch_instance_props };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, 'labelWrapper', switch_instance_labelWrapper_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'isOpen', switch_instance_isOpen_binding));
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*hex*/ 4) switch_instance_changes.hex = /*hex*/ ctx[2];
    			if (dirty[0] & /*label*/ 64) switch_instance_changes.label = /*label*/ ctx[6];

    			if (!updating_labelWrapper && dirty[0] & /*labelWrapper*/ 524288) {
    				updating_labelWrapper = true;
    				switch_instance_changes.labelWrapper = /*labelWrapper*/ ctx[19];
    				add_flush_callback(() => updating_labelWrapper = false);
    			}

    			if (!updating_isOpen && dirty[0] & /*isOpen*/ 8) {
    				updating_isOpen = true;
    				switch_instance_changes.isOpen = /*isOpen*/ ctx[3];
    				add_flush_callback(() => updating_isOpen = false);
    			}

    			if (switch_value !== (switch_value = /*getComponents*/ ctx[21]().input)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, 'labelWrapper', switch_instance_labelWrapper_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'isOpen', switch_instance_isOpen_binding));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (171:2) {#if isAlpha}
    function create_if_block_2$1(ctx) {
    	let alpha;
    	let updating_a;
    	let updating_isOpen;
    	let current;

    	function alpha_a_binding(value) {
    		/*alpha_a_binding*/ ctx[32](value);
    	}

    	function alpha_isOpen_binding(value) {
    		/*alpha_isOpen_binding*/ ctx[33](value);
    	}

    	let alpha_props = {
    		components: /*getComponents*/ ctx[21](),
    		hex: /*hex*/ ctx[2],
    		toRight: /*toRight*/ ctx[17]
    	};

    	if (/*hsv*/ ctx[1].a !== void 0) {
    		alpha_props.a = /*hsv*/ ctx[1].a;
    	}

    	if (/*isOpen*/ ctx[3] !== void 0) {
    		alpha_props.isOpen = /*isOpen*/ ctx[3];
    	}

    	alpha = new Alpha({ props: alpha_props });
    	binding_callbacks.push(() => bind(alpha, 'a', alpha_a_binding));
    	binding_callbacks.push(() => bind(alpha, 'isOpen', alpha_isOpen_binding));

    	return {
    		c() {
    			create_component(alpha.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(alpha, target, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const alpha_changes = {};
    			if (dirty[0] & /*hex*/ 4) alpha_changes.hex = /*hex*/ ctx[2];
    			if (dirty[0] & /*toRight*/ 131072) alpha_changes.toRight = /*toRight*/ ctx[17];

    			if (!updating_a && dirty[0] & /*hsv*/ 2) {
    				updating_a = true;
    				alpha_changes.a = /*hsv*/ ctx[1].a;
    				add_flush_callback(() => updating_a = false);
    			}

    			if (!updating_isOpen && dirty[0] & /*isOpen*/ 8) {
    				updating_isOpen = true;
    				alpha_changes.isOpen = /*isOpen*/ ctx[3];
    				add_flush_callback(() => updating_isOpen = false);
    			}

    			alpha.$set(alpha_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(alpha.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(alpha.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(alpha, detaching);
    		}
    	};
    }

    // (174:2) {#if isTextInput}
    function create_if_block_1$1(ctx) {
    	let switch_instance;
    	let updating_hex;
    	let updating_rgb;
    	let updating_hsv;
    	let switch_instance_anchor;
    	let current;

    	function switch_instance_hex_binding(value) {
    		/*switch_instance_hex_binding*/ ctx[34](value);
    	}

    	function switch_instance_rgb_binding(value) {
    		/*switch_instance_rgb_binding*/ ctx[35](value);
    	}

    	function switch_instance_hsv_binding(value) {
    		/*switch_instance_hsv_binding*/ ctx[36](value);
    	}

    	var switch_value = /*getComponents*/ ctx[21]().textInput;

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			isAlpha: /*isAlpha*/ ctx[7],
    			canChangeMode: /*canChangeMode*/ ctx[10]
    		};

    		if (/*hex*/ ctx[2] !== void 0) {
    			switch_instance_props.hex = /*hex*/ ctx[2];
    		}

    		if (/*rgb*/ ctx[0] !== void 0) {
    			switch_instance_props.rgb = /*rgb*/ ctx[0];
    		}

    		if (/*hsv*/ ctx[1] !== void 0) {
    			switch_instance_props.hsv = /*hsv*/ ctx[1];
    		}

    		return { props: switch_instance_props };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, 'hex', switch_instance_hex_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'rgb', switch_instance_rgb_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'hsv', switch_instance_hsv_binding));
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*isAlpha*/ 128) switch_instance_changes.isAlpha = /*isAlpha*/ ctx[7];
    			if (dirty[0] & /*canChangeMode*/ 1024) switch_instance_changes.canChangeMode = /*canChangeMode*/ ctx[10];

    			if (!updating_hex && dirty[0] & /*hex*/ 4) {
    				updating_hex = true;
    				switch_instance_changes.hex = /*hex*/ ctx[2];
    				add_flush_callback(() => updating_hex = false);
    			}

    			if (!updating_rgb && dirty[0] & /*rgb*/ 1) {
    				updating_rgb = true;
    				switch_instance_changes.rgb = /*rgb*/ ctx[0];
    				add_flush_callback(() => updating_rgb = false);
    			}

    			if (!updating_hsv && dirty[0] & /*hsv*/ 2) {
    				updating_hsv = true;
    				switch_instance_changes.hsv = /*hsv*/ ctx[1];
    				add_flush_callback(() => updating_hsv = false);
    			}

    			if (switch_value !== (switch_value = /*getComponents*/ ctx[21]().textInput)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, 'hex', switch_instance_hex_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'rgb', switch_instance_rgb_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'hsv', switch_instance_hsv_binding));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (184:2) {#if isA11y}
    function create_if_block$2(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*getComponents*/ ctx[21]().a11yNotice;

    	function switch_props(ctx) {
    		return {
    			props: {
    				components: /*getComponents*/ ctx[21](),
    				a11yColors: /*a11yColors*/ ctx[12],
    				color: /*color*/ ctx[4],
    				hex: /*hex*/ ctx[2],
    				a11yGuidelines: /*a11yGuidelines*/ ctx[13],
    				isA11yOpen: /*isA11yOpen*/ ctx[14],
    				isA11yClosable: /*isA11yClosable*/ ctx[15]
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*a11yColors*/ 4096) switch_instance_changes.a11yColors = /*a11yColors*/ ctx[12];
    			if (dirty[0] & /*color*/ 16) switch_instance_changes.color = /*color*/ ctx[4];
    			if (dirty[0] & /*hex*/ 4) switch_instance_changes.hex = /*hex*/ ctx[2];
    			if (dirty[0] & /*a11yGuidelines*/ 8192) switch_instance_changes.a11yGuidelines = /*a11yGuidelines*/ ctx[13];
    			if (dirty[0] & /*isA11yOpen*/ 16384) switch_instance_changes.isA11yOpen = /*isA11yOpen*/ ctx[14];
    			if (dirty[0] & /*isA11yClosable*/ 32768) switch_instance_changes.isA11yClosable = /*isA11yClosable*/ ctx[15];

    			if (switch_value !== (switch_value = /*getComponents*/ ctx[21]().a11yNotice)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (160:1) <svelte:component this={getComponents().wrapper} bind:wrapper {isOpen} {isPopup} {toRight}>
    function create_default_slot(ctx) {
    	let picker;
    	let updating_s;
    	let updating_v;
    	let updating_isOpen;
    	let t0;
    	let slider;
    	let updating_h;
    	let t1;
    	let t2;
    	let t3;
    	let if_block2_anchor;
    	let current;

    	function picker_s_binding(value) {
    		/*picker_s_binding*/ ctx[28](value);
    	}

    	function picker_v_binding(value) {
    		/*picker_v_binding*/ ctx[29](value);
    	}

    	function picker_isOpen_binding(value) {
    		/*picker_isOpen_binding*/ ctx[30](value);
    	}

    	let picker_props = {
    		components: /*getComponents*/ ctx[21](),
    		h: /*hsv*/ ctx[1].h,
    		toRight: /*toRight*/ ctx[17],
    		isDark: /*isDark*/ ctx[5]
    	};

    	if (/*hsv*/ ctx[1].s !== void 0) {
    		picker_props.s = /*hsv*/ ctx[1].s;
    	}

    	if (/*hsv*/ ctx[1].v !== void 0) {
    		picker_props.v = /*hsv*/ ctx[1].v;
    	}

    	if (/*isOpen*/ ctx[3] !== void 0) {
    		picker_props.isOpen = /*isOpen*/ ctx[3];
    	}

    	picker = new Picker({ props: picker_props });
    	binding_callbacks.push(() => bind(picker, 's', picker_s_binding));
    	binding_callbacks.push(() => bind(picker, 'v', picker_v_binding));
    	binding_callbacks.push(() => bind(picker, 'isOpen', picker_isOpen_binding));

    	function slider_h_binding(value) {
    		/*slider_h_binding*/ ctx[31](value);
    	}

    	let slider_props = {
    		components: /*getComponents*/ ctx[21](),
    		toRight: /*toRight*/ ctx[17]
    	};

    	if (/*hsv*/ ctx[1].h !== void 0) {
    		slider_props.h = /*hsv*/ ctx[1].h;
    	}

    	slider = new Slider({ props: slider_props });
    	binding_callbacks.push(() => bind(slider, 'h', slider_h_binding));
    	let if_block0 = /*isAlpha*/ ctx[7] && create_if_block_2$1(ctx);
    	let if_block1 = /*isTextInput*/ ctx[9] && create_if_block_1$1(ctx);
    	let if_block2 = /*isA11y*/ ctx[11] && create_if_block$2(ctx);

    	return {
    		c() {
    			create_component(picker.$$.fragment);
    			t0 = space();
    			create_component(slider.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m(target, anchor) {
    			mount_component(picker, target, anchor);
    			insert(target, t0, anchor);
    			mount_component(slider, target, anchor);
    			insert(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, t3, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const picker_changes = {};
    			if (dirty[0] & /*hsv*/ 2) picker_changes.h = /*hsv*/ ctx[1].h;
    			if (dirty[0] & /*toRight*/ 131072) picker_changes.toRight = /*toRight*/ ctx[17];
    			if (dirty[0] & /*isDark*/ 32) picker_changes.isDark = /*isDark*/ ctx[5];

    			if (!updating_s && dirty[0] & /*hsv*/ 2) {
    				updating_s = true;
    				picker_changes.s = /*hsv*/ ctx[1].s;
    				add_flush_callback(() => updating_s = false);
    			}

    			if (!updating_v && dirty[0] & /*hsv*/ 2) {
    				updating_v = true;
    				picker_changes.v = /*hsv*/ ctx[1].v;
    				add_flush_callback(() => updating_v = false);
    			}

    			if (!updating_isOpen && dirty[0] & /*isOpen*/ 8) {
    				updating_isOpen = true;
    				picker_changes.isOpen = /*isOpen*/ ctx[3];
    				add_flush_callback(() => updating_isOpen = false);
    			}

    			picker.$set(picker_changes);
    			const slider_changes = {};
    			if (dirty[0] & /*toRight*/ 131072) slider_changes.toRight = /*toRight*/ ctx[17];

    			if (!updating_h && dirty[0] & /*hsv*/ 2) {
    				updating_h = true;
    				slider_changes.h = /*hsv*/ ctx[1].h;
    				add_flush_callback(() => updating_h = false);
    			}

    			slider.$set(slider_changes);

    			if (/*isAlpha*/ ctx[7]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*isAlpha*/ 128) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*isTextInput*/ ctx[9]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*isTextInput*/ 512) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*isA11y*/ ctx[11]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*isA11y*/ 2048) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(picker.$$.fragment, local);
    			transition_in(slider.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o(local) {
    			transition_out(picker.$$.fragment, local);
    			transition_out(slider.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(picker, detaching);
    			if (detaching) detach(t0);
    			destroy_component(slider, detaching);
    			if (detaching) detach(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach(t3);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach(if_block2_anchor);
    		}
    	};
    }

    function create_fragment$9(ctx) {
    	let arrowkeyhandler;
    	let t0;
    	let span_1;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let switch_instance;
    	let updating_wrapper;
    	let current;
    	let mounted;
    	let dispose;
    	arrowkeyhandler = new ArrowKeyHandler({});
    	const if_block_creators = [create_if_block_3$1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isInput*/ ctx[8]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function switch_instance_wrapper_binding(value) {
    		/*switch_instance_wrapper_binding*/ ctx[37](value);
    	}

    	var switch_value = /*getComponents*/ ctx[21]().wrapper;

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			isOpen: /*isOpen*/ ctx[3],
    			isPopup: /*isPopup*/ ctx[16],
    			toRight: /*toRight*/ ctx[17],
    			$$slots: { default: [create_default_slot] },
    			$$scope: { ctx }
    		};

    		if (/*wrapper*/ ctx[20] !== void 0) {
    			switch_instance_props.wrapper = /*wrapper*/ ctx[20];
    		}

    		return { props: switch_instance_props };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, 'wrapper', switch_instance_wrapper_binding));
    	}

    	return {
    		c() {
    			create_component(arrowkeyhandler.$$.fragment);
    			t0 = space();
    			span_1 = element("span");
    			if_block.c();
    			t1 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr(span_1, "class", "color-picker svelte-7ntk55");
    		},
    		m(target, anchor) {
    			mount_component(arrowkeyhandler, target, anchor);
    			insert(target, t0, anchor);
    			insert(target, span_1, anchor);
    			if_blocks[current_block_type_index].m(span_1, null);
    			append(span_1, t1);

    			if (switch_instance) {
    				mount_component(switch_instance, span_1, null);
    			}

    			/*span_1_binding*/ ctx[38](span_1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(window, "mousedown", /*mousedown*/ ctx[22]),
    					listen(window, "keyup", /*keyup*/ ctx[23])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(span_1, t1);
    			}

    			const switch_instance_changes = {};
    			if (dirty[0] & /*isOpen*/ 8) switch_instance_changes.isOpen = /*isOpen*/ ctx[3];
    			if (dirty[0] & /*isPopup*/ 65536) switch_instance_changes.isPopup = /*isPopup*/ ctx[16];
    			if (dirty[0] & /*toRight*/ 131072) switch_instance_changes.toRight = /*toRight*/ ctx[17];

    			if (dirty[0] & /*a11yColors, color, hex, a11yGuidelines, isA11yOpen, isA11yClosable, isA11y, isAlpha, canChangeMode, rgb, hsv, isTextInput, toRight, isOpen, isDark*/ 196287 | dirty[1] & /*$$scope*/ 16384) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_wrapper && dirty[0] & /*wrapper*/ 1048576) {
    				updating_wrapper = true;
    				switch_instance_changes.wrapper = /*wrapper*/ ctx[20];
    				add_flush_callback(() => updating_wrapper = false);
    			}

    			if (switch_value !== (switch_value = /*getComponents*/ ctx[21]().wrapper)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, 'wrapper', switch_instance_wrapper_binding));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, span_1, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(arrowkeyhandler.$$.fragment, local);
    			transition_in(if_block);
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(arrowkeyhandler.$$.fragment, local);
    			transition_out(if_block);
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(arrowkeyhandler, detaching);
    			if (detaching) detach(t0);
    			if (detaching) detach(span_1);
    			if_blocks[current_block_type_index].d();
    			if (switch_instance) destroy_component(switch_instance);
    			/*span_1_binding*/ ctx[38](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$8($$self, $$props, $$invalidate) {
    	k([a11yPlugin]);
    	let { components = {} } = $$props;
    	const dispatch = createEventDispatcher();
    	let { label = 'Choose a color' } = $$props;
    	let { isAlpha = true } = $$props;
    	let { isInput = true } = $$props;
    	let { isTextInput = true } = $$props;
    	let { canChangeMode = true } = $$props;
    	let { isA11y = false } = $$props;
    	let { a11yColors = [{ hex: '#ffffff' }] } = $$props;
    	let { a11yGuidelines = '<p style="margin: 0; font-size: 12px;">Learn more at <a href="https://webaim.org/articles/contrast/" target="_blank">WebAIM contrast guide</a></p>' } = $$props;
    	let { isA11yOpen = false } = $$props;
    	let { isA11yClosable = true } = $$props;
    	let { isPopup = isInput } = $$props;
    	let { isOpen = !isInput } = $$props;
    	let { toRight = false } = $$props;
    	let { disableCloseClickOutside = false } = $$props;
    	let { rgb = { r: 255, g: 0, b: 0, a: 1 } } = $$props;
    	let { hsv = { h: 0, s: 100, v: 100, a: 1 } } = $$props;
    	let { hex = '#ff0000' } = $$props;
    	let { color = undefined } = $$props;
    	let { isDark = false } = $$props;

    	/**
     * Internal old value to trigger color conversion
     */
    	let _rgb = { r: 255, g: 0, b: 0, a: 1 };

    	let _hsv = { h: 0, s: 100, v: 100, a: 1 };
    	let _hex = '#ff0000';
    	let span;

    	const default_components = {
    		sliderIndicator: SliderIndicator$1,
    		pickerIndicator: PickerIndicator$1,
    		alphaIndicator: SliderIndicator$1,
    		pickerWrapper: PickerWrapper$1,
    		sliderWrapper: SliderWrapper$1,
    		alphaWrapper: SliderWrapper$1,
    		textInput: TextInput,
    		a11yNotice: A11yNotice,
    		a11ySingleNotice: A11ySingleNotice,
    		a11ySummary: A11ySummary,
    		input: Input,
    		wrapper: Wrapper$1
    	};

    	function getComponents() {
    		return { ...default_components, ...components };
    	}

    	let labelWrapper;
    	let wrapper;

    	function mousedown({ target }) {
    		if (isInput) {
    			if (labelWrapper.contains(target) || labelWrapper.isSameNode(target)) {
    				$$invalidate(3, isOpen = !isOpen);
    			} else if (isOpen && !wrapper.contains(target) && !disableCloseClickOutside) {
    				$$invalidate(3, isOpen = false);
    			}
    		}
    	}

    	function keyup(e) {
    		if (e.key === 'Tab' && isPopup) {
    			$$invalidate(3, isOpen = span?.contains(document.activeElement));
    		}
    	}

    	/**
     * using a function seems to trigger the exported value change only once when all of them has been updated
     * and not just after the hsv change
     */
    	function updateColor() {
    		if (hsv.h === _hsv.h && hsv.s === _hsv.s && hsv.v === _hsv.v && hsv.a === _hsv.a && rgb.r === _rgb.r && rgb.g === _rgb.g && rgb.b === _rgb.b && rgb.a === _rgb.a && hex === _hex) {
    			return;
    		}

    		// reinitialize empty alpha values
    		if (hsv.a === undefined) $$invalidate(1, hsv.a = 1, hsv);

    		if (_hsv.a === undefined) _hsv.a = 1;
    		if (rgb.a === undefined) $$invalidate(0, rgb.a = 1, rgb);
    		if (_rgb.a === undefined) _rgb.a = 1;
    		if (hex?.substring(7) === 'ff') $$invalidate(2, hex = hex.substring(0, 7));
    		if (hex?.substring(7) === 'ff') $$invalidate(2, hex = hex.substring(0, 7));

    		// check which color format changed and updates the others accordingly
    		if (hsv.h !== _hsv.h || hsv.s !== _hsv.s || hsv.v !== _hsv.v || hsv.a !== _hsv.a) {
    			$$invalidate(4, color = w(hsv));
    			$$invalidate(0, rgb = color.toRgb());
    			$$invalidate(2, hex = color.toHex());
    		} else if (rgb.r !== _rgb.r || rgb.g !== _rgb.g || rgb.b !== _rgb.b || rgb.a !== _rgb.a) {
    			$$invalidate(4, color = w(rgb));
    			$$invalidate(2, hex = color.toHex());
    			$$invalidate(1, hsv = color.toHsv());
    		} else if (hex !== _hex) {
    			$$invalidate(4, color = w(hex));
    			$$invalidate(0, rgb = color.toRgb());
    			$$invalidate(1, hsv = color.toHsv());
    		}

    		if (color) {
    			$$invalidate(5, isDark = color.isDark());
    		}

    		// update old colors
    		_hsv = Object.assign({}, hsv);

    		_rgb = Object.assign({}, rgb);
    		_hex = hex;
    		dispatch('input', { color, hsv, rgb, hex });
    	}

    	function switch_instance_labelWrapper_binding(value) {
    		labelWrapper = value;
    		$$invalidate(19, labelWrapper);
    	}

    	function switch_instance_isOpen_binding(value) {
    		isOpen = value;
    		$$invalidate(3, isOpen);
    	}

    	function picker_s_binding(value) {
    		if ($$self.$$.not_equal(hsv.s, value)) {
    			hsv.s = value;
    			$$invalidate(1, hsv);
    		}
    	}

    	function picker_v_binding(value) {
    		if ($$self.$$.not_equal(hsv.v, value)) {
    			hsv.v = value;
    			$$invalidate(1, hsv);
    		}
    	}

    	function picker_isOpen_binding(value) {
    		isOpen = value;
    		$$invalidate(3, isOpen);
    	}

    	function slider_h_binding(value) {
    		if ($$self.$$.not_equal(hsv.h, value)) {
    			hsv.h = value;
    			$$invalidate(1, hsv);
    		}
    	}

    	function alpha_a_binding(value) {
    		if ($$self.$$.not_equal(hsv.a, value)) {
    			hsv.a = value;
    			$$invalidate(1, hsv);
    		}
    	}

    	function alpha_isOpen_binding(value) {
    		isOpen = value;
    		$$invalidate(3, isOpen);
    	}

    	function switch_instance_hex_binding(value) {
    		hex = value;
    		$$invalidate(2, hex);
    	}

    	function switch_instance_rgb_binding(value) {
    		rgb = value;
    		$$invalidate(0, rgb);
    	}

    	function switch_instance_hsv_binding(value) {
    		hsv = value;
    		$$invalidate(1, hsv);
    	}

    	function switch_instance_wrapper_binding(value) {
    		wrapper = value;
    		$$invalidate(20, wrapper);
    	}

    	function span_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			span = $$value;
    			$$invalidate(18, span);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('components' in $$props) $$invalidate(24, components = $$props.components);
    		if ('label' in $$props) $$invalidate(6, label = $$props.label);
    		if ('isAlpha' in $$props) $$invalidate(7, isAlpha = $$props.isAlpha);
    		if ('isInput' in $$props) $$invalidate(8, isInput = $$props.isInput);
    		if ('isTextInput' in $$props) $$invalidate(9, isTextInput = $$props.isTextInput);
    		if ('canChangeMode' in $$props) $$invalidate(10, canChangeMode = $$props.canChangeMode);
    		if ('isA11y' in $$props) $$invalidate(11, isA11y = $$props.isA11y);
    		if ('a11yColors' in $$props) $$invalidate(12, a11yColors = $$props.a11yColors);
    		if ('a11yGuidelines' in $$props) $$invalidate(13, a11yGuidelines = $$props.a11yGuidelines);
    		if ('isA11yOpen' in $$props) $$invalidate(14, isA11yOpen = $$props.isA11yOpen);
    		if ('isA11yClosable' in $$props) $$invalidate(15, isA11yClosable = $$props.isA11yClosable);
    		if ('isPopup' in $$props) $$invalidate(16, isPopup = $$props.isPopup);
    		if ('isOpen' in $$props) $$invalidate(3, isOpen = $$props.isOpen);
    		if ('toRight' in $$props) $$invalidate(17, toRight = $$props.toRight);
    		if ('disableCloseClickOutside' in $$props) $$invalidate(25, disableCloseClickOutside = $$props.disableCloseClickOutside);
    		if ('rgb' in $$props) $$invalidate(0, rgb = $$props.rgb);
    		if ('hsv' in $$props) $$invalidate(1, hsv = $$props.hsv);
    		if ('hex' in $$props) $$invalidate(2, hex = $$props.hex);
    		if ('color' in $$props) $$invalidate(4, color = $$props.color);
    		if ('isDark' in $$props) $$invalidate(5, isDark = $$props.isDark);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*hsv, rgb, hex*/ 7) {
    			if (hsv || rgb || hex) {
    				updateColor();
    			}
    		}
    	};

    	return [
    		rgb,
    		hsv,
    		hex,
    		isOpen,
    		color,
    		isDark,
    		label,
    		isAlpha,
    		isInput,
    		isTextInput,
    		canChangeMode,
    		isA11y,
    		a11yColors,
    		a11yGuidelines,
    		isA11yOpen,
    		isA11yClosable,
    		isPopup,
    		toRight,
    		span,
    		labelWrapper,
    		wrapper,
    		getComponents,
    		mousedown,
    		keyup,
    		components,
    		disableCloseClickOutside,
    		switch_instance_labelWrapper_binding,
    		switch_instance_isOpen_binding,
    		picker_s_binding,
    		picker_v_binding,
    		picker_isOpen_binding,
    		slider_h_binding,
    		alpha_a_binding,
    		alpha_isOpen_binding,
    		switch_instance_hex_binding,
    		switch_instance_rgb_binding,
    		switch_instance_hsv_binding,
    		switch_instance_wrapper_binding,
    		span_1_binding
    	];
    }

    class ColorPicker extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(
    			this,
    			options,
    			instance$8,
    			create_fragment$9,
    			safe_not_equal,
    			{
    				components: 24,
    				label: 6,
    				isAlpha: 7,
    				isInput: 8,
    				isTextInput: 9,
    				canChangeMode: 10,
    				isA11y: 11,
    				a11yColors: 12,
    				a11yGuidelines: 13,
    				isA11yOpen: 14,
    				isA11yClosable: 15,
    				isPopup: 16,
    				isOpen: 3,
    				toRight: 17,
    				disableCloseClickOutside: 25,
    				rgb: 0,
    				hsv: 1,
    				hex: 2,
    				color: 4,
    				isDark: 5
    			},
    			null,
    			[-1, -1]
    		);
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\chrome-picker\PickerIndicator.svelte generated by Svelte v3.50.1 */

    function create_fragment$8(ctx) {
    	let div;
    	let div_style_value;

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "picker-indicator svelte-1nw247x");
    			attr(div, "style", div_style_value = `left: ${/*left*/ ctx[2]}; top: ${/*top*/ ctx[1]}; box-shadow: 0 0 4px ${/*isDark*/ ctx[0] ? 'white' : 'black'};`);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*left, top, isDark*/ 7 && div_style_value !== (div_style_value = `left: ${/*left*/ ctx[2]}; top: ${/*top*/ ctx[1]}; box-shadow: 0 0 4px ${/*isDark*/ ctx[0] ? 'white' : 'black'};`)) {
    				attr(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let left;
    	let top;
    	let { pos } = $$props;
    	let { hex } = $$props;
    	let { isDark } = $$props;

    	$$self.$$set = $$props => {
    		if ('pos' in $$props) $$invalidate(3, pos = $$props.pos);
    		if ('hex' in $$props) $$invalidate(4, hex = $$props.hex);
    		if ('isDark' in $$props) $$invalidate(0, isDark = $$props.isDark);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*pos*/ 8) {
    			$$invalidate(2, left = `calc(${pos.x} * (var(--picker-width, 260px) - 14px) / 100 + 2px)`);
    		}

    		if ($$self.$$.dirty & /*pos*/ 8) {
    			$$invalidate(1, top = `calc(${pos.y} * (var(--picker-height, 200px) - 14px) / 100 + 2px)`);
    		}
    	};

    	return [isDark, top, left, pos, hex];
    }

    class PickerIndicator extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$7, create_fragment$8, safe_not_equal, { pos: 3, hex: 4, isDark: 0 });
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\chrome-picker\PickerWrapper.svelte generated by Svelte v3.50.1 */

    function create_fragment$7(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	return {
    		c() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr(div, "class", "picker-wrapper svelte-607izz");
    			toggle_class(div, "focused", /*focused*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*focused*/ 1) {
    				toggle_class(div, "focused", /*focused*/ ctx[0]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { focused } = $$props;
    	let { toRight } = $$props;

    	$$self.$$set = $$props => {
    		if ('focused' in $$props) $$invalidate(0, focused = $$props.focused);
    		if ('toRight' in $$props) $$invalidate(1, toRight = $$props.toRight);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	return [focused, toRight, $$scope, slots];
    }

    class PickerWrapper extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$6, create_fragment$7, safe_not_equal, { focused: 0, toRight: 1 });
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\chrome-picker\SliderIndicator.svelte generated by Svelte v3.50.1 */

    function create_fragment$6(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "slider-indicator svelte-hspaza");
    			set_style(div, "left", /*left*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*left*/ 1) {
    				set_style(div, "left", /*left*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let left;
    	let { pos } = $$props;
    	let { toRight } = $$props;

    	$$self.$$set = $$props => {
    		if ('pos' in $$props) $$invalidate(1, pos = $$props.pos);
    		if ('toRight' in $$props) $$invalidate(2, toRight = $$props.toRight);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*pos*/ 2) {
    			$$invalidate(0, left = `calc(${pos} * (var(--picker-width, 260px) - 20px) / 100 + 2px)`);
    		}
    	};

    	return [left, pos, toRight];
    }

    class SliderIndicator extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$5, create_fragment$6, safe_not_equal, { pos: 1, toRight: 2 });
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\chrome-picker\SliderWrapper.svelte generated by Svelte v3.50.1 */

    function create_fragment$5(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	return {
    		c() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr(div, "class", "slider-wrapper svelte-1apx9th");
    			toggle_class(div, "focused", /*focused*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*focused*/ 1) {
    				toggle_class(div, "focused", /*focused*/ ctx[0]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { focused } = $$props;
    	let { toRight } = $$props;

    	$$self.$$set = $$props => {
    		if ('focused' in $$props) $$invalidate(0, focused = $$props.focused);
    		if ('toRight' in $$props) $$invalidate(1, toRight = $$props.toRight);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	return [focused, toRight, $$scope, slots];
    }

    class SliderWrapper extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$4, create_fragment$5, safe_not_equal, { focused: 0, toRight: 1 });
    	}
    }

    /* node_modules\svelte-awesome-color-picker\components\variant\chrome-picker\Wrapper.svelte generated by Svelte v3.50.1 */

    function create_fragment$4(ctx) {
    	let div;
    	let div_role_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	return {
    		c() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr(div, "class", "wrapper svelte-13oqf85");
    			attr(div, "role", div_role_value = /*isPopup*/ ctx[2] ? 'dialog' : undefined);
    			attr(div, "aria-label", "color picker");
    			toggle_class(div, "isOpen", /*isOpen*/ ctx[1]);
    			toggle_class(div, "isPopup", /*isPopup*/ ctx[2]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[6](div);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*isPopup*/ 4 && div_role_value !== (div_role_value = /*isPopup*/ ctx[2] ? 'dialog' : undefined)) {
    				attr(div, "role", div_role_value);
    			}

    			if (!current || dirty & /*isOpen*/ 2) {
    				toggle_class(div, "isOpen", /*isOpen*/ ctx[1]);
    			}

    			if (!current || dirty & /*isPopup*/ 4) {
    				toggle_class(div, "isPopup", /*isPopup*/ ctx[2]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[6](null);
    		}
    	};
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { wrapper } = $$props;
    	let { isOpen } = $$props;
    	let { isPopup } = $$props;
    	let { toRight } = $$props;

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			wrapper = $$value;
    			$$invalidate(0, wrapper);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('wrapper' in $$props) $$invalidate(0, wrapper = $$props.wrapper);
    		if ('isOpen' in $$props) $$invalidate(1, isOpen = $$props.isOpen);
    		if ('isPopup' in $$props) $$invalidate(2, isPopup = $$props.isPopup);
    		if ('toRight' in $$props) $$invalidate(3, toRight = $$props.toRight);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	return [wrapper, isOpen, isPopup, toRight, $$scope, slots, div_binding];
    }

    class Wrapper extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$3, create_fragment$4, safe_not_equal, {
    			wrapper: 0,
    			isOpen: 1,
    			isPopup: 2,
    			toRight: 3
    		});
    	}
    }

    const ChromeVariant = {
        sliderIndicator: SliderIndicator,
        pickerIndicator: PickerIndicator,
        alphaIndicator: SliderIndicator,
        pickerWrapper: PickerWrapper,
        sliderWrapper: SliderWrapper,
        alphaWrapper: SliderWrapper,
        wrapper: Wrapper
    };

    /* src\PortDialog.svelte generated by Svelte v3.50.1 */

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (64:12) {#each devices as dev, i}
    function create_each_block(ctx) {
    	let div5;
    	let div4;
    	let div3;
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let span1;
    	let t1_value = /*dev*/ ctx[9] + "";
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[5](/*i*/ ctx[11]);
    	}

    	return {
    		c() {
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.innerHTML = `<span class="icon"><i class="fa fa-plug"></i></span>`;
    			t0 = space();
    			div1 = element("div");
    			span1 = element("span");
    			t1 = text(t1_value);
    			attr(div0, "class", "level-item");
    			attr(div1, "class", "level-item");
    			attr(div2, "class", "level-left");
    			attr(div3, "class", "level");
    			attr(div4, "class", "card-content");
    			attr(div5, "class", "card");
    			attr(div5, "tabindex", /*i*/ ctx[11]);
    		},
    		m(target, anchor) {
    			insert(target, div5, anchor);
    			append(div5, div4);
    			append(div4, div3);
    			append(div3, div2);
    			append(div2, div0);
    			append(div2, t0);
    			append(div2, div1);
    			append(div1, span1);
    			append(span1, t1);

    			if (!mounted) {
    				dispose = listen(div5, "click", click_handler);
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*devices*/ 1 && t1_value !== (t1_value = /*dev*/ ctx[9] + "")) set_data(t1, t1_value);
    		},
    		d(detaching) {
    			if (detaching) detach(div5);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (81:12) {#if ports.length === 0}
    function create_if_block$1(ctx) {
    	let div2;

    	return {
    		c() {
    			div2 = element("div");
    			div2.innerHTML = `<div class="card-content"><div>No paired ports detected</div></div>`;
    			attr(div2, "class", "card");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    		}
    	};
    }

    function create_fragment$3(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let header;
    	let p;
    	let t2;
    	let button0;
    	let t3;
    	let colorpicker;
    	let div;
    	let t4;
    	let section;
    	let t5;
    	let t6;
    	let footer;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;

    	colorpicker = new ColorPicker({
    			props: {
    				components: ChromeVariant,
    				sliderDirection: "horizontal"
    			}
    		});

    	let each_value = /*devices*/ ctx[0];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	let if_block = /*ports*/ ctx[1].length === 0 && create_if_block$1();

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			header = element("header");
    			p = element("p");
    			p.textContent = "Paired Ports";
    			t2 = space();
    			button0 = element("button");
    			t3 = space();
    			div = element("div");
    			create_component(colorpicker.$$.fragment);
    			t4 = space();
    			section = element("section");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t5 = space();
    			if (if_block) if_block.c();
    			t6 = space();
    			footer = element("footer");
    			button1 = element("button");
    			button1.textContent = "Pair new\r\n                port";
    			attr(div0, "class", "modal-background");
    			attr(p, "class", "modal-card-title");
    			attr(button0, "class", "delete");
    			attr(button0, "aria-label", "close");
    			set_style(div, "display", "contents");
    			set_style(div, "--picker-height", "100px");
    			set_style(div, "--picker-width", "100px");
    			set_style(div, "--slider-width", "25px");
    			set_style(div, "--picker-indicator-size", "25px");
    			set_style(div, "--picker-z-index", "10");
    			set_style(div, "--input-size", "100px");
    			set_style(div, "--focus-color", "green");
    			attr(header, "class", "modal-card-head");
    			attr(section, "class", "modal-card-body is-paddingless");
    			attr(button1, "class", "button is-success");
    			attr(footer, "class", "modal-card-foot");
    			attr(div1, "class", "modal-card");
    			attr(div2, "class", "modal is-active svelte-1njnz7e");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			append(div2, t0);
    			append(div2, div1);
    			append(div1, header);
    			append(header, p);
    			append(header, t2);
    			append(header, button0);
    			append(header, t3);
    			append(header, div);
    			mount_component(colorpicker, div, null);
    			append(div1, t4);
    			append(div1, section);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(section, null);
    			}

    			append(section, t5);
    			if (if_block) if_block.m(section, null);
    			append(div1, t6);
    			append(div1, footer);
    			append(footer, button1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(button0, "click", /*onOkClick*/ ctx[2]),
    					listen(button1, "click", /*onDetectNew*/ ctx[4])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*onPortSelected, devices*/ 9) {
    				each_value = /*devices*/ ctx[0];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(section, t5);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*ports*/ ctx[1].length === 0) {
    				if (if_block) ; else {
    					if_block = create_if_block$1();
    					if_block.c();
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(colorpicker.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(colorpicker.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    			destroy_component(colorpicker);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$2($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	const close = () => dispatch('close');
    	let devices = [];
    	let ports = [];

    	async function getPaired() {
    		$$invalidate(1, ports = await navigator.serial.getPorts());

    		$$invalidate(0, devices = ports.map(port => {
    			let info = port.getInfo();
    			let name = 'Serial Port';

    			if (info.usbProductId && info.usbVendorId) {
    				name += ' (usb:0x' + info.usbVendorId.toString(16) + ':0x' + info.usbProductId.toString(16) + ')';
    			}

    			port.name = 'Serial Port';
    			return name;
    		}));
    	}

    	function onOkClick() {
    		close();
    	}

    	function onPortSelected(index) {
    		dispatch('selected_port', ports[index]);
    		close();
    	}

    	function onDetectNew() {
    		navigator.serial.requestPort().then(getPaired);
    	}

    	onMount(getPaired);
    	const click_handler = i => onPortSelected(i);
    	return [devices, ports, onOkClick, onPortSelected, onDetectNew, click_handler];
    }

    class PortDialog extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$2, create_fragment$3, safe_not_equal, {});
    	}
    }

    /* src\SettingsDialog.svelte generated by Svelte v3.50.1 */

    function create_fragment$2(ctx) {
    	let div12;
    	let div0;
    	let t0;
    	let div11;
    	let header;
    	let p0;
    	let t2;
    	let button;
    	let t3;
    	let section;
    	let div3;
    	let label0;
    	let t5;
    	let div2;
    	let div1;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let option6;
    	let t13;
    	let div5;
    	let label1;
    	let t15;
    	let div4;
    	let input0;
    	let t16;
    	let p1;
    	let t18;
    	let div10;
    	let div6;
    	let label2;
    	let input1;
    	let t19;
    	let t20;
    	let div7;
    	let label3;
    	let input2;
    	let t21;
    	let t22;
    	let div9;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			div12 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div11 = element("div");
    			header = element("header");
    			p0 = element("p");
    			p0.textContent = "Settings";
    			t2 = space();
    			button = element("button");
    			t3 = space();
    			section = element("section");
    			div3 = element("div");
    			label0 = element("label");
    			label0.textContent = "Baud rate:";
    			t5 = space();
    			div2 = element("div");
    			div1 = element("div");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "4800";
    			option1 = element("option");
    			option1.textContent = "9600";
    			option2 = element("option");
    			option2.textContent = "19200";
    			option3 = element("option");
    			option3.textContent = "38400";
    			option4 = element("option");
    			option4.textContent = "57600";
    			option5 = element("option");
    			option5.textContent = "115200";
    			option6 = element("option");
    			option6.textContent = "250000";
    			t13 = space();
    			div5 = element("div");
    			label1 = element("label");
    			label1.textContent = "Address in flash for\r\n                    code:";
    			t15 = space();
    			div4 = element("div");
    			input0 = element("input");
    			t16 = space();
    			p1 = element("p");
    			p1.textContent = "If the selected file does not provide the starting address,\r\n                    this address will be used to write the code at. In most\r\n                    cases this is the starting address of the flash memory\r\n                    (STM32: 0x8000000 and STM8: 0x8000).";
    			t18 = space();
    			div10 = element("div");
    			div6 = element("div");
    			label2 = element("label");
    			input1 = element("input");
    			t19 = text(" Use Reply mode (STM8)");
    			t20 = space();
    			div7 = element("div");
    			label3 = element("label");
    			input2 = element("input");
    			t21 = text(" Access MODBUS");
    			t22 = space();
    			div9 = element("div");

    			div9.innerHTML = `<div>Some STM8 device interfaces require &quot;reply&quot; mode for
                        serial communication. See UM0560 for details. Uncheck
                        for STM32.</div>`;

    			attr(div0, "class", "modal-background");
    			attr(p0, "class", "modal-card-title");
    			attr(button, "class", "delete");
    			attr(button, "aria-label", "close");
    			attr(header, "class", "modal-card-head");
    			attr(label0, "class", "label");
    			attr(label0, "for", "baudList");
    			option0.__value = "4800";
    			option0.value = option0.__value;
    			option1.__value = "9600";
    			option1.value = option1.__value;
    			option2.__value = "19200";
    			option2.value = option2.__value;
    			option3.__value = "38400";
    			option3.value = option3.__value;
    			option4.__value = "57600";
    			option4.value = option4.__value;
    			option5.__value = "115200";
    			option5.value = option5.__value;
    			option6.__value = "250000";
    			option6.value = option6.__value;
    			attr(select, "id", "baudList");
    			if (/*settings*/ ctx[0].baudrate === void 0) add_render_callback(() => /*select_change_handler*/ ctx[2].call(select));
    			attr(div1, "class", "select");
    			attr(div2, "class", "control");
    			attr(div3, "class", "field");
    			attr(label1, "class", "label");
    			attr(label1, "for", "startingAddress");
    			attr(input0, "id", "startingAddress");
    			attr(input0, "class", "input");
    			attr(input0, "type", "text");
    			attr(input0, "placeholder", "Start address in flash");
    			attr(div4, "class", "control");
    			attr(p1, "class", "help");
    			attr(div5, "class", "field");
    			attr(input1, "type", "checkbox");
    			attr(label2, "class", "checkbox");
    			attr(div6, "class", "control");
    			attr(input2, "type", "checkbox");
    			attr(label3, "class", "checkbox");
    			attr(div7, "class", "control");
    			attr(div9, "class", "help");
    			attr(div10, "class", "field");
    			attr(section, "class", "modal-card-body");
    			attr(div11, "class", "modal-card");
    			attr(div12, "class", "modal is-active");
    		},
    		m(target, anchor) {
    			insert(target, div12, anchor);
    			append(div12, div0);
    			append(div12, t0);
    			append(div12, div11);
    			append(div11, header);
    			append(header, p0);
    			append(header, t2);
    			append(header, button);
    			append(div11, t3);
    			append(div11, section);
    			append(section, div3);
    			append(div3, label0);
    			append(div3, t5);
    			append(div3, div2);
    			append(div2, div1);
    			append(div1, select);
    			append(select, option0);
    			append(select, option1);
    			append(select, option2);
    			append(select, option3);
    			append(select, option4);
    			append(select, option5);
    			append(select, option6);
    			select_option(select, /*settings*/ ctx[0].baudrate);
    			append(section, t13);
    			append(section, div5);
    			append(div5, label1);
    			append(div5, t15);
    			append(div5, div4);
    			append(div4, input0);
    			set_input_value(input0, /*settings*/ ctx[0].startAddress);
    			append(div5, t16);
    			append(div5, p1);
    			append(section, t18);
    			append(section, div10);
    			append(div10, div6);
    			append(div6, label2);
    			append(label2, input1);
    			input1.checked = /*settings*/ ctx[0].replyMode;
    			append(label2, t19);
    			append(div10, t20);
    			append(div10, div7);
    			append(div7, label3);
    			append(label3, input2);
    			input2.checked = /*settings*/ ctx[0].modbus;
    			append(label3, t21);
    			append(div10, t22);
    			append(div10, div9);

    			if (!mounted) {
    				dispose = [
    					listen(button, "click", /*onOkClick*/ ctx[1]),
    					listen(select, "change", /*select_change_handler*/ ctx[2]),
    					listen(input0, "input", /*input0_input_handler*/ ctx[3]),
    					listen(input1, "change", /*input1_change_handler*/ ctx[4]),
    					listen(input2, "change", /*input2_change_handler*/ ctx[5])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*settings*/ 1) {
    				select_option(select, /*settings*/ ctx[0].baudrate);
    			}

    			if (dirty & /*settings*/ 1 && input0.value !== /*settings*/ ctx[0].startAddress) {
    				set_input_value(input0, /*settings*/ ctx[0].startAddress);
    			}

    			if (dirty & /*settings*/ 1) {
    				input1.checked = /*settings*/ ctx[0].replyMode;
    			}

    			if (dirty & /*settings*/ 1) {
    				input2.checked = /*settings*/ ctx[0].modbus;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div12);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$1($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	const close = () => dispatch('close');

    	function onOkClick() {
    		close();
    	}

    	function select_change_handler() {
    		settings.baudrate = select_value(this);
    		$$invalidate(0, settings);
    	}

    	function input0_input_handler() {
    		settings.startAddress = this.value;
    		$$invalidate(0, settings);
    	}

    	function input1_change_handler() {
    		settings.replyMode = this.checked;
    		$$invalidate(0, settings);
    	}

    	function input2_change_handler() {
    		settings.modbus = this.checked;
    		$$invalidate(0, settings);
    	}

    	return [
    		settings,
    		onOkClick,
    		select_change_handler,
    		input0_input_handler,
    		input1_change_handler,
    		input2_change_handler
    	];
    }

    class SettingsDialog extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1, create_fragment$2, safe_not_equal, {});
    	}
    }

    /* src\NotSupportedDialog.svelte generated by Svelte v3.50.1 */

    function create_fragment$1(ctx) {
    	let div2;

    	return {
    		c() {
    			div2 = element("div");

    			div2.innerHTML = `<div class="modal-background"></div> 
    <div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Browser not supported</p></header> 
        <section class="modal-card-body"><p>Your browser does not support Web Serial API. Check the <a href="https://github.com/Gamadril/stm-serial-flasher">documentation</a> for more info.</p></section></div>`;

    			attr(div2, "class", "modal is-active svelte-1njnz7e");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div2);
    		}
    	};
    }

    class NotSupportedDialog extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, null, create_fragment$1, safe_not_equal, {});
    	}
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    class Serial {
        constructor() {
            this.init();
        }

        init() {
        }

        /**
         * Check if a connection is opened.
         */
        isOpen() {
            return false;
        }

        /**
         * Open the serial port
         * @param {Object} port Port object
         */
        open(port) {
        }

        /**
         * Close the current connection
         */
        close() {
        }

        /**
         * Read data from the serial port
         */
        read() {
        }

        /**
         * Writes data to serial port
         * @param {Uint8Array} data Data to send.
         */
        write(data) {
        }

        /**
         * Set the control signals of the current connection
         * @param {dtr:boolean, rts:boolean} lineParams signal parameters
         */
        control(lineParams) {
        }

        onConnect() {       
        }

        onDisconnect() {
        }
    }

    function info(msg) {
        console.info('[WebSerial] ' + msg);
    }

    class WebSerial extends Serial {
        constructor(port) {
            super();
            if (!(port instanceof SerialPort)) {
                throw new Error('Expected a SerialPort object');
            }
            this._port = port;
            this._reader = null;
            this._writer = null;
        }

        init() {
            navigator.serial.onconnect = this.onConnect.bind(this);
            navigator.serial.ondisconnect = this.onDisconnect.bind(this);
        }

        /**
         * Check if a connection is opened.
         */
        isOpen() {
            return this._writer !== null;
        }

        /**
         * Open the serial port
         * @param {Object} parameter Parameter
         */
        open(parameter) {
            return new Promise((resolve, reject) => {
                info('-> open ' + JSON.stringify(parameter));
                this._port.open(parameter)
                    .then(() => {
                        this._reader = this._port.readable.getReader();
                        this._writer = this._port.writable.getWriter();
                        info('<- open');
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Close the current connection
         */
        close() {
            return new Promise((resolve, reject) => {
                info('-> close');
                this._reader.cancel();
                this._writer.close();
                Promise.all([this._reader.closed, this._writer.closed])
                    .then(() => this._port.close())
                    .then(() => {
                        this._reader = null;
                        this._writer = null;
                        info('<- close');
                        this.onDisconnect();
                        resolve();
                    })
                    .catch((err) => {
                        this._reader = null;
                        this._writer = null;
                        info('<- close reject');
                        reject(err);
                    });
            });
        }

        /**
         * Read data from the serial port
         */
        read() {
            return new Promise(async (resolve, reject) => {
                info('-> read');

                this._reader.read()
                    .then((result) => {
                        console.debug(result);
                        resolve(result.value);
                    })
                    .catch(reject);
            });
        }

        /**
         * Read data from the serial port with a timeout
         * @param {number} timeoutMilliseconds - Timeout in milliseconds
         * @returns {Promise<Buffer>} - Resolves with the received data or rejects on error or timeout
         */
        readWithTimeout(timeoutMilliseconds) {
            return new Promise(async (resolve, reject) => {
                info('-> readWithTimeout');
                
                // Create a timeout promise
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => {
                        reject(new Error('Serial read operation timed out'));
                    }, timeoutMilliseconds);
                });

                // Race between the read operation and the timeout promise
                Promise.race([this._reader.read(), timeoutPromise])
                    .then((result) => {
                        if (result instanceof Error) {
                            reject(result); // Propagate any error from the timeout promise
                        } else {
                            console.debug(result);
                            resolve(result.value);
                        }
                    })
                    .catch(reject);
            });
        }

        /**
         * Writes data to serial port
         * @param {Uint8Array} data Data to send.
         */
        write(data) {
            return new Promise((resolve, reject) => {
                info('-> write');
                console.debug(data);
                this._writer.write(data.buffer)
                    .then(resolve)
                    .catch(reject);
            });
        }

        /**
         * Set the control signals of the current connection
         * @param {dtr:boolean, rts:boolean} lineParams signal parameters
         */
        control(lineParams) {
            return new Promise((resolve, reject) => {
                info('-> control');
                console.debug(lineParams);
                this._port.setSignals(lineParams)
                    .then(() => {
                        resolve();
                    })
                    .catch(reject);
            });
        }
    }

    const tools = {
        /**
         * Parses the content of a s19 file
         * @param {boolean} combine Set to true to combine the data into packages
         * @param {number} blockSize Size of the block to combine data to
         * @param {string} fileContent Content of the s19 file
         * @returns {Array} Array of single records
         * @throws Error
         */
        parseSRec: function (combine, blockSize, fileContent) {
            var lines, i, line, record, checksum, records = [], type, addrLength;

            lines = fileContent.split("\n");
            for (i = 0; i < lines.length; i++) {
                line = lines[i];

                if (line.length === 0) { // skip empty lines
                    continue;
                } else if (line.charAt(0) !== 'S') {
                    throw new Error('Invalid SRecord file format')
                }

                record = {};
                type = parseInt(line.substr(1, 1), 10);
                record.type = null;
                if (type === 1) {
                    addrLength = 4;
                    record.type = 'data';
                } else if (type === 3) {
                    addrLength = 8;
                    record.type = 'data';
                } else if (type === 9) {
                    addrLength = 4;
                    record.type = 'start';
                } else if (type === 7) {
                    addrLength = 8;
                    record.type = 'start';
                } else {
                    continue;
                }
                record.length = parseInt(line.substr(2, 2), 16);
                record.address = parseInt(line.substr(4, addrLength), 16);
                record.data = this.hexstr2uintarray(line.substr(4 + addrLength, (record.length - 3) * 2));
                record.checksum = parseInt(line.substr(-2), 16);

                checksum = (this.sum(this.hexstr2uintarray(line.substring(2, line.length - 2))) & 0xFF) ^ 0xFF;

                if (checksum !== record.checksum) {
                    throw new Error('Checksum in line ' + (i + 1) + ' does not match');
                }

                records.push(record);
            }

            if (combine) {
                records = this.packRecords(records, blockSize);
            }

            return records;
        },

        /**
         * Parses the content of a hex file
         * @param {boolean} combine Set to true to combine the data into packages
         * @param {number} blockSize Size of the block to combine data to
         * @param {string} fileContent Content of the hex file
         * @returns {Array} Array of single records
         * @throws Error
         */
        parseHex: function (combine, blockSize, fileContent) {
            var lines, i, line, record, checksum, records = [], type, base = 0;

            lines = fileContent.split("\n");
            for (i = 0; i < lines.length; i++) {
                line = lines[i];

                if (line.length === 0) { // skip empty lines
                    continue;
                } else if (line.charAt(0) !== ':') {
                    throw new Error('Invalid HEX file format');
                }

                record = {};
                type = parseInt(line.substr(7, 2), 16);
                record.length = parseInt(line.substr(1, 2), 16);
                record.address = parseInt(line.substr(3, 4), 16);
                if (base > 0) {
                    record.address += base;
                }

                record.data = this.hexstr2uintarray(line.substr(9, record.length * 2));
                record.checksum = parseInt(line.substr(-2), 16);

                checksum = this.sum(this.hexstr2uintarray(line.substr(1))) % 256;

                if (checksum !== 0) {
                    throw new Error('Checksum in line ' + (i + 1) + ' does not match');
                }

                record.type = null;
                if (type === 0) {
                    record.type = 'data';
                    records.push(record);
                } else if (type === 4) {
                    base = record.data[0] << 24;
                    base += record.data[1] << 16;
                } else if (type === 5) {
                    record.type = 'start';
                    record.address = parseInt(line.substr(9, record.length * 2), 16);
                    records.push(record);
                }
            }

            if (combine) {
                records = this.packRecords(records, blockSize);
            }

            return records;
        },

        /**
         * Parses the content of a bin file. Actually splits binary data into records
         * @param {number} blockSize Size of the block to split data into
         * @param {ArrayBuffer} fileContent Content of the bin file
         * @returns {Array} Array of single records
         * @throws Error
         */
        parseBin: function (blockSize, fileContent) {
            let records = [];
            let nrRecords = Math.ceil(fileContent.byteLength / blockSize);

            for (let i = 0; i < nrRecords; i++) {
                let start = i * blockSize;
                let end = start + blockSize;
                let chunk = new Uint8Array(fileContent.slice(start, end));
                let record = {
                    data: chunk,
                    type: 'data'
                };
                records.push(record);
            }
            return records;
        },

        /**
         * @private
         * @param {Array} records Array of records to combine
         * @param {number} blockSize Size of the block to combine data to
         * @returns {Array} New recombined records
         */
        packRecords: function (records, blockSize) {
            var record, newRecord, result = [], startAddress, offset = 0, dataBuffer;

            var minAddress = function (records) {
                var record, i, result = -1;

                for (i = 0; i < records.length; i++) {
                    record = records[i];

                    if (result === -1 || result > record.address) {
                        result = record.address;
                    }
                }

                return result;
            };

            var findRecord = function (address) {
                var i;

                for (i = 0; i < records.length; i++) {
                    if (records[i].address === address && records[i].type === 'data') {
                        return records[i];
                    }
                }

                return null;
            };

            var findStartRecord = function () {
                var i;

                for (i = 0; i < records.length; i++) {
                    if (records[i].type === 'start') {
                        return records[i];
                    }
                }

                return null;
            };

            while (true) {
                newRecord = {
                    type: 'data'
                };

                record = findStartRecord();
                if (record) {
                    result.push(record);
                    records.splice(records.indexOf(record), 1);
                    continue;
                }

                startAddress = minAddress(records);

                if (startAddress === -1) {
                    break;
                }

                newRecord.address = startAddress;
                dataBuffer = new Uint8Array(blockSize);

                while ((record = findRecord(startAddress + offset)) !== null) {
                    if (offset + record.data.length > blockSize) {
                        break;
                    } else {
                        dataBuffer.set(record.data, offset);
                        records.splice(records.indexOf(record), 1);
                        offset += record.data.length;
                    }
                }

                if (offset < blockSize) {
                    dataBuffer = dataBuffer.subarray(0, offset);
                }

                offset = 0;
                newRecord.data = dataBuffer;

                result.push(newRecord);
            }

            return result;
        },

        /**
         * Returns the number of data records
         * @param {Array} records Array of records
         * @returns {number} Number of daa records
         */
        countData: function (records) {
            var i, result = 0;
            for (i = 0; i < records.length; i++) {
                if (records[i].type === 'data') {
                    result++;
                }
            }
            return result;
        },

        /**
         * Extracts the extension of a filename
         * @param {string} fileName Name of the file
         * @returns {string} Extension or null if file has no extension
         */
        extension: function (fileName) {
            var result = null, dotIndex = fileName.lastIndexOf('.');

            if (dotIndex !== -1) {
                result = fileName.substr(dotIndex + 1);
            }

            return result;
        },

        /**
         * Calculate the sum of bytes in the array
         * @private
         * @param {Uint8Array} array Array
         * @returns {number} Sum of all values in the array
         */
        sum: function (array) {
            return array.reduce((a, b) => a + b, 0);
        },

        /**
         * Convert a HEX string to Uint8Array
         * @private
         * @param {string} str String
         * @returns {Uint8Array} Result
         */
        hexstr2uintarray: function (str) {
            var result = new Uint8Array(str.length / 2);
            for (var i = 0; i < str.length / 2; i++) {
                result[i] = parseInt(str.substr(i * 2, 2), 16);
            }
            return result;
        },

        /**
         * Convert a string to ArrayBuffer
         * @private
         * @param {string} str String to convert
         * @returns {ArrayBuffer} Result
         */
        str2ab: function (str) {
            var buf = new ArrayBuffer(str.length);
            var bufView = new Uint8Array(buf);
            for (var i = 0; i < str.length; i++) {
                bufView[i] = str.charCodeAt(i);
            }
            return buf;
        },

        /**
         * Convert an array to ArrayBuffer
         * @private
         * @param array
         * @returns {ArrayBuffer} Result
         */
        a2ab: function (array) {
            var buf = new ArrayBuffer(array.length);
            var bufView = new Uint8Array(buf);
            for (var i = 0; i < array.length; i++) {
                bufView[i] = array[i];
            }
            return buf;
        },

        /**
         * Convert ArrayBuffer to array
         * @private
         * @param buffer
         * @returns {Uint8Array}
         */
        ab2a: function (buffer) {
            return new Uint8Array(buffer);
        },

        /**
         * Convert ArrayBuffer to string
         * @private
         * @param {ArrayBuffer} buffer Buffer to convert
         * @returns {string}
         */
        ab2hexstr: function (buffer) {
            var ua = new Uint8Array(buffer);
            var str = "";
            for (var i = 0; i < ua.length; i++) {
                str += this.b2hexstr(ua[i]);
            }
            return str;
        },

        /**
         * Convert byte to hexstr.
         * @param {number} byte Byte to convert
         */
        b2hexstr: function (byte) {
            return ("00" + byte.toString(16)).substr(-2);
        },

        /**
         * @private
         * @param buffer
         * @returns {string}
         */
        ab2str: function (buffer) {
            return String.fromCharCode.apply(null, new Uint8Array(buffer));
        },

        /**
         * @private
         * @param number
         * @param arraySize
         * @returns {Array}
         */
        num2a: function (number, arraySize) {
            var i, temp = number, result = [];

            for (i = 0; i < arraySize; i++) {
                result.unshift(temp & 0xFF);
                temp = temp >> 8;
            }

            return result;
        },

        /**
         * Convert an Uint8Array to array
         * @private
         * @param uiArray
         * @returns {Array}
         */
        uia2a: function (uiArray) {
            var i, result = [];

            for (i = 0; i < uiArray.length; i++) {
                result.push(uiArray[i]);
            }

            return result;
        },

        /**
         * Read the content of the file as text
         * @param {File} file 
         */
        readFile(file) {
            return new Promise((resolve, reject) => {
                let reader = new FileReader();
                reader.onload = () => {
                    resolve(reader.result);
                };
                reader.onerror = () => {
                    reject(reader.error);
                };
                if (file.name.endsWith('.bin')) {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file);
                }
            });
        }
    };

    const MAX_WRITE_BLOCK_SIZE_STM32 = 256;
    const MAX_READ_BLOCK_SIZE = 256;
    const MAX_WRITE_BLOCK_SIZE_STM8 = 128;

    // use control signals to trigger bootloader activation and device hardware reset
    // false = pin hight, true = pin low
    const RTS_PIN = "requestToSend";
    const DTR_PIN = "dataTerminalReady"; // STM32
    const PIN_HIGH = false;
    const PIN_LOW = true;

    const SYNCHR = 0x7F;
    const SYNCHR_ARTERY = 0x7F; //Set host identification number

    const ACK = 0x79;

    const CMD_GET = 0x00;
    const CMD_GV = 0x01;
    // GET ID command used to identify the STM family. If it's present it's STM32, STM8 otherwise
    const CMD_GID = 0x02;
    const CMD_READ = 0x11;
    const CMD_GO = 0x21;
    const CMD_WRITE = 0x31;
    const CMD_ERASE = 0x43;
    const CMD_EXTENDED_ERASE = 0x44;
    const CMD_WPUN = 0x73;
    const CMD_RDU_PRM = 0x92;

    // Address for erase_write_routines for STM8 S/A
    const STM8_WRITE_CODE_ADDRESS = 0xA0;

    const EwrLoadState = Object.freeze({
        NOT_LOADED: Symbol("not_loaded"),
        LOADING: Symbol("loading"),
        LOADED: Symbol("loaded")
    });

    function u8a(array) {
        return new Uint8Array(array);
    }

    class InfoGV {
        constructor() {
            // Bootloader version
            this.blVersion = null;
            // Number of times the read protection was disabled
            this.countRPdisabled = -1;
            // Number of times the read protection was enabled
            this.countRPenabled = -1;
        }
    }

    class InfoGET {
        constructor() {
            // Bootloader version
            this.blVersion = null;
            // List of supported commands
            this.commands = [];
            this.inp0 = 0.0;
            this.inp1 = 0.0;
            this.range_min = 0.0;
            this.range_max = 0.0;
            this.revision = 0;
            this.temperature = 999.0;
        }

        getFamily() {
            return this.commands.indexOf(CMD_GID) === -1 ? 'STM8' : 'STM32';
        }
    }

    class STMApi {
        constructor(serial) {
            if (!serial) {
                throw new Error('Serial port object not provided');
            }
            this.serial = serial;
            // reply mode which is necessary for some STM8 MCUs
            this.replyMode = false;
            // Indicates if the STM8 erase_write_routines are already loaded
            this.ewrLoadState = EwrLoadState.NOT_LOADED;
            // max: STM8 = 128, STM32 = 256. must be mutliple of 4
            this.writeBlockSize = MAX_WRITE_BLOCK_SIZE_STM8;
            this.readBlockSize = MAX_READ_BLOCK_SIZE;
            // list of supported commands by the target
            this.commands = [];
            // name of the stm8 routines file
            this.stm8RoutinesFile = null;
            //Access MODBUS and not Bootloader
            this.modbusEnabled = false;
        }

        /**
         * Initializes erase_write_routines for STM8 S/A
         * @param {flash:"0"|"32"|"128"|"256", blVersion:string} device Flash size of the target MCU
         */
        setDevice(device) {
            this.ewrLoadState = EwrLoadState.NOT_LOADED;

            if (!device.blVersion || !device.flash) {
                return;
            }

            if (device.flash === '0') { // STM8 L
                this.ewrLoadState = EwrLoadState.LOADED;
                return;
            } else if (device.flash !== '32' && device.flash !== '128' && device.flash !== '256') {
                throw new Error('Unsupported device selected: ' + device);
            }

            this.stm8RoutinesFile = 'res/stm8_routines/E_W_ROUTINEs_' + device.flash + 'K_ver_' + device.blVersion + '.bin';
        }

        /**
         * Connect to the target by resetting it and activating the ROM bootloader
         * @param {object} params
         * @returns {Promise}
         */
        async connect(params) {
            this.ewrLoadState = EwrLoadState.NOT_LOADED;
            return new Promise((resolve, reject) => {
                logger.log('Connecting with baudrate ' + params.baudrate + ' and reply mode ' + (params.replyMode ? 'on' : 'off'));
                if (this.serial.isOpen()) {
                    reject(new Error('Port already opened'));
                    return;
                }

                this.replyMode = params.replyMode || false;
                this.modbusEnabled = params.modbus || false;
                this.serial.open({
                    baudRate: parseInt(params.baudrate, 10),
                    parity: (this.replyMode||this.modbusEnabled) ? 'none' : 'even'
                })
                    .then(() => {
                        // set init state of the NRST pin to high
                        // for stm32 set the BOOT0 pin to low.
                        let signal = {};
                        signal[RTS_PIN] = PIN_HIGH; //RESET=1
                        signal[DTR_PIN] = PIN_LOW; //BOOT0=0
                        return this.serial.control(signal);
                        
                    })
                    .then(() => this.activateBootloader())
                    .then(resolve)
                    .catch(error => {
                        if (this.serial.isOpen()) {
                            this.serial.close(function (err) {
                                console.log('port closed', err);
                            });
                        }
                        reject(error);
                    });
            });
        }

        /**
         * Close current connection. Before closing serial connection disable bootloader and reset target
         * @returns {Promise}
         */
        async disconnect() {
            return new Promise((resolve, reject) => {
                let signal = {};
                signal[DTR_PIN] = PIN_LOW; //BOOT=0
                signal[RTS_PIN] = PIN_HIGH; //RESET=1
                this.serial.control(signal)
                    .then(() => this.resetTarget())
                    .then(() => this.serial.close())
                    .then(resolve)
                    .catch(reject);
            });

        }

        /**
         * Write data to memory. If the data exceeds the max frame size it will be splitted and sent in chunks automatically
         * @param {Uint8Array} data Data to write
         * @param {number} address Address to write at
         * @param {Function} onProgress Callback to notify progress
         * @returns {Promise}
         */
        async write(data, address, onProgress) {
            return new Promise(async (resolve, reject) => {
                logger.log('Writing ' + data.length + ' bytes to flash at address 0x' + address.toString(16) + ' using ' + this.writeBlockSize + ' bytes chunks');
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                let blocksCount = Math.ceil(data.byteLength / this.writeBlockSize);

                let offset = 0;
                let blocks = [];
                for (let i = 0; i < blocksCount; i++) {
                    let block = {};

                    if (i < blocksCount - 1) {
                        block.data = data.subarray(offset, offset + this.writeBlockSize);
                    } else {
                        block.data = data.subarray(offset);
                    }
                    offset += block.data.length;
                    blocks.push(block);
                }

                for (let i = 0; i < blocks.length; i++) {
                    let block = blocks[i];
                    try {
                        //logger.log('Writing block ' + (i + 1) + '/' + blocksCount);
                        if (onProgress) {
                            onProgress(i, blocksCount);
                        }
                        await this.cmdWRITE(block.data, address + i * this.writeBlockSize);
                    } catch (e) {
                        reject(e);
                        return;
                    }
                }
                logger.log('Finished writing');
                resolve();
            });
        }

        /**
         * Do a full erase of the flash
         * @returns {Promise}
         */
        async eraseAll() {
            return new Promise(async (resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (this.ewrLoadState == EwrLoadState.NOT_LOADED) {
                    try {
                        await this.sendEWR();
                    } catch (e) {
                        reject(e);
                        return;
                    }
                }

                let eraseCmd, eraseFlash;
                if (this.commands.indexOf(CMD_ERASE) !== -1) {
                    eraseCmd = [CMD_ERASE, 0xFF ^ CMD_ERASE];
                    eraseFlash = [0xFF, 0x00];
                } else if (this.commands.indexOf(CMD_EXTENDED_ERASE) !== -1) {
                    eraseCmd = [CMD_EXTENDED_ERASE, 0xFF ^ CMD_EXTENDED_ERASE];
                    eraseFlash = [0xFF, 0xFF, 0x00];
                } else {
                    reject(new Error('No erase command found'));
                    return;
                }

                this.serial.write(u8a(eraseCmd))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK erase ALL');
                        }
                        return this.serial.write(u8a(eraseFlash));
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while erase ALL');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Executes GET command
         * @returns {Promise<InfoGET>}
         */
        async cmdGET() {
            return new Promise((resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (this.modbusEnabled)
                {
                    //01 03 00 00 00 0D 84 0F
                    this.serial.write(u8a([0x01,0x03,0x00,0x00,0x00,0x0D,0x84,0x0F]))
                    .then(() => this.readResponse())
                    .then(async (resp) => {
                        let response = new Uint8Array(resp);
                        if (response[0] !== 0x1) {
                            throw new Error('Unexpected MODBUS id');
                        }
                        console.log(resp);
                        let info = new InfoGET();
                        // 01 03 1A 00 04 FE F9 03 32 03 14 FF FF FF FF 11 B6 11 0F FF FF FF FF 00 00 03 E8 13 88 C6 3B (31 bytes)
                        info.blVersion = (response[2] >> 4) + '.' + (response[2] & 0x0F);
                        info.revision = (response[3] << 8) | (response[4] );
                        info.temperature = (response[5] << 8) | (response[6] );
                        info.inp0 = (response[7] << 8) | (response[8] );
                        info.inp1 = (response[9] << 8) | (response[10] );

                        console.log(info.temperature);
                        
                        resolve(info);
                    })
                    .catch(reject);
                }
                else
                {
                    this.serial.write(u8a([CMD_GET, 0xFF ^ CMD_GET]))
                    .then(() => this.readResponse())
                    .then(async (resp) => {
                        let response = new Uint8Array(resp);
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdGET');
                        }

                        // if (response.length === 1) { // TODO stm8 sends the bytes with delay. Always or on in reply mode only?
                        //     let res = await this.readResponse();
                        //     response[1] = res[0];
                        //     res = await this.readResponse(); // bl version
                        //     response[2] = res[0];
                        //     for (let i = 0; i <= response[1]; i++) {
                        //         res = await this.readResponse();
                        //         response[3 + i] = res[0];
                        //     }
                        // }

                        while (response.length === 1 || response.length < response[1] + 4) {
                            let res = await this.readResponse();
                            response = new Uint8Array([
                                ...response,
                                ...res
                            ]);
                        }

                        let info = new InfoGET();
                        info.blVersion = (response[2] >> 4) + '.' + (response[2] & 0x0F);
                        for (let i = 0; i < response[1]; i++) {
                            info.commands.push(response[3 + i]);
                        }
                        this.commands = info.commands;
                        if (info.getFamily() === 'STM32') {
                            this.writeBlockSize = MAX_WRITE_BLOCK_SIZE_STM32;
                            this.ewrLoadState = EwrLoadState.LOADED;
                        } else {
                            this.writeBlockSize = MAX_WRITE_BLOCK_SIZE_STM8;
                        }
                        resolve(info);
                    })
                    .catch(reject);
                }
            });
        }

        /**
         * Execute GO command
         * @param {number} address Memory address to start code execution
         * @returns {Promise}
         */
        async cmdGO(address) {
            return new Promise((resolve, reject) => {
                let addressFrame;

                if (!Number.isInteger(address)) {
                    reject(new Error('Invalid address parameter'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                addressFrame = tools.num2a(address, 4);
                addressFrame.push(this.calcChecksum(addressFrame, false));

                this.serial.write(u8a([CMD_GO, 0xFF ^ CMD_GO]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK CMD GO');
                        }
                        return this.serial.write(u8a(addressFrame));
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while CMD GO');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute single READ command
         * @param {number} address Memory address to read from
         * @param bytesCount Number of bytes to read
         * @returns {Promise}
         */
        async cmdREAD(address, bytesCount) {
            return new Promise((resolve, reject) => {
                let addressFrame;

                if (!Number.isInteger(address) || address < 0) {
                    reject(new Error('Invalid address parameter'));
                    return;
                }

                if (!Number.isInteger(bytesCount) || bytesCount <= 0 || bytesCount > this.readBlockSize) {
                    reject(new Error('Invalid bytesCount parameter'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                addressFrame = tools.num2a(address, 4);
                addressFrame.push(this.calcChecksum(addressFrame, false));

                this.serial.write(u8a([CMD_READ, 0xFF ^ CMD_READ]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdREAD');
                        }
                        return this.serial.write(u8a(addressFrame));
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdREAD address');
                        }
                        // The number of bytes to be read -1 (0 <= N <= 255)
                        return this.serial.write(u8a([bytesCount - 1, (bytesCount - 1) ^ 0xFF]));
                    })
                    .then(() => this.readResponse())
                    .then(async (response) => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdREAD response');
                        }

                        if (this.replyMode) {
                            for (let i = 0; i < bytesCount; i++) {
                                await this.readResponse(); // read and ignore
                            }
                        }
                        resolve(result.subarray(1));
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute Write Unprotect command
         * STM32 only
         * @returns {Promise}
         */
        async cmdWPUN() {
            return new Promise((resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (this.commands.indexOf(CMD_WPUN) === -1) {
                    reject(new Error('Write Unprotect command is not supported by the current target'));
                    return;
                }

                this.serial.write(u8a([CMD_WPUN, 0xFF ^ CMD_WPUN]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK CMD_WPUN');
                        }
                        return this.readResponse();
                    })
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while CMD_WPUN');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute Readout Unprotect command
         * STM32 only
         * @returns {Promise}
         */
        async cmdRPUN() {
            return new Promise((resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (this.commands.indexOf(CMD_RDU_PRM) === -1) {
                    reject(new Error('Readout Unprotect command is not supported by the current target'));
                    return;
                }

                this.serial.write(u8a([CMD_RDU_PRM, 0xFF ^ CMD_RDU_PRM]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK CMD_RDU_PRM');
                        }
                        return this.readResponse();
                    })
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK CMD_RDU_PRM');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute single WRITE command
         * @param {Uint8Array} data Data to write
         * @param {number} address Address to write at
         * @returns {Promise}
         */
        async cmdWRITE(data, address) {
            return new Promise(async (resolve, reject) => {
                if (!(data instanceof Uint8Array)) {
                    reject(new Error('Missinf data to write'));
                    return;
                }

                if (!Number.isInteger(address) || address < 0) {
                    reject(new Error('Invalid address parameter'));
                    return;
                }

                if (data.length > this.writeBlockSize) {
                    reject(new Error('Data is too big, use write()'));
                    return;
                }

                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (this.ewrLoadState == EwrLoadState.NOT_LOADED) {
                    try {
                        await this.sendEWR();
                    } catch (e) {
                        reject(e);
                        return;
                    }
                }

                // Frame: number of bytes to be written (1 byte), the data (N + 1 bytes) (multiple of 4) and checksum
                let checksum = this.calcChecksum(data, true);
                let frame = new Uint8Array(data.length + 2);
                frame[0] = [data.length - 1]; //
                frame.set(data, 1);
                frame[frame.length - 1] = checksum;

                let addressFrame = tools.num2a(address, 4);
                addressFrame.push(this.calcChecksum(addressFrame, false));

                this.serial.write(u8a([CMD_WRITE, 0xFF ^ CMD_WRITE]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdWRITE');
                        }
                        return this.serial.write(u8a(addressFrame));
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdWRITE read');
                        }
                        return this.serial.write(frame);
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdWRITE 2');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute Get ID command
         * STM32 only
         */
        async cmdGID() {
            return new Promise((resolve, reject) => {
                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (this.commands.indexOf(CMD_GID) === -1) {
                    reject(new Error('GET ID command is not supported by the current target'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                this.serial.write(u8a([CMD_GID, 0xFF ^ CMD_GID]))
                    .then(() => this.readResponse())
                    .then(async (response) => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdGID');
                        }

                        while (response.length === 1 || response.length < response[1] + 4) {
                            let res = await this.readResponse();
                            response = new Uint8Array([
                                ...response,
                                ...res
                            ]);
                        }

                        let pid = '0x' + tools.b2hexstr(response[2]) + tools.b2hexstr(response[3]);
                        resolve(pid);
                    })
                    .catch(reject);
            });
        }

        /**
         * Get Version & Read Protection Status command
         * STM32 only
         * @returns {Promise<InfoGV>}
         */
        async cmdGV() {
            return new Promise((resolve, reject) => {
                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (this.commands.indexOf(CMD_GV) === -1) {
                    reject(new Error('Get Version & Read Protection Status command is not supported by the current target'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                this.serial.write(u8a([CMD_GV, 0xFF ^ CMD_GV]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdGV');
                        }

                        let info = new InfoGV();
                        info.blVersion = (result[1] >> 4) + '.' + (result[1] & 0x0F);
                        info.countRPenabled = result[2];
                        info.countRPdisabled = result[3];
                        resolve(info);
                    })
                    .catch(reject);
            });
        }

        /**
         * Serial read wrapper for single response with automatic echo mode
         * @private
         * @returns {Promise}
         */
        async readResponse() {
            return new Promise((resolve, reject) => {
                let result = null;
                this.serial.read()
                    .then(response => {
                        result = response;
                        if (this.replyMode) {
                            return this.serial.write(u8a([result[0]]));
                        }
                        return Promise.resolve();
                    })
                    .then(() => {
                        resolve(result);
                    })
                    .catch(reject);
            });
        }

        /**
         * Writes erase_write_routines for STM8 A/S to RAM. All erase/write operations won't work without them
         * @private
         */
        async sendEWR() {
            return new Promise(async (resolve, reject) => {
                if (!this.ewRoutines) {
                    if (!this.stm8RoutinesFile) {
                        reject(new Error('Select your device first by calling setDevice'));
                        return;
                    }

                    logger.log('Loading Erase-Write-Routines ' + this.stm8RoutinesFile);
                    this.ewRoutines = await fetch(this.stm8RoutinesFile)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Failed fetching ' + this.stm8RoutinesFile);
                            }
                            return response.arrayBuffer();
                        })
                        .then(buffer => {
                            return new Uint8Array(buffer);
                        })
                        .catch(reject);
                }

                this.ewrLoadState = EwrLoadState.LOADING;
                logger.log('Sending Erase-Write-Routines to the device...');
                this.write(this.ewRoutines, STM8_WRITE_CODE_ADDRESS)
                    .then(() => {
                        this.ewrLoadState = EwrLoadState.LOADED;
                        logger.log('Erase-Write-Routines loaded');
                        resolve();
                    })
                    .catch(error => {
                        this.ewrLoadState = EwrLoadState.NOT_LOADED;
                        reject(error);
                    });
            });
        }

        /**
         * Activate the ROM bootloader
         * @private
         * @returns {Promise}
         */
        async activateBootloader() {
            return new Promise((resolve, reject) => {
                if (this.modbusEnabled)
                {
                    logger.log('Using MODBUS.');
                    resolve();
                }
                else
                {
                    logger.log('Activating bootloader...');
                    logger.log('Using '+settings.mcutype + ' mode');
                    if (!this.serial.isOpen()) {
                        reject(new Error('Port must be opened before activating the bootloader'));
                        return;
                    }
                    

                    let synchr_byte = (settings.mcutype=="Artery") ? SYNCHR_ARTERY : SYNCHR;
                    this.enterBootMode()
                        .then(() => {
                            logger.log('Writing sync byte.');
                            this.serial.write(u8a([synchr_byte]));
                        })
                        .then(() => {
                            logger.log('Waiting for response...');
                            let res = this.serial.readWithTimeout(1000);
                            return res;
                        })
                        .then(response => {
                            if (response[0] === ACK) {
                                if (this.replyMode) {
                                    logger.log('Sending ACK.');
                                    return this.serial.write(u8a([ACK]));
                                }
                                return Promise.resolve();
                            } else {
                                throw new Error('Unexpected response for sync byte. Check device family');
                            }
                        })
                        .then(() => {
                            logger.log('Bootloader is ready for commands');
                            resolve();
                        })
                        .catch(error => 
                        {
                            console.log("Rejected with error");
                            console.log(error);
                            reject(error);
                        });
                }
            });
        }

        /**
         * Resets the target by toggling a control pin defined in RTS_PIN
         * @private
         * @returns {Promise}
         */
         async enterBootMode() {
            return new Promise((resolve, reject) => {
                logger.log('Enter boot mode target...');
                let signal = {};

                if (!this.serial.isOpen()) {
                    reject(new Error('Port must be opened for device reset'));
                    return;
                }

        // def boot(a: float, b: float) -> None:
            // ser.dtr = 0
            // ser.rts = 1
            // time.sleep(a)
            // ser.dtr = 1
            // ser.rts = 0
            // time.sleep(b)
            // ser.dtr = 0

                signal[DTR_PIN] = PIN_HIGH; //boot=1
                signal[RTS_PIN] = PIN_LOW; //reset=0
                this.serial.control(signal)
                    .then(() => new Promise(resolve => setTimeout(resolve, 500)))
                    .then(() => {
                        signal[DTR_PIN] = PIN_HIGH; //boot=1
                        signal[RTS_PIN] = PIN_HIGH; //reset=1
                        return this.serial.control(signal);
                    })
                    .then(() => new Promise(resolve => setTimeout(resolve, 500)))
                    .then(() => {
                        signal[DTR_PIN] = PIN_LOW; //boot=0
                        signal[RTS_PIN] = PIN_HIGH; //reset=1
                        return this.serial.control(signal);
                    })
                    .then(() => {
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Resets the target by toggling a control pin defined in RTS_PIN
         * @private
         * @returns {Promise}
         */
        async resetTarget() {
            return new Promise((resolve, reject) => {
                logger.log('Resetting target...');
                let signal = {};

                if (!this.serial.isOpen()) {
                    reject(new Error('Port must be opened for device reset'));
                    return;
                }

                signal[RTS_PIN] = PIN_LOW; //RESET=0
                this.serial.control(signal)
                    .then(() => {
                        logger.log('Resetting...');
                        setTimeout(resolve, 200);
                    })
                    .then(() => {
                        signal[RTS_PIN] = PIN_HIGH; //RESET=1
                        return this.serial.control(signal);
                    })
                    .then(() => {
                        // wait for device init
                        logger.log('Reset done. Wait for init.');
                        this.ewrLoadState = EwrLoadState.NOT_LOADED;
                        setTimeout(resolve, 200);
                    })
                    .catch(reject);
            });
        }

        /**
         * Calcualtes the checksum (XOR) of the byte array.
         * @private
         * @param data Byte Array to calculate the checksum for.
         * @param {boolean} wLength If true takes the length of the array into the account (used for data write)
         * @returns {number} Calculated checksum
         */
        calcChecksum(data, wLength) {
            let result = 0;

            for (let i = 0; i < data.length; i += 1) {
                result = result ^ data[i];
            }

            if (wLength) {
                result = result ^ (data.length - 1);
            }

            return result;
        }
    }

    /* src\App.svelte generated by Svelte v3.50.1 */

    function create_if_block_4(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1_value = /*selectedFile*/ ctx[4].name + "";
    	let t1;
    	let div1_intro;

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text("File: ");
    			t1 = text(t1_value);
    			attr(div0, "class", "notification is-info py-2");
    			attr(div1, "class", "container is-fluid is-paddingless");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, t0);
    			append(div0, t1);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*selectedFile*/ 16 && t1_value !== (t1_value = /*selectedFile*/ ctx[4].name + "")) set_data(t1, t1_value);
    		},
    		i(local) {
    			if (!div1_intro) {
    				add_render_callback(() => {
    					div1_intro = create_in_transition(div1, fade, {});
    					div1_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div1);
    		}
    	};
    }

    // (398:4) {#if error}
    function create_if_block_3(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let div1_intro;
    	let div1_outro;
    	let current;

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text("Error: ");
    			t1 = text(/*error*/ ctx[9]);
    			attr(div0, "class", "notification is-danger");
    			attr(div1, "class", "container is-fluid is-paddingless");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, t0);
    			append(div0, t1);
    			current = true;
    		},
    		p(ctx, dirty) {
    			if (!current || dirty[0] & /*error*/ 512) set_data(t1, /*error*/ ctx[9]);
    		},
    		i(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (div1_outro) div1_outro.end(1);
    				div1_intro = create_in_transition(div1, fade, {});
    				div1_intro.start();
    			});

    			current = true;
    		},
    		o(local) {
    			if (div1_intro) div1_intro.invalidate();
    			div1_outro = create_out_transition(div1, fade, {});
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			if (detaching && div1_outro) div1_outro.end();
    		}
    	};
    }

    // (541:4) {#if showPortDialog}
    function create_if_block_2(ctx) {
    	let portdialog;
    	let current;
    	portdialog = new PortDialog({});
    	portdialog.$on("close", /*close_handler*/ ctx[30]);
    	portdialog.$on("selected_port", /*onPortSelected*/ ctx[15]);

    	return {
    		c() {
    			create_component(portdialog.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(portdialog, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(portdialog.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(portdialog.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(portdialog, detaching);
    		}
    	};
    }

    // (547:4) {#if showSettingsDialog}
    function create_if_block_1(ctx) {
    	let settingsdialog;
    	let current;
    	settingsdialog = new SettingsDialog({});
    	settingsdialog.$on("close", /*close_handler_1*/ ctx[31]);

    	return {
    		c() {
    			create_component(settingsdialog.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(settingsdialog, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(settingsdialog.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(settingsdialog.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(settingsdialog, detaching);
    		}
    	};
    }

    // (551:4) {#if !navigator.serial}
    function create_if_block(ctx) {
    	let notsupporteddialog;
    	let current;
    	notsupporteddialog = new NotSupportedDialog({});

    	return {
    		c() {
    			create_component(notsupporteddialog.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(notsupporteddialog, target, anchor);
    			current = true;
    		},
    		i(local) {
    			if (current) return;
    			transition_in(notsupporteddialog.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(notsupporteddialog.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(notsupporteddialog, detaching);
    		}
    	};
    }

    function create_fragment(ctx) {
    	let div72;
    	let div7;
    	let div0;
    	let h1;
    	let t2;
    	let a0;
    	let span1;
    	let t3;
    	let span2;
    	let t4;
    	let span3;
    	let a0_class_value;
    	let t5;
    	let div6;
    	let div4;
    	let a1;
    	let div1;
    	let label;
    	let input;
    	let t6;
    	let span4;
    	let t7;
    	let span5;
    	let t9;
    	let a2;
    	let span6;
    	let i1;
    	let i1_class_value;
    	let t10;
    	let span7;
    	let t11_value = (/*isConnected*/ ctx[1] ? 'Disconnect' : 'Connect') + "";
    	let t11;
    	let t12;
    	let a3;
    	let t15;
    	let a4;
    	let t18;
    	let a5;
    	let t21;
    	let a6;
    	let t24;
    	let a7;
    	let t27;
    	let div3;
    	let div2;
    	let select0;
    	let option0;
    	let option1;
    	let t30;
    	let div5;
    	let a8;
    	let span18;
    	let t31;
    	let span19;

    	let t32_value = (/*selectedPort*/ ctx[5]
    	? /*selectedPort*/ ctx[5].name
    	: 'Select port') + "";

    	let t32;
    	let div6_class_value;
    	let t33;
    	let t34;
    	let t35;
    	let div71;
    	let div70;
    	let div37;
    	let div36;
    	let p0;
    	let t37;
    	let div14;
    	let div10;
    	let t39;
    	let div13;
    	let div12;
    	let div11;

    	let t40_value = (/*deviceInfo*/ ctx[0].family == 'STM32'
    	? '32-bit'
    	: '8-bit') + "";

    	let t40;
    	let t41;
    	let div21;
    	let div17;
    	let t43;
    	let div20;
    	let div19;
    	let div18;
    	let t44_value = /*deviceInfo*/ ctx[0].bl + "";
    	let t44;
    	let t45;
    	let div28;
    	let div24;
    	let t47;
    	let div27;
    	let div26;
    	let div25;
    	let t48_value = /*deviceInfo*/ ctx[0].pid + "";
    	let t48;
    	let t49;
    	let div35;
    	let div31;
    	let t51;
    	let div34;
    	let div33;
    	let div32;
    	let select1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let option6;
    	let t57;
    	let div39;
    	let div38;
    	let p1;
    	let t59;
    	let pre;
    	let t60;
    	let t61;
    	let div69;
    	let div68;
    	let p2;
    	let t63;
    	let div46;
    	let div42;
    	let t65;
    	let div45;
    	let div44;
    	let div43;
    	let t66_value = /*deviceInfo*/ ctx[0].revision + "";
    	let t66;
    	let t67;
    	let div53;
    	let div49;
    	let t69;
    	let div52;
    	let div51;
    	let div50;
    	let t70_value = /*deviceInfo*/ ctx[0].temperature + "";
    	let t70;
    	let t71;
    	let div60;
    	let div56;
    	let t73;
    	let div59;
    	let div58;
    	let div57;
    	let t74_value = /*deviceInfo*/ ctx[0].inp0 + "";
    	let t74;
    	let t75;
    	let div67;
    	let div63;
    	let t77;
    	let div66;
    	let div65;
    	let div64;
    	let t78_value = /*deviceInfo*/ ctx[0].inp1 + "";
    	let t78;
    	let t79;
    	let t80;
    	let t81;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*selectedFile*/ ctx[4] && create_if_block_4(ctx);
    	let if_block1 = /*error*/ ctx[9] && create_if_block_3(ctx);
    	let if_block2 = /*showPortDialog*/ ctx[7] && create_if_block_2(ctx);
    	let if_block3 = /*showSettingsDialog*/ ctx[8] && create_if_block_1(ctx);
    	let if_block4 = !navigator.serial && create_if_block();

    	return {
    		c() {
    			div72 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.innerHTML = `IV-Flasher<span id="subtitle" class="is-size-6 svelte-1ei71ab">serial</span>`;
    			t2 = space();
    			a0 = element("a");
    			span1 = element("span");
    			t3 = space();
    			span2 = element("span");
    			t4 = space();
    			span3 = element("span");
    			t5 = space();
    			div6 = element("div");
    			div4 = element("div");
    			a1 = element("a");
    			div1 = element("div");
    			label = element("label");
    			input = element("input");
    			t6 = space();
    			span4 = element("span");
    			span4.innerHTML = `<i class="fa fa-folder-open"></i>`;
    			t7 = space();
    			span5 = element("span");
    			span5.textContent = "Open File";
    			t9 = space();
    			a2 = element("a");
    			span6 = element("span");
    			i1 = element("i");
    			t10 = space();
    			span7 = element("span");
    			t11 = text(t11_value);
    			t12 = space();
    			a3 = element("a");

    			a3.innerHTML = `<span class="icon"><i class="fa fa-eraser"></i></span> 
                    <span>Full Erase</span>`;

    			t15 = space();
    			a4 = element("a");

    			a4.innerHTML = `<span class="icon"><i class="fas fa-pen"></i></span> 
                    <span>Flash</span>`;

    			t18 = space();
    			a5 = element("a");

    			a5.innerHTML = `<span class="icon"><i class="fa fa-play"></i></span> 
                    <span>Flash &amp; Go</span>`;

    			t21 = space();
    			a6 = element("a");

    			a6.innerHTML = `<span class="icon"><i class="fa fa-cog"></i></span> 
                    <span>Settings</span>`;

    			t24 = space();
    			a7 = element("a");

    			a7.innerHTML = `<span class="icon"><i class="fa fa-car"></i></span> 
                    <span>Get data</span>`;

    			t27 = space();
    			div3 = element("div");
    			div2 = element("div");
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "Artery";
    			option1 = element("option");
    			option1.textContent = "STM32";
    			t30 = space();
    			div5 = element("div");
    			a8 = element("a");
    			span18 = element("span");
    			span18.innerHTML = `<i class="fas fa-plug"></i>`;
    			t31 = space();
    			span19 = element("span");
    			t32 = text(t32_value);
    			t33 = space();
    			if (if_block0) if_block0.c();
    			t34 = space();
    			if (if_block1) if_block1.c();
    			t35 = space();
    			div71 = element("div");
    			div70 = element("div");
    			div37 = element("div");
    			div36 = element("div");
    			p0 = element("p");
    			p0.textContent = "Device Info";
    			t37 = space();
    			div14 = element("div");
    			div10 = element("div");
    			div10.innerHTML = `<div class="level-item"><div class="label">Family:</div></div>`;
    			t39 = space();
    			div13 = element("div");
    			div12 = element("div");
    			div11 = element("div");
    			t40 = text(t40_value);
    			t41 = space();
    			div21 = element("div");
    			div17 = element("div");
    			div17.innerHTML = `<div class="level-item"><div class="label">Bootloader:</div></div>`;
    			t43 = space();
    			div20 = element("div");
    			div19 = element("div");
    			div18 = element("div");
    			t44 = text(t44_value);
    			t45 = space();
    			div28 = element("div");
    			div24 = element("div");
    			div24.innerHTML = `<div class="level-item"><div class="label">Product ID:</div></div>`;
    			t47 = space();
    			div27 = element("div");
    			div26 = element("div");
    			div25 = element("div");
    			t48 = text(t48_value);
    			t49 = space();
    			div35 = element("div");
    			div31 = element("div");
    			div31.innerHTML = `<div class="level-item"><div class="label">STM8 type:</div></div>`;
    			t51 = space();
    			div34 = element("div");
    			div33 = element("div");
    			div32 = element("div");
    			select1 = element("select");
    			option2 = element("option");
    			option2.textContent = "Select device...\r\n                                        ";
    			option3 = element("option");
    			option3.textContent = "STM8 S/A 32K";
    			option4 = element("option");
    			option4.textContent = "STM8 S/A 128K\r\n                                        ";
    			option5 = element("option");
    			option5.textContent = "STM8 S/A 256K\r\n                                        ";
    			option6 = element("option");
    			option6.textContent = "STM8 L";
    			t57 = space();
    			div39 = element("div");
    			div38 = element("div");
    			p1 = element("p");
    			p1.textContent = "Log Messages";
    			t59 = space();
    			pre = element("pre");
    			t60 = text(/*logs*/ ctx[6]);
    			t61 = space();
    			div69 = element("div");
    			div68 = element("div");
    			p2 = element("p");
    			p2.textContent = "Sensors data";
    			t63 = space();
    			div46 = element("div");
    			div42 = element("div");
    			div42.innerHTML = `<div class="level-item"><div class="label">Revision:</div></div>`;
    			t65 = space();
    			div45 = element("div");
    			div44 = element("div");
    			div43 = element("div");
    			t66 = text(t66_value);
    			t67 = space();
    			div53 = element("div");
    			div49 = element("div");
    			div49.innerHTML = `<div class="level-item"><div class="label">Temperature:</div></div>`;
    			t69 = space();
    			div52 = element("div");
    			div51 = element("div");
    			div50 = element("div");
    			t70 = text(t70_value);
    			t71 = space();
    			div60 = element("div");
    			div56 = element("div");
    			div56.innerHTML = `<div class="level-item"><div class="label">Input 0:</div></div>`;
    			t73 = space();
    			div59 = element("div");
    			div58 = element("div");
    			div57 = element("div");
    			t74 = text(t74_value);
    			t75 = space();
    			div67 = element("div");
    			div63 = element("div");
    			div63.innerHTML = `<div class="level-item"><div class="label">Input 1:</div></div>`;
    			t77 = space();
    			div66 = element("div");
    			div65 = element("div");
    			div64 = element("div");
    			t78 = text(t78_value);
    			t79 = space();
    			if (if_block2) if_block2.c();
    			t80 = space();
    			if (if_block3) if_block3.c();
    			t81 = space();
    			if (if_block4) if_block4.c();
    			attr(h1, "class", "navbar-item is-size-5 mr-3 pt-1");
    			attr(span1, "aria-hidden", "true");
    			attr(span2, "aria-hidden", "true");
    			attr(span3, "aria-hidden", "true");
    			attr(a0, "role", "button");
    			attr(a0, "class", a0_class_value = "navbar-burger burger " + (/*burgerActive*/ ctx[3] ? 'is-active' : ''));
    			attr(a0, "aria-label", "menu");
    			attr(a0, "aria-expanded", "false");
    			attr(a0, "data-target", "blpnavbar");
    			attr(div0, "class", "navbar-brand");
    			attr(input, "class", "file-input");
    			attr(input, "type", "file");
    			attr(input, "accept", ".s19,.hex,.ihx,.bin");
    			attr(input, "name", "file");
    			attr(span4, "class", "icon");
    			attr(span5, "class", "file-label");
    			attr(label, "class", "file-label");
    			attr(div1, "class", "file");
    			attr(a1, "class", "navbar-item");
    			attr(i1, "class", i1_class_value = "fa " + (/*isConnected*/ ctx[1] ? 'fa-unlink' : 'fa-link'));
    			attr(span6, "class", "icon");
    			attr(a2, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a2, "disabled", /*isConnecting*/ ctx[12] || !/*selectedPort*/ ctx[5]);
    			attr(a3, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a3, "disabled", !/*cmdsAllowed*/ ctx[10]);
    			attr(a4, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a4, "disabled", !/*selectedFile*/ ctx[4] || !/*cmdsAllowed*/ ctx[10]);
    			attr(a5, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a5, "disabled", !/*selectedFile*/ ctx[4] || !/*cmdsAllowed*/ ctx[10]);
    			attr(a6, "class", "navbar-item");
    			attr(a7, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a7, "disabled", !/*settings*/ ctx[2]._modbus || !/*isConnected*/ ctx[1]);
    			option0.__value = "Artery";
    			option0.value = option0.__value;
    			option1.__value = "STM32";
    			option1.value = option1.__value;
    			attr(select0, "id", "mcuType");
    			if (/*settings*/ ctx[2].mcutype === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[29].call(select0));
    			attr(div2, "class", "select");
    			attr(div3, "class", "navbar-item");
    			attr(div4, "class", "navbar-start");
    			attr(span18, "class", "icon");
    			attr(a8, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a8, "disabled", !/*isDisconnected*/ ctx[11]);
    			attr(div5, "class", "navbar-end");
    			attr(div6, "id", "blpnavbar");
    			attr(div6, "class", div6_class_value = "navbar-menu " + (/*burgerActive*/ ctx[3] ? 'is-active' : ''));
    			attr(div7, "class", "navbar has-shadow");
    			attr(p0, "class", "title is-5");
    			attr(div10, "class", "level-left");
    			attr(div11, "class", "value");
    			attr(div12, "class", "level-item");
    			attr(div13, "class", "level-right");
    			attr(div14, "class", "level is-mobile");
    			attr(div17, "class", "level-left");
    			attr(div18, "class", "value");
    			attr(div19, "class", "level-item");
    			attr(div20, "class", "level-right");
    			attr(div21, "class", "level is-mobile");
    			attr(div24, "class", "level-left");
    			attr(div25, "class", "value");
    			attr(div26, "class", "level-item");
    			attr(div27, "class", "level-right");
    			attr(div28, "class", "level is-mobile");
    			attr(div31, "class", "level-left");
    			option2.__value = "-1";
    			option2.value = option2.__value;
    			option2.selected = true;
    			option3.__value = "32";
    			option3.value = option3.__value;
    			option4.__value = "128";
    			option4.value = option4.__value;
    			option5.__value = "256";
    			option5.value = option5.__value;
    			option6.__value = "0";
    			option6.value = option6.__value;
    			attr(select1, "id", "devices");
    			attr(div32, "class", "select value");
    			attr(div33, "class", "level-item");
    			attr(div34, "class", "level-right");
    			attr(div35, "class", "level is-mobile");
    			toggle_class(div35, "is-hidden", /*deviceInfo*/ ctx[0].family !== 'STM8');
    			attr(div36, "class", "box");
    			attr(div36, "id", "devinfo");
    			attr(div37, "class", "column is-narrow");
    			set_style(div37, "min-width", "360px");
    			attr(p1, "class", "title is-5");
    			attr(div38, "class", "box");
    			attr(div39, "class", "column");
    			attr(p2, "class", "title is-5");
    			attr(div42, "class", "level-left");
    			attr(div43, "class", "value");
    			attr(div44, "class", "level-item");
    			attr(div45, "class", "level-right");
    			attr(div46, "class", "level is-mobile");
    			attr(div49, "class", "level-left");
    			attr(div50, "class", "value");
    			attr(div51, "class", "level-item");
    			attr(div52, "class", "level-right");
    			attr(div53, "class", "level is-mobile");
    			attr(div56, "class", "level-left");
    			attr(div57, "class", "value");
    			attr(div58, "class", "level-item");
    			attr(div59, "class", "level-right");
    			attr(div60, "class", "level is-mobile");
    			attr(div63, "class", "level-left");
    			attr(div64, "class", "value");
    			attr(div65, "class", "level-item");
    			attr(div66, "class", "level-right");
    			attr(div67, "class", "level is-mobile");
    			attr(div68, "class", "box");
    			attr(div68, "id", "devinfo");
    			attr(div69, "class", "column is-narrow");
    			set_style(div69, "min-width", "360px");
    			attr(div70, "class", "columns");
    			attr(div71, "class", "container is-fluid mt-4");
    			attr(div72, "id", "app");
    		},
    		m(target, anchor) {
    			insert(target, div72, anchor);
    			append(div72, div7);
    			append(div7, div0);
    			append(div0, h1);
    			append(div0, t2);
    			append(div0, a0);
    			append(a0, span1);
    			append(a0, t3);
    			append(a0, span2);
    			append(a0, t4);
    			append(a0, span3);
    			append(div7, t5);
    			append(div7, div6);
    			append(div6, div4);
    			append(div4, a1);
    			append(a1, div1);
    			append(div1, label);
    			append(label, input);
    			append(label, t6);
    			append(label, span4);
    			append(label, t7);
    			append(label, span5);
    			append(div4, t9);
    			append(div4, a2);
    			append(a2, span6);
    			append(span6, i1);
    			append(a2, t10);
    			append(a2, span7);
    			append(span7, t11);
    			append(div4, t12);
    			append(div4, a3);
    			append(div4, t15);
    			append(div4, a4);
    			append(div4, t18);
    			append(div4, a5);
    			append(div4, t21);
    			append(div4, a6);
    			append(div4, t24);
    			append(div4, a7);
    			append(div4, t27);
    			append(div4, div3);
    			append(div3, div2);
    			append(div2, select0);
    			append(select0, option0);
    			append(select0, option1);
    			select_option(select0, /*settings*/ ctx[2].mcutype);
    			append(div6, t30);
    			append(div6, div5);
    			append(div5, a8);
    			append(a8, span18);
    			append(a8, t31);
    			append(a8, span19);
    			append(span19, t32);
    			append(div72, t33);
    			if (if_block0) if_block0.m(div72, null);
    			append(div72, t34);
    			if (if_block1) if_block1.m(div72, null);
    			append(div72, t35);
    			append(div72, div71);
    			append(div71, div70);
    			append(div70, div37);
    			append(div37, div36);
    			append(div36, p0);
    			append(div36, t37);
    			append(div36, div14);
    			append(div14, div10);
    			append(div14, t39);
    			append(div14, div13);
    			append(div13, div12);
    			append(div12, div11);
    			append(div11, t40);
    			append(div36, t41);
    			append(div36, div21);
    			append(div21, div17);
    			append(div21, t43);
    			append(div21, div20);
    			append(div20, div19);
    			append(div19, div18);
    			append(div18, t44);
    			append(div36, t45);
    			append(div36, div28);
    			append(div28, div24);
    			append(div28, t47);
    			append(div28, div27);
    			append(div27, div26);
    			append(div26, div25);
    			append(div25, t48);
    			append(div36, t49);
    			append(div36, div35);
    			append(div35, div31);
    			append(div35, t51);
    			append(div35, div34);
    			append(div34, div33);
    			append(div33, div32);
    			append(div32, select1);
    			append(select1, option2);
    			append(select1, option3);
    			append(select1, option4);
    			append(select1, option5);
    			append(select1, option6);
    			append(div70, t57);
    			append(div70, div39);
    			append(div39, div38);
    			append(div38, p1);
    			append(div38, t59);
    			append(div38, pre);
    			append(pre, t60);
    			append(div70, t61);
    			append(div70, div69);
    			append(div69, div68);
    			append(div68, p2);
    			append(div68, t63);
    			append(div68, div46);
    			append(div46, div42);
    			append(div46, t65);
    			append(div46, div45);
    			append(div45, div44);
    			append(div44, div43);
    			append(div43, t66);
    			append(div68, t67);
    			append(div68, div53);
    			append(div53, div49);
    			append(div53, t69);
    			append(div53, div52);
    			append(div52, div51);
    			append(div51, div50);
    			append(div50, t70);
    			append(div68, t71);
    			append(div68, div60);
    			append(div60, div56);
    			append(div60, t73);
    			append(div60, div59);
    			append(div59, div58);
    			append(div58, div57);
    			append(div57, t74);
    			append(div68, t75);
    			append(div68, div67);
    			append(div67, div63);
    			append(div67, t77);
    			append(div67, div66);
    			append(div66, div65);
    			append(div65, div64);
    			append(div64, t78);
    			append(div72, t79);
    			if (if_block2) if_block2.m(div72, null);
    			append(div72, t80);
    			if (if_block3) if_block3.m(div72, null);
    			append(div72, t81);
    			if (if_block4) if_block4.m(div72, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(a0, "click", /*onBurgerClick*/ ctx[14]),
    					listen(input, "change", /*onOpenFile*/ ctx[16]),
    					listen(a2, "click", /*onConnect*/ ctx[19]),
    					listen(a3, "click", /*onErase*/ ctx[20]),
    					listen(a4, "click", /*click_handler*/ ctx[26]),
    					listen(a5, "click", /*click_handler_1*/ ctx[27]),
    					listen(a6, "click", /*onSettings*/ ctx[21]),
    					listen(a7, "click", /*click_handler_2*/ ctx[28]),
    					listen(select0, "change", /*select0_change_handler*/ ctx[29]),
    					listen(a8, "click", /*onSelectPort*/ ctx[13]),
    					listen(select1, "change", /*onStm8Select*/ ctx[22])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (!current || dirty[0] & /*burgerActive*/ 8 && a0_class_value !== (a0_class_value = "navbar-burger burger " + (/*burgerActive*/ ctx[3] ? 'is-active' : ''))) {
    				attr(a0, "class", a0_class_value);
    			}

    			if (!current || dirty[0] & /*isConnected*/ 2 && i1_class_value !== (i1_class_value = "fa " + (/*isConnected*/ ctx[1] ? 'fa-unlink' : 'fa-link'))) {
    				attr(i1, "class", i1_class_value);
    			}

    			if ((!current || dirty[0] & /*isConnected*/ 2) && t11_value !== (t11_value = (/*isConnected*/ ctx[1] ? 'Disconnect' : 'Connect') + "")) set_data(t11, t11_value);

    			if (!current || dirty[0] & /*isConnecting, selectedPort*/ 4128) {
    				toggle_class(a2, "disabled", /*isConnecting*/ ctx[12] || !/*selectedPort*/ ctx[5]);
    			}

    			if (!current || dirty[0] & /*cmdsAllowed*/ 1024) {
    				toggle_class(a3, "disabled", !/*cmdsAllowed*/ ctx[10]);
    			}

    			if (!current || dirty[0] & /*selectedFile, cmdsAllowed*/ 1040) {
    				toggle_class(a4, "disabled", !/*selectedFile*/ ctx[4] || !/*cmdsAllowed*/ ctx[10]);
    			}

    			if (!current || dirty[0] & /*selectedFile, cmdsAllowed*/ 1040) {
    				toggle_class(a5, "disabled", !/*selectedFile*/ ctx[4] || !/*cmdsAllowed*/ ctx[10]);
    			}

    			if (!current || dirty[0] & /*settings, isConnected*/ 6) {
    				toggle_class(a7, "disabled", !/*settings*/ ctx[2]._modbus || !/*isConnected*/ ctx[1]);
    			}

    			if (dirty[0] & /*settings*/ 4) {
    				select_option(select0, /*settings*/ ctx[2].mcutype);
    			}

    			if ((!current || dirty[0] & /*selectedPort*/ 32) && t32_value !== (t32_value = (/*selectedPort*/ ctx[5]
    			? /*selectedPort*/ ctx[5].name
    			: 'Select port') + "")) set_data(t32, t32_value);

    			if (!current || dirty[0] & /*isDisconnected*/ 2048) {
    				toggle_class(a8, "disabled", !/*isDisconnected*/ ctx[11]);
    			}

    			if (!current || dirty[0] & /*burgerActive*/ 8 && div6_class_value !== (div6_class_value = "navbar-menu " + (/*burgerActive*/ ctx[3] ? 'is-active' : ''))) {
    				attr(div6, "class", div6_class_value);
    			}

    			if (/*selectedFile*/ ctx[4]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*selectedFile*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div72, t34);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*error*/ ctx[9]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*error*/ 512) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div72, t35);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t40_value !== (t40_value = (/*deviceInfo*/ ctx[0].family == 'STM32'
    			? '32-bit'
    			: '8-bit') + "")) set_data(t40, t40_value);

    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t44_value !== (t44_value = /*deviceInfo*/ ctx[0].bl + "")) set_data(t44, t44_value);
    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t48_value !== (t48_value = /*deviceInfo*/ ctx[0].pid + "")) set_data(t48, t48_value);

    			if (!current || dirty[0] & /*deviceInfo*/ 1) {
    				toggle_class(div35, "is-hidden", /*deviceInfo*/ ctx[0].family !== 'STM8');
    			}

    			if (!current || dirty[0] & /*logs*/ 64) set_data(t60, /*logs*/ ctx[6]);
    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t66_value !== (t66_value = /*deviceInfo*/ ctx[0].revision + "")) set_data(t66, t66_value);
    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t70_value !== (t70_value = /*deviceInfo*/ ctx[0].temperature + "")) set_data(t70, t70_value);
    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t74_value !== (t74_value = /*deviceInfo*/ ctx[0].inp0 + "")) set_data(t74, t74_value);
    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t78_value !== (t78_value = /*deviceInfo*/ ctx[0].inp1 + "")) set_data(t78, t78_value);

    			if (/*showPortDialog*/ ctx[7]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*showPortDialog*/ 128) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div72, t80);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*showSettingsDialog*/ ctx[8]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*showSettingsDialog*/ 256) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div72, t81);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div72);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    const DISCONNECTED = 'disconnected';
    const CONNECTING = 'connecting';
    const CONNECTED = 'connected';

    function instance($$self, $$props, $$invalidate) {
    	let isConnected;
    	let isConnecting;
    	let isDisconnected;
    	let cmdsAllowed;
    	let burgerActive = false;
    	let selectedFile = null;
    	let selectedPort = null;
    	let logs = '';
    	let showPortDialog = false;
    	let showSettingsDialog = false;
    	let connectionState = DISCONNECTED;
    	let error = null;
    	let stmApi = null;

    	let deviceInfo = {
    		family: '-',
    		bl: '-',
    		pid: '-',
    		commands: [],
    		temperature: 999,
    		inp0: 0,
    		inp1: 0,
    		revision: 999
    	};

    	let stm8selected = false;
    	let sending = false;

    	logger.registerLogger({
    		log(...args) {
    			log(args[0]);
    		}
    	});

    	function onSelectPort() {
    		$$invalidate(9, error = null);
    		$$invalidate(7, showPortDialog = true);
    	}

    	function onBurgerClick() {
    		$$invalidate(3, burgerActive = !burgerActive);
    	}

    	function log(message) {
    		$$invalidate(6, logs += message + '\n');
    	}

    	function onPortSelected(event) {
    		$$invalidate(9, error = null);
    		$$invalidate(5, selectedPort = event.detail);
    		let serial = new WebSerial(selectedPort);

    		serial.onConnect = () => {
    			
    		};

    		serial.onDisconnect = () => {
    			$$invalidate(25, sending = false);
    			$$invalidate(23, connectionState = DISCONNECTED);
    		}; //logs = '';

    		stmApi = new STMApi(serial);
    	}

    	function onOpenFile(event) {
    		$$invalidate(9, error = null);
    		$$invalidate(4, selectedFile = event.target.files[0]);
    	}

    	function onGetData(go) {
    		stmApi.cmdGET();
    	}

    	function onFlash(go) {
    		$$invalidate(9, error = null);
    		$$invalidate(25, sending = true);
    		log('Reading content of the file ' + selectedFile.name);

    		tools.readFile(selectedFile).then(async content => {
    			log('Parsing content of the file');
    			const ext = tools.extension(selectedFile.name);
    			let startAddress;
    			let records;

    			if (ext === 's19') {
    				records = tools.parseSRec(true, stmApi.writeBlockSize, content);
    			} else if (ext === 'hex' || ext === 'ihx') {
    				records = tools.parseHex(true, stmApi.writeBlockSize, content);
    			} else if (ext === 'bin') {
    				startAddress = parseInt(settings.startAddress);

    				records = [
    					{
    						type: 'data',
    						data: new Uint8Array(content),
    						address: startAddress
    					}
    				];
    			}

    			for (let i = 0; i < records.length; i++) {
    				let rec = records[i];

    				if (rec.type === 'data') {
    					let before_log = logs;

    					await stmApi.write(rec.data, rec.address, (i, blocksCount) => {
    						$$invalidate(6, logs = before_log + 'Writing block ' + (i + 1) + '/' + blocksCount + '\n');
    					});
    				} else if (rec.type === 'start') {
    					log('Start address detected: 0x' + rec.address.toString(16));
    					startAddress = rec.address;
    				}
    			}

    			if (go) {
    				startAddress = startAddress || parseInt(settings.startAddress);
    				log('Starting code execution');
    				await stmApi.cmdGO(startAddress);
    				stmApi.disconnect();
    				$$invalidate(23, connectionState = DISCONNECTED);
    			}

    			$$invalidate(25, sending = false);
    		}).catch(err => {
    			$$invalidate(25, sending = false);
    			$$invalidate(9, error = err.message);
    		});
    	}

    	function onConnect() {
    		$$invalidate(0, deviceInfo = {
    			family: '-',
    			bl: '-',
    			pid: '-',
    			commands: [],
    			temperature: 999,
    			inp0: 0,
    			inp1: 0,
    			revision: 999
    		});

    		if (connectionState === DISCONNECTED) {
    			$$invalidate(23, connectionState = CONNECTING);
    			$$invalidate(9, error = null);

    			stmApi.connect({
    				replyMode: settings.replyMode,
    				baudrate: settings.baudrate,
    				mcutype: settings.mcuType,
    				modbus: settings._modbus
    			}).then(() => {
    				$$invalidate(23, connectionState = CONNECTED);
    				return stmApi.cmdGET();
    			}).then(info => {
    				$$invalidate(0, deviceInfo.bl = info.blVersion, deviceInfo);
    				$$invalidate(0, deviceInfo.commands = info.commands, deviceInfo);

    				if (!settings._modbus) {
    					$$invalidate(0, deviceInfo.family = info.getFamily(), deviceInfo);

    					if (deviceInfo.family === 'STM32') {
    						//deviceInfo.family = '32-bit'
    						return stmApi.cmdGID();
    					} else {
    						return Promise.resolve('-');
    					}
    				} else {
    					$$invalidate(0, deviceInfo.family = "IV", deviceInfo);
    					$$invalidate(0, deviceInfo.inp0 = info.inp0, deviceInfo);
    					$$invalidate(0, deviceInfo.inp1 = info.inp1, deviceInfo);
    					$$invalidate(0, deviceInfo.revision = info.revision, deviceInfo);
    					$$invalidate(0, deviceInfo.temperature = info.temperature, deviceInfo);
    					return Promise.resolve('IV Modbus');
    				}
    			}).then(pid => {
    				$$invalidate(0, deviceInfo.pid = pid, deviceInfo);
    			}).then(() => {
    				if (settings._modbus) {
    					log("Modbus enabled");
    				} else {
    					log("Modbus not enabled");
    				}
    			}).catch(err => {
    				log(err);
    				console.log(err);

    				if (err != undefined) {
    					$$invalidate(9, error = err.message);
    				}

    				$$invalidate(23, connectionState = DISCONNECTED);
    			});
    		} else {
    			stmApi.disconnect().catch(err => {
    				if (err != undefined) {
    					$$invalidate(9, error = err.message);
    				}

    				console.log(err);
    			});
    		}
    	}

    	function onErase() {
    		$$invalidate(9, error = null);
    		$$invalidate(25, sending = true);
    		log('Erasing flash...');

    		stmApi.eraseAll().then(() => {
    			log('Flash erased');
    			$$invalidate(25, sending = false);
    		}).catch(err => {
    			$$invalidate(25, sending = false);
    			$$invalidate(9, error = err.message);
    		});
    	}

    	function onSettings() {
    		$$invalidate(9, error = null);
    		$$invalidate(8, showSettingsDialog = true);
    	}

    	function onStm8Select(event) {
    		let value = event.target.value;
    		$$invalidate(24, stm8selected = value !== '-1');

    		stmApi.setDevice({
    			blVersion: deviceInfo.bl,
    			flash: stm8selected ? value : null
    		});
    	}

    	const click_handler = () => onFlash(false);
    	const click_handler_1 = () => onFlash(true);
    	const click_handler_2 = () => onGetData();

    	function select0_change_handler() {
    		settings.mcutype = select_value(this);
    		$$invalidate(2, settings);
    	}

    	const close_handler = () => $$invalidate(7, showPortDialog = false);
    	const close_handler_1 = () => $$invalidate(8, showSettingsDialog = false);

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*connectionState*/ 8388608) {
    			$$invalidate(1, isConnected = connectionState === CONNECTED);
    		}

    		if ($$self.$$.dirty[0] & /*connectionState*/ 8388608) {
    			$$invalidate(12, isConnecting = connectionState === CONNECTING);
    		}

    		if ($$self.$$.dirty[0] & /*connectionState*/ 8388608) {
    			$$invalidate(11, isDisconnected = connectionState === DISCONNECTED);
    		}

    		if ($$self.$$.dirty[0] & /*isConnected, sending, deviceInfo, stm8selected*/ 50331651) {
    			$$invalidate(10, cmdsAllowed = isConnected && !sending && (deviceInfo.family === 'STM32' || deviceInfo.family === 'STM8' && stm8selected));
    		}
    	};

    	return [
    		deviceInfo,
    		isConnected,
    		settings,
    		burgerActive,
    		selectedFile,
    		selectedPort,
    		logs,
    		showPortDialog,
    		showSettingsDialog,
    		error,
    		cmdsAllowed,
    		isDisconnected,
    		isConnecting,
    		onSelectPort,
    		onBurgerClick,
    		onPortSelected,
    		onOpenFile,
    		onGetData,
    		onFlash,
    		onConnect,
    		onErase,
    		onSettings,
    		onStm8Select,
    		connectionState,
    		stm8selected,
    		sending,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		select0_change_handler,
    		close_handler,
    		close_handler_1
    	];
    }

    class App extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance, create_fragment, safe_not_equal, {}, null, [-1, -1]);
    	}
    }

    const app = new App({
    	target: document.body
    });

    return app;

})();
