
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
        return style.sheet;
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.wholeText !== data)
            text.data = data;
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            managed_styles.forEach(info => {
                const { ownerNode } = info.stylesheet;
                // there is no ownerNode if it runs on jsdom.
                if (ownerNode)
                    detach(ownerNode);
            });
            managed_styles.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    const REPLY_MODE = 'reply_mode';
    const BAUDRATE = 'baudrate';
    const MCUTYPE = 'mcutype';
    const START_ADDRESS = 'start_address';
    const MODBUS = 'modbus';

    class Settings {
        constructor() {
            this._replyMode = localStorage.getItem(REPLY_MODE) === "true" || false;
            this._baudrate = localStorage.getItem(BAUDRATE) || "9600";
            this._mcutype = localStorage.getItem(MCUTYPE) || "Artery";
            this._startAddress = localStorage.getItem(START_ADDRESS) || "0x8000000";
            this._modbus = localStorage.getItem(MODBUS) === "true" || false;
        }

        set replyMode(reply) {
            this._replyMode = reply;
            this.commit();
        }

        get replyMode() {
            return this._replyMode;
        }

        set modbus(mdbs) {
            this._modbus = mdbs;
            this.commit();
        }

        get modbus() {
            return this._modbus;
        }

        set baudrate(baudrate) {
            this._baudrate = baudrate;
            this.commit();
        }

        get baudrate() {
            return this._baudrate;
        }

        set mcutype(mcutype) {
            this._mcutype = mcutype;
            this.commit();
        }

        get mcutype() {
            return this._mcutype;
        }

        get startAddress() {
            return this._startAddress;
        }

        set startAddress(address) {
            this._startAddress = address;
            this.commit();
        }

        commit() {
            localStorage.setItem(REPLY_MODE, this._replyMode);
            localStorage.setItem(BAUDRATE, this._baudrate);
            localStorage.setItem(START_ADDRESS, this._startAddress);
            localStorage.setItem(MODBUS, this._modbus);
        }
    }

    const settings = new Settings();

    class Logger {
        constructor() {
            this.allLogger = [];
        }

        registerLogger(logger) {
            this.allLogger.push(logger);
        }

        log(...args) {
            this.allLogger.forEach((logger) => {
                logger.log.apply(null, args);
            });
        }
    }

    const logger = new Logger();

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    /**
     * Store that keeps track of the keys pressed, updated by the ArrowKeyHandler component
     */
    const keyPressed = writable({
        ArrowLeft: 0,
        ArrowUp: 0,
        ArrowRight: 0,
        ArrowDown: 0
    });
    /**
     * Store that keeps track of the keys pressed, with utility horizontal / vertical attributes
     * updated by the ArrowKeyHandler component
     */
    derived(keyPressed, ($keyPressed) => {
        return {
            ...$keyPressed,
            ArrowV: $keyPressed.ArrowUp + $keyPressed.ArrowDown,
            ArrowH: $keyPressed.ArrowLeft + $keyPressed.ArrowRight,
            ArrowVH: $keyPressed.ArrowUp + $keyPressed.ArrowDown + $keyPressed.ArrowLeft + $keyPressed.ArrowRight
        };
    });

    /* src\PortDialog.svelte generated by Svelte v3.50.1 */

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (58:12) {#each devices as dev, i}
    function create_each_block(ctx) {
    	let div5;
    	let div4;
    	let div3;
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let span1;
    	let t1_value = /*dev*/ ctx[9] + "";
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[5](/*i*/ ctx[11]);
    	}

    	return {
    		c() {
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.innerHTML = `<span class="icon"><i class="fa fa-plug"></i></span>`;
    			t0 = space();
    			div1 = element("div");
    			span1 = element("span");
    			t1 = text(t1_value);
    			attr(div0, "class", "level-item");
    			attr(div1, "class", "level-item");
    			attr(div2, "class", "level-left");
    			attr(div3, "class", "level");
    			attr(div4, "class", "card-content");
    			attr(div5, "class", "card");
    			attr(div5, "tabindex", /*i*/ ctx[11]);
    		},
    		m(target, anchor) {
    			insert(target, div5, anchor);
    			append(div5, div4);
    			append(div4, div3);
    			append(div3, div2);
    			append(div2, div0);
    			append(div2, t0);
    			append(div2, div1);
    			append(div1, span1);
    			append(span1, t1);

    			if (!mounted) {
    				dispose = listen(div5, "click", click_handler);
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*devices*/ 1 && t1_value !== (t1_value = /*dev*/ ctx[9] + "")) set_data(t1, t1_value);
    		},
    		d(detaching) {
    			if (detaching) detach(div5);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (75:12) {#if ports.length === 0}
    function create_if_block$1(ctx) {
    	let div2;

    	return {
    		c() {
    			div2 = element("div");
    			div2.innerHTML = `<div class="card-content"><div>No paired ports detected</div></div>`;
    			attr(div2, "class", "card");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    		}
    	};
    }

    function create_fragment$3(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let header;
    	let p;
    	let t2;
    	let button0;
    	let t3;
    	let section;
    	let t4;
    	let t5;
    	let footer;
    	let button1;
    	let mounted;
    	let dispose;
    	let each_value = /*devices*/ ctx[0];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	let if_block = /*ports*/ ctx[1].length === 0 && create_if_block$1();

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			header = element("header");
    			p = element("p");
    			p.textContent = "Paired Ports";
    			t2 = space();
    			button0 = element("button");
    			t3 = space();
    			section = element("section");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			if (if_block) if_block.c();
    			t5 = space();
    			footer = element("footer");
    			button1 = element("button");
    			button1.textContent = "Pair new\r\n                port";
    			attr(div0, "class", "modal-background");
    			attr(p, "class", "modal-card-title");
    			attr(button0, "class", "delete");
    			attr(button0, "aria-label", "close");
    			attr(header, "class", "modal-card-head");
    			attr(section, "class", "modal-card-body is-paddingless");
    			attr(button1, "class", "button is-success");
    			attr(footer, "class", "modal-card-foot");
    			attr(div1, "class", "modal-card");
    			attr(div2, "class", "modal is-active svelte-1njnz7e");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			append(div2, t0);
    			append(div2, div1);
    			append(div1, header);
    			append(header, p);
    			append(header, t2);
    			append(header, button0);
    			append(div1, t3);
    			append(div1, section);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(section, null);
    			}

    			append(section, t4);
    			if (if_block) if_block.m(section, null);
    			append(div1, t5);
    			append(div1, footer);
    			append(footer, button1);

    			if (!mounted) {
    				dispose = [
    					listen(button0, "click", /*onOkClick*/ ctx[2]),
    					listen(button1, "click", /*onDetectNew*/ ctx[4])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*onPortSelected, devices*/ 9) {
    				each_value = /*devices*/ ctx[0];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(section, t4);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*ports*/ ctx[1].length === 0) {
    				if (if_block) ; else {
    					if_block = create_if_block$1();
    					if_block.c();
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div2);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$2($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	const close = () => dispatch('close');
    	let devices = [];
    	let ports = [];

    	async function getPaired() {
    		$$invalidate(1, ports = await navigator.serial.getPorts());

    		$$invalidate(0, devices = ports.map(port => {
    			let info = port.getInfo();
    			let name = 'Serial Port';

    			if (info.usbProductId && info.usbVendorId) {
    				name += ' (usb:0x' + info.usbVendorId.toString(16) + ':0x' + info.usbProductId.toString(16) + ')';
    			}

    			port.name = 'Serial Port';
    			return name;
    		}));
    	}

    	function onOkClick() {
    		close();
    	}

    	function onPortSelected(index) {
    		dispatch('selected_port', ports[index]);
    		close();
    	}

    	function onDetectNew() {
    		navigator.serial.requestPort().then(getPaired);
    	}

    	onMount(getPaired);
    	const click_handler = i => onPortSelected(i);
    	return [devices, ports, onOkClick, onPortSelected, onDetectNew, click_handler];
    }

    class PortDialog extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$2, create_fragment$3, safe_not_equal, {});
    	}
    }

    /* src\SettingsDialog.svelte generated by Svelte v3.50.1 */

    function create_fragment$2(ctx) {
    	let div12;
    	let div0;
    	let t0;
    	let div11;
    	let header;
    	let p0;
    	let t2;
    	let button;
    	let t3;
    	let section;
    	let div3;
    	let label0;
    	let t5;
    	let div2;
    	let div1;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let option6;
    	let t13;
    	let div5;
    	let label1;
    	let t15;
    	let div4;
    	let input0;
    	let t16;
    	let p1;
    	let t18;
    	let div10;
    	let div6;
    	let label2;
    	let input1;
    	let t19;
    	let t20;
    	let div7;
    	let label3;
    	let input2;
    	let t21;
    	let t22;
    	let div9;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			div12 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div11 = element("div");
    			header = element("header");
    			p0 = element("p");
    			p0.textContent = "Settings";
    			t2 = space();
    			button = element("button");
    			t3 = space();
    			section = element("section");
    			div3 = element("div");
    			label0 = element("label");
    			label0.textContent = "Baud rate:";
    			t5 = space();
    			div2 = element("div");
    			div1 = element("div");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "4800";
    			option1 = element("option");
    			option1.textContent = "9600";
    			option2 = element("option");
    			option2.textContent = "19200";
    			option3 = element("option");
    			option3.textContent = "38400";
    			option4 = element("option");
    			option4.textContent = "57600";
    			option5 = element("option");
    			option5.textContent = "115200";
    			option6 = element("option");
    			option6.textContent = "250000";
    			t13 = space();
    			div5 = element("div");
    			label1 = element("label");
    			label1.textContent = "Address in flash for\r\n                    code:";
    			t15 = space();
    			div4 = element("div");
    			input0 = element("input");
    			t16 = space();
    			p1 = element("p");
    			p1.textContent = "If the selected file does not provide the starting address,\r\n                    this address will be used to write the code at. In most\r\n                    cases this is the starting address of the flash memory\r\n                    (STM32: 0x8000000 and STM8: 0x8000).";
    			t18 = space();
    			div10 = element("div");
    			div6 = element("div");
    			label2 = element("label");
    			input1 = element("input");
    			t19 = text(" Use Reply mode (STM8)");
    			t20 = space();
    			div7 = element("div");
    			label3 = element("label");
    			input2 = element("input");
    			t21 = text(" Access MODBUS");
    			t22 = space();
    			div9 = element("div");

    			div9.innerHTML = `<div>Some STM8 device interfaces require &quot;reply&quot; mode for
                        serial communication. See UM0560 for details. Uncheck
                        for STM32.</div>`;

    			attr(div0, "class", "modal-background");
    			attr(p0, "class", "modal-card-title");
    			attr(button, "class", "delete");
    			attr(button, "aria-label", "close");
    			attr(header, "class", "modal-card-head");
    			attr(label0, "class", "label");
    			attr(label0, "for", "baudList");
    			option0.__value = "4800";
    			option0.value = option0.__value;
    			option1.__value = "9600";
    			option1.value = option1.__value;
    			option2.__value = "19200";
    			option2.value = option2.__value;
    			option3.__value = "38400";
    			option3.value = option3.__value;
    			option4.__value = "57600";
    			option4.value = option4.__value;
    			option5.__value = "115200";
    			option5.value = option5.__value;
    			option6.__value = "250000";
    			option6.value = option6.__value;
    			attr(select, "id", "baudList");
    			if (/*settings*/ ctx[0].baudrate === void 0) add_render_callback(() => /*select_change_handler*/ ctx[2].call(select));
    			attr(div1, "class", "select");
    			attr(div2, "class", "control");
    			attr(div3, "class", "field");
    			attr(label1, "class", "label");
    			attr(label1, "for", "startingAddress");
    			attr(input0, "id", "startingAddress");
    			attr(input0, "class", "input");
    			attr(input0, "type", "text");
    			attr(input0, "placeholder", "Start address in flash");
    			attr(div4, "class", "control");
    			attr(p1, "class", "help");
    			attr(div5, "class", "field");
    			attr(input1, "type", "checkbox");
    			attr(label2, "class", "checkbox");
    			attr(div6, "class", "control");
    			attr(input2, "type", "checkbox");
    			attr(label3, "class", "checkbox");
    			attr(div7, "class", "control");
    			attr(div9, "class", "help");
    			attr(div10, "class", "field");
    			attr(section, "class", "modal-card-body");
    			attr(div11, "class", "modal-card");
    			attr(div12, "class", "modal is-active");
    		},
    		m(target, anchor) {
    			insert(target, div12, anchor);
    			append(div12, div0);
    			append(div12, t0);
    			append(div12, div11);
    			append(div11, header);
    			append(header, p0);
    			append(header, t2);
    			append(header, button);
    			append(div11, t3);
    			append(div11, section);
    			append(section, div3);
    			append(div3, label0);
    			append(div3, t5);
    			append(div3, div2);
    			append(div2, div1);
    			append(div1, select);
    			append(select, option0);
    			append(select, option1);
    			append(select, option2);
    			append(select, option3);
    			append(select, option4);
    			append(select, option5);
    			append(select, option6);
    			select_option(select, /*settings*/ ctx[0].baudrate);
    			append(section, t13);
    			append(section, div5);
    			append(div5, label1);
    			append(div5, t15);
    			append(div5, div4);
    			append(div4, input0);
    			set_input_value(input0, /*settings*/ ctx[0].startAddress);
    			append(div5, t16);
    			append(div5, p1);
    			append(section, t18);
    			append(section, div10);
    			append(div10, div6);
    			append(div6, label2);
    			append(label2, input1);
    			input1.checked = /*settings*/ ctx[0].replyMode;
    			append(label2, t19);
    			append(div10, t20);
    			append(div10, div7);
    			append(div7, label3);
    			append(label3, input2);
    			input2.checked = /*settings*/ ctx[0].modbus;
    			append(label3, t21);
    			append(div10, t22);
    			append(div10, div9);

    			if (!mounted) {
    				dispose = [
    					listen(button, "click", /*onOkClick*/ ctx[1]),
    					listen(select, "change", /*select_change_handler*/ ctx[2]),
    					listen(input0, "input", /*input0_input_handler*/ ctx[3]),
    					listen(input1, "change", /*input1_change_handler*/ ctx[4]),
    					listen(input2, "change", /*input2_change_handler*/ ctx[5])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*settings*/ 1) {
    				select_option(select, /*settings*/ ctx[0].baudrate);
    			}

    			if (dirty & /*settings*/ 1 && input0.value !== /*settings*/ ctx[0].startAddress) {
    				set_input_value(input0, /*settings*/ ctx[0].startAddress);
    			}

    			if (dirty & /*settings*/ 1) {
    				input1.checked = /*settings*/ ctx[0].replyMode;
    			}

    			if (dirty & /*settings*/ 1) {
    				input2.checked = /*settings*/ ctx[0].modbus;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div12);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$1($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	const close = () => dispatch('close');

    	function onOkClick() {
    		close();
    	}

    	function select_change_handler() {
    		settings.baudrate = select_value(this);
    		$$invalidate(0, settings);
    	}

    	function input0_input_handler() {
    		settings.startAddress = this.value;
    		$$invalidate(0, settings);
    	}

    	function input1_change_handler() {
    		settings.replyMode = this.checked;
    		$$invalidate(0, settings);
    	}

    	function input2_change_handler() {
    		settings.modbus = this.checked;
    		$$invalidate(0, settings);
    	}

    	return [
    		settings,
    		onOkClick,
    		select_change_handler,
    		input0_input_handler,
    		input1_change_handler,
    		input2_change_handler
    	];
    }

    class SettingsDialog extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1, create_fragment$2, safe_not_equal, {});
    	}
    }

    /* src\NotSupportedDialog.svelte generated by Svelte v3.50.1 */

    function create_fragment$1(ctx) {
    	let div2;

    	return {
    		c() {
    			div2 = element("div");

    			div2.innerHTML = `<div class="modal-background"></div> 
    <div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Browser not supported</p></header> 
        <section class="modal-card-body"><p>Your browser does not support Web Serial API. Check the <a href="https://github.com/Gamadril/stm-serial-flasher">documentation</a> for more info.</p></section></div>`;

    			attr(div2, "class", "modal is-active svelte-1njnz7e");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div2);
    		}
    	};
    }

    class NotSupportedDialog extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, null, create_fragment$1, safe_not_equal, {});
    	}
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    class Serial {
        constructor() {
            this.init();
        }

        init() {
        }

        /**
         * Check if a connection is opened.
         */
        isOpen() {
            return false;
        }

        /**
         * Open the serial port
         * @param {Object} port Port object
         */
        open(port) {
        }

        /**
         * Close the current connection
         */
        close() {
        }

        /**
         * Read data from the serial port
         */
        read() {
        }

        /**
         * Writes data to serial port
         * @param {Uint8Array} data Data to send.
         */
        write(data) {
        }

        /**
         * Set the control signals of the current connection
         * @param {dtr:boolean, rts:boolean} lineParams signal parameters
         */
        control(lineParams) {
        }

        onConnect() {       
        }

        onDisconnect() {
        }
    }

    function info(msg) {
        console.info('[WebSerial] ' + msg);
    }

    class WebSerial extends Serial {
        constructor(port) {
            super();
            if (!(port instanceof SerialPort)) {
                throw new Error('Expected a SerialPort object');
            }
            this._port = port;
            this._reader = null;
            this._writer = null;
        }

        init() {
            navigator.serial.onconnect = this.onConnect.bind(this);
            navigator.serial.ondisconnect = this.onDisconnect.bind(this);
        }

        /**
         * Check if a connection is opened.
         */
        isOpen() {
            return this._writer !== null;
        }

        /**
         * Open the serial port
         * @param {Object} parameter Parameter
         */
        open(parameter) {
            return new Promise((resolve, reject) => {
                info('-> open ' + JSON.stringify(parameter));
                this._port.open(parameter)
                    .then(() => {
                        this._reader = this._port.readable.getReader();
                        this._writer = this._port.writable.getWriter();
                        info('<- open');
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Close the current connection
         */
        close() {
            return new Promise((resolve, reject) => {
                info('-> close');
                this._reader.cancel();
                this._writer.close();
                Promise.all([this._reader.closed, this._writer.closed])
                    .then(() => this._port.close())
                    .then(() => {
                        this._reader = null;
                        this._writer = null;
                        info('<- close');
                        this.onDisconnect();
                        resolve();
                    })
                    .catch((err) => {
                        this._reader = null;
                        this._writer = null;
                        info('<- close reject');
                        reject(err);
                    });
            });
        }

        /**
         * Read data from the serial port
         */
        read() {
            return new Promise(async (resolve, reject) => {
                info('-> read');

                this._reader.read()
                    .then((result) => {
                        console.debug(result);
                        resolve(result.value);
                    })
                    .catch(reject);
            });
        }

        /**
         * Read data from the serial port with a timeout
         * @param {number} timeoutMilliseconds - Timeout in milliseconds
         * @returns {Promise<Buffer>} - Resolves with the received data or rejects on error or timeout
         */
        readWithTimeout(timeoutMilliseconds) {
            return new Promise(async (resolve, reject) => {
                info('-> readWithTimeout');
                
                // Create a timeout promise
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => {
                        reject(new Error('Serial read operation timed out'));
                    }, timeoutMilliseconds);
                });

                // Race between the read operation and the timeout promise
                Promise.race([this._reader.read(), timeoutPromise])
                    .then((result) => {
                        if (result instanceof Error) {
                            reject(result); // Propagate any error from the timeout promise
                        } else {
                            console.debug(result);
                            resolve(result.value);
                        }
                    })
                    .catch(reject);
            });
        }

        /**
         * Writes data to serial port
         * @param {Uint8Array} data Data to send.
         */
        write(data) {
            return new Promise((resolve, reject) => {
                info('-> write');
                console.debug(data);
                this._writer.write(data.buffer)
                    .then(resolve)
                    .catch(reject);
            });
        }

        /**
         * Set the control signals of the current connection
         * @param {dtr:boolean, rts:boolean} lineParams signal parameters
         */
        control(lineParams) {
            return new Promise((resolve, reject) => {
                info('-> control');
                console.debug(lineParams);
                this._port.setSignals(lineParams)
                    .then(() => {
                        resolve();
                    })
                    .catch(reject);
            });
        }
    }

    const tools = {
        /**
         * Parses the content of a s19 file
         * @param {boolean} combine Set to true to combine the data into packages
         * @param {number} blockSize Size of the block to combine data to
         * @param {string} fileContent Content of the s19 file
         * @returns {Array} Array of single records
         * @throws Error
         */
        parseSRec: function (combine, blockSize, fileContent) {
            var lines, i, line, record, checksum, records = [], type, addrLength;

            lines = fileContent.split("\n");
            for (i = 0; i < lines.length; i++) {
                line = lines[i];

                if (line.length === 0) { // skip empty lines
                    continue;
                } else if (line.charAt(0) !== 'S') {
                    throw new Error('Invalid SRecord file format')
                }

                record = {};
                type = parseInt(line.substr(1, 1), 10);
                record.type = null;
                if (type === 1) {
                    addrLength = 4;
                    record.type = 'data';
                } else if (type === 3) {
                    addrLength = 8;
                    record.type = 'data';
                } else if (type === 9) {
                    addrLength = 4;
                    record.type = 'start';
                } else if (type === 7) {
                    addrLength = 8;
                    record.type = 'start';
                } else {
                    continue;
                }
                record.length = parseInt(line.substr(2, 2), 16);
                record.address = parseInt(line.substr(4, addrLength), 16);
                record.data = this.hexstr2uintarray(line.substr(4 + addrLength, (record.length - 3) * 2));
                record.checksum = parseInt(line.substr(-2), 16);

                checksum = (this.sum(this.hexstr2uintarray(line.substring(2, line.length - 2))) & 0xFF) ^ 0xFF;

                if (checksum !== record.checksum) {
                    throw new Error('Checksum in line ' + (i + 1) + ' does not match');
                }

                records.push(record);
            }

            if (combine) {
                records = this.packRecords(records, blockSize);
            }

            return records;
        },

        /**
         * Parses the content of a hex file
         * @param {boolean} combine Set to true to combine the data into packages
         * @param {number} blockSize Size of the block to combine data to
         * @param {string} fileContent Content of the hex file
         * @returns {Array} Array of single records
         * @throws Error
         */
        parseHex: function (combine, blockSize, fileContent) {
            var lines, i, line, record, checksum, records = [], type, base = 0;

            lines = fileContent.split("\n");
            for (i = 0; i < lines.length; i++) {
                line = lines[i];

                if (line.length === 0) { // skip empty lines
                    continue;
                } else if (line.charAt(0) !== ':') {
                    throw new Error('Invalid HEX file format');
                }

                record = {};
                type = parseInt(line.substr(7, 2), 16);
                record.length = parseInt(line.substr(1, 2), 16);
                record.address = parseInt(line.substr(3, 4), 16);
                if (base > 0) {
                    record.address += base;
                }

                record.data = this.hexstr2uintarray(line.substr(9, record.length * 2));
                record.checksum = parseInt(line.substr(-2), 16);

                checksum = this.sum(this.hexstr2uintarray(line.substr(1))) % 256;

                if (checksum !== 0) {
                    throw new Error('Checksum in line ' + (i + 1) + ' does not match');
                }

                record.type = null;
                if (type === 0) {
                    record.type = 'data';
                    records.push(record);
                } else if (type === 4) {
                    base = record.data[0] << 24;
                    base += record.data[1] << 16;
                } else if (type === 5) {
                    record.type = 'start';
                    record.address = parseInt(line.substr(9, record.length * 2), 16);
                    records.push(record);
                }
            }

            if (combine) {
                records = this.packRecords(records, blockSize);
            }

            return records;
        },

        /**
         * Parses the content of a bin file. Actually splits binary data into records
         * @param {number} blockSize Size of the block to split data into
         * @param {ArrayBuffer} fileContent Content of the bin file
         * @returns {Array} Array of single records
         * @throws Error
         */
        parseBin: function (blockSize, fileContent) {
            let records = [];
            let nrRecords = Math.ceil(fileContent.byteLength / blockSize);

            for (let i = 0; i < nrRecords; i++) {
                let start = i * blockSize;
                let end = start + blockSize;
                let chunk = new Uint8Array(fileContent.slice(start, end));
                let record = {
                    data: chunk,
                    type: 'data'
                };
                records.push(record);
            }
            return records;
        },

        /**
         * @private
         * @param {Array} records Array of records to combine
         * @param {number} blockSize Size of the block to combine data to
         * @returns {Array} New recombined records
         */
        packRecords: function (records, blockSize) {
            var record, newRecord, result = [], startAddress, offset = 0, dataBuffer;

            var minAddress = function (records) {
                var record, i, result = -1;

                for (i = 0; i < records.length; i++) {
                    record = records[i];

                    if (result === -1 || result > record.address) {
                        result = record.address;
                    }
                }

                return result;
            };

            var findRecord = function (address) {
                var i;

                for (i = 0; i < records.length; i++) {
                    if (records[i].address === address && records[i].type === 'data') {
                        return records[i];
                    }
                }

                return null;
            };

            var findStartRecord = function () {
                var i;

                for (i = 0; i < records.length; i++) {
                    if (records[i].type === 'start') {
                        return records[i];
                    }
                }

                return null;
            };

            while (true) {
                newRecord = {
                    type: 'data'
                };

                record = findStartRecord();
                if (record) {
                    result.push(record);
                    records.splice(records.indexOf(record), 1);
                    continue;
                }

                startAddress = minAddress(records);

                if (startAddress === -1) {
                    break;
                }

                newRecord.address = startAddress;
                dataBuffer = new Uint8Array(blockSize);

                while ((record = findRecord(startAddress + offset)) !== null) {
                    if (offset + record.data.length > blockSize) {
                        break;
                    } else {
                        dataBuffer.set(record.data, offset);
                        records.splice(records.indexOf(record), 1);
                        offset += record.data.length;
                    }
                }

                if (offset < blockSize) {
                    dataBuffer = dataBuffer.subarray(0, offset);
                }

                offset = 0;
                newRecord.data = dataBuffer;

                result.push(newRecord);
            }

            return result;
        },

        /**
         * Returns the number of data records
         * @param {Array} records Array of records
         * @returns {number} Number of daa records
         */
        countData: function (records) {
            var i, result = 0;
            for (i = 0; i < records.length; i++) {
                if (records[i].type === 'data') {
                    result++;
                }
            }
            return result;
        },

        /**
         * Extracts the extension of a filename
         * @param {string} fileName Name of the file
         * @returns {string} Extension or null if file has no extension
         */
        extension: function (fileName) {
            var result = null, dotIndex = fileName.lastIndexOf('.');

            if (dotIndex !== -1) {
                result = fileName.substr(dotIndex + 1);
            }

            return result;
        },

        /**
         * Calculate the sum of bytes in the array
         * @private
         * @param {Uint8Array} array Array
         * @returns {number} Sum of all values in the array
         */
        sum: function (array) {
            return array.reduce((a, b) => a + b, 0);
        },

        /**
         * Convert a HEX string to Uint8Array
         * @private
         * @param {string} str String
         * @returns {Uint8Array} Result
         */
        hexstr2uintarray: function (str) {
            var result = new Uint8Array(str.length / 2);
            for (var i = 0; i < str.length / 2; i++) {
                result[i] = parseInt(str.substr(i * 2, 2), 16);
            }
            return result;
        },

        /**
         * Convert a string to ArrayBuffer
         * @private
         * @param {string} str String to convert
         * @returns {ArrayBuffer} Result
         */
        str2ab: function (str) {
            var buf = new ArrayBuffer(str.length);
            var bufView = new Uint8Array(buf);
            for (var i = 0; i < str.length; i++) {
                bufView[i] = str.charCodeAt(i);
            }
            return buf;
        },

        /**
         * Convert an array to ArrayBuffer
         * @private
         * @param array
         * @returns {ArrayBuffer} Result
         */
        a2ab: function (array) {
            var buf = new ArrayBuffer(array.length);
            var bufView = new Uint8Array(buf);
            for (var i = 0; i < array.length; i++) {
                bufView[i] = array[i];
            }
            return buf;
        },

        /**
         * Convert ArrayBuffer to array
         * @private
         * @param buffer
         * @returns {Uint8Array}
         */
        ab2a: function (buffer) {
            return new Uint8Array(buffer);
        },

        /**
         * Convert ArrayBuffer to string
         * @private
         * @param {ArrayBuffer} buffer Buffer to convert
         * @returns {string}
         */
        ab2hexstr: function (buffer) {
            var ua = new Uint8Array(buffer);
            var str = "";
            for (var i = 0; i < ua.length; i++) {
                str += this.b2hexstr(ua[i]);
            }
            return str;
        },

        /**
         * Convert byte to hexstr.
         * @param {number} byte Byte to convert
         */
        b2hexstr: function (byte) {
            return ("00" + byte.toString(16)).substr(-2);
        },

        /**
         * @private
         * @param buffer
         * @returns {string}
         */
        ab2str: function (buffer) {
            return String.fromCharCode.apply(null, new Uint8Array(buffer));
        },

        /**
         * @private
         * @param number
         * @param arraySize
         * @returns {Array}
         */
        num2a: function (number, arraySize) {
            var i, temp = number, result = [];

            for (i = 0; i < arraySize; i++) {
                result.unshift(temp & 0xFF);
                temp = temp >> 8;
            }

            return result;
        },

        /**
         * Convert an Uint8Array to array
         * @private
         * @param uiArray
         * @returns {Array}
         */
        uia2a: function (uiArray) {
            var i, result = [];

            for (i = 0; i < uiArray.length; i++) {
                result.push(uiArray[i]);
            }

            return result;
        },

        /**
         * Read the content of the file as text
         * @param {File} file 
         */
        readFile(file) {
            return new Promise((resolve, reject) => {
                let reader = new FileReader();
                reader.onload = () => {
                    resolve(reader.result);
                };
                reader.onerror = () => {
                    reject(reader.error);
                };
                if (file.name.endsWith('.bin')) {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file);
                }
            });
        }
    };

    const MAX_WRITE_BLOCK_SIZE_STM32 = 256;
    const MAX_READ_BLOCK_SIZE = 256;
    const MAX_WRITE_BLOCK_SIZE_STM8 = 128;

    // use control signals to trigger bootloader activation and device hardware reset
    // false = pin hight, true = pin low
    const RTS_PIN = "requestToSend";
    const DTR_PIN = "dataTerminalReady"; // STM32
    const PIN_HIGH = false;
    const PIN_LOW = true;

    const SYNCHR = 0x7F;
    const SYNCHR_ARTERY = 0x7F; //Set host identification number

    const ACK = 0x79;

    const CMD_GET = 0x00;
    const CMD_GV = 0x01;
    // GET ID command used to identify the STM family. If it's present it's STM32, STM8 otherwise
    const CMD_GID = 0x02;
    const CMD_READ = 0x11;
    const CMD_GO = 0x21;
    const CMD_WRITE = 0x31;
    const CMD_ERASE = 0x43;
    const CMD_EXTENDED_ERASE = 0x44;
    const CMD_WPUN = 0x73;
    const CMD_RDU_PRM = 0x92;

    // Address for erase_write_routines for STM8 S/A
    const STM8_WRITE_CODE_ADDRESS = 0xA0;

    const EwrLoadState = Object.freeze({
        NOT_LOADED: Symbol("not_loaded"),
        LOADING: Symbol("loading"),
        LOADED: Symbol("loaded")
    });

    function u8a(array) {
        return new Uint8Array(array);
    }

    function CRC16_2(buf) {
        let crc = 0xFFFF;
      
        for (let pos = 0; pos < buf.length; pos++) {
          crc ^= buf[pos] & 0xFF; // XOR byte into the least significant byte of crc
      
          for (let i = 8; i !== 0; i--) {
            // Loop over each bit
            if ((crc & 0x0001) !== 0) {
              // If the LSB is set
              crc = (crc >> 1) ^ 0xA001; // Shift right and XOR 0xA001
            } else {
              // Else LSB is not set
              crc >>= 1; // Just shift right
            }
          }
        }
      
        // Note: This number has low and high bytes swapped, so use it accordingly (or swap bytes)
        return crc;
      }

    class InfoGV {
        constructor() {
            // Bootloader version
            this.blVersion = null;
            // Number of times the read protection was disabled
            this.countRPdisabled = -1;
            // Number of times the read protection was enabled
            this.countRPenabled = -1;
        }
    }

    class InfoGET {
        constructor() {
            // Bootloader version
            this.blVersion = null;
            // List of supported commands
            this.commands = [];
            this.inp0 = 0.0;
            this.inp1 = 0.0;
            this.source = 0;
            this.range_min = 0.0;
            this.range_max = 0.0;
            this.revision = 0;
            this.temperature = 999.0;
            this.range_start = 0;
            this.range_end= 0;
            this.hue_start= 0;
            this.hue_end= 0;
            this.saturation= 0;
            this.c_value= 0;
            this.backlight_value = 0;
            this.backlight_saturation = 0;
            this.backlight_hue = 0;
        }

        getFamily() {
            return this.commands.indexOf(CMD_GID) === -1 ? 'STM8' : 'STM32';
        }
    }

    class STMApi {
        constructor(serial) {
            if (!serial) {
                throw new Error('Serial port object not provided');
            }
            this.serial = serial;
            // reply mode which is necessary for some STM8 MCUs
            this.replyMode = false;
            // Indicates if the STM8 erase_write_routines are already loaded
            this.ewrLoadState = EwrLoadState.NOT_LOADED;
            // max: STM8 = 128, STM32 = 256. must be mutliple of 4
            this.writeBlockSize = MAX_WRITE_BLOCK_SIZE_STM8;
            this.readBlockSize = MAX_READ_BLOCK_SIZE;
            // list of supported commands by the target
            this.commands = [];
            // name of the stm8 routines file
            this.stm8RoutinesFile = null;
            //Access MODBUS and not Bootloader
            this.modbusEnabled = false;
        }

        /**
         * Initializes erase_write_routines for STM8 S/A
         * @param {flash:"0"|"32"|"128"|"256", blVersion:string} device Flash size of the target MCU
         */
        setDevice(device) {
            this.ewrLoadState = EwrLoadState.NOT_LOADED;

            if (!device.blVersion || !device.flash) {
                return;
            }

            if (device.flash === '0') { // STM8 L
                this.ewrLoadState = EwrLoadState.LOADED;
                return;
            } else if (device.flash !== '32' && device.flash !== '128' && device.flash !== '256') {
                throw new Error('Unsupported device selected: ' + device);
            }

            this.stm8RoutinesFile = 'res/stm8_routines/E_W_ROUTINEs_' + device.flash + 'K_ver_' + device.blVersion + '.bin';
        }

        /**
         * Connect to the target by resetting it and activating the ROM bootloader
         * @param {object} params
         * @returns {Promise}
         */
        async connect(params) {
            this.ewrLoadState = EwrLoadState.NOT_LOADED;
            return new Promise((resolve, reject) => {
                logger.log('Connecting with baudrate ' + params.baudrate + ' and reply mode ' + (params.replyMode ? 'on' : 'off'));
                if (this.serial.isOpen()) {
                    reject(new Error('Port already opened'));
                    return;
                }

                this.replyMode = params.replyMode || false;
                this.modbusEnabled = params.modbus || false;
                this.serial.open({
                    baudRate: parseInt(params.baudrate, 10),
                    parity: (this.replyMode||this.modbusEnabled) ? 'none' : 'even'
                })
                    .then(() => {
                        // set init state of the NRST pin to high
                        // for stm32 set the BOOT0 pin to low.
                        let signal = {};
                        signal[RTS_PIN] = PIN_HIGH; //RESET=1
                        signal[DTR_PIN] = PIN_LOW; //BOOT0=0
                        return this.serial.control(signal);
                        
                    })
                    .then(() => this.activateBootloader())
                    .then(resolve)
                    .catch(error => {
                        if (this.serial.isOpen()) {
                            this.serial.close(function (err) {
                                console.log('port closed', err);
                            });
                        }
                        reject(error);
                    });
            });
        }

        /**
         * Close current connection. Before closing serial connection disable bootloader and reset target
         * @returns {Promise}
         */
        async disconnect() {
            return new Promise((resolve, reject) => {
                let signal = {};
                signal[DTR_PIN] = PIN_LOW; //BOOT=0
                signal[RTS_PIN] = PIN_HIGH; //RESET=1
                this.serial.control(signal)
                    .then(() => this.resetTarget())
                    .then(() => this.serial.close())
                    .then(resolve)
                    .catch(reject);
            });

        }

        /**
         * Write data to memory. If the data exceeds the max frame size it will be splitted and sent in chunks automatically
         * @param {Uint8Array} data Data to write
         * @param {number} address Address to write at
         * @param {Function} onProgress Callback to notify progress
         * @returns {Promise}
         */
        async write(data, address, onProgress) {
            return new Promise(async (resolve, reject) => {
                logger.log('Writing ' + data.length + ' bytes to flash at address 0x' + address.toString(16) + ' using ' + this.writeBlockSize + ' bytes chunks');
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                let blocksCount = Math.ceil(data.byteLength / this.writeBlockSize);

                let offset = 0;
                let blocks = [];
                for (let i = 0; i < blocksCount; i++) {
                    let block = {};

                    if (i < blocksCount - 1) {
                        block.data = data.subarray(offset, offset + this.writeBlockSize);
                    } else {
                        block.data = data.subarray(offset);
                    }
                    offset += block.data.length;
                    blocks.push(block);
                }

                for (let i = 0; i < blocks.length; i++) {
                    let block = blocks[i];
                    try {
                        //logger.log('Writing block ' + (i + 1) + '/' + blocksCount);
                        if (onProgress) {
                            onProgress(i, blocksCount);
                        }
                        await this.cmdWRITE(block.data, address + i * this.writeBlockSize);
                    } catch (e) {
                        reject(e);
                        return;
                    }
                }
                logger.log('Finished writing');
                resolve();
            });
        }

        /**
         * Do a full erase of the flash
         * @returns {Promise}
         */
        async eraseAll() {
            return new Promise(async (resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (this.ewrLoadState == EwrLoadState.NOT_LOADED) {
                    try {
                        await this.sendEWR();
                    } catch (e) {
                        reject(e);
                        return;
                    }
                }

                let eraseCmd, eraseFlash;
                if (this.commands.indexOf(CMD_ERASE) !== -1) {
                    eraseCmd = [CMD_ERASE, 0xFF ^ CMD_ERASE];
                    eraseFlash = [0xFF, 0x00];
                } else if (this.commands.indexOf(CMD_EXTENDED_ERASE) !== -1) {
                    eraseCmd = [CMD_EXTENDED_ERASE, 0xFF ^ CMD_EXTENDED_ERASE];
                    eraseFlash = [0xFF, 0xFF, 0x00];
                } else {
                    reject(new Error('No erase command found'));
                    return;
                }

                this.serial.write(u8a(eraseCmd))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK erase ALL');
                        }
                        return this.serial.write(u8a(eraseFlash));
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while erase ALL');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Async delay
         * @param {*} ms 
         * @returns 
         */
        async delay_nb(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * sets modbus parameter
         * @param {*} reg 
         * @param {*} val 
         * @returns 
         */
        async cmdModbusWRITEReg(reg,val) {
            return new Promise((resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }
                if (this.modbusEnabled)
                {
                    var modbusRequest = u8a([0x01,0x06,(reg&0xFF00)>>8,(reg&0xFF),(val&0xFF00)>>8,(val&0xFF)]);
                    var checksum = CRC16_2(modbusRequest);
                    var ch8a = u8a([checksum&0xFF,(checksum&0xFF00)>>8]);
                    const combinedArray = new Uint8Array(modbusRequest.length + ch8a.length);
                    combinedArray.set(modbusRequest, 0);
                    combinedArray.set(ch8a, modbusRequest.length);
                    console.log(combinedArray);
                    this.serial.write(combinedArray).then(()=>resolve());
                }
            });
        }

        /**
         * Executes GET command
         * @returns {Promise<InfoGET>}
         */
        async cmdGET() {
            return new Promise((resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (this.modbusEnabled)
                {
                    //01 03 00 00 00 0D 84 0F

                    var parNumber = 23;
                    var modbusRequest = u8a([0x01,0x03,0x00,0x00,0x00,parNumber]);
                    var checksum = CRC16_2(modbusRequest);
                    var ch8a = u8a([checksum&0xFF,(checksum&0xFF00)>>8]);
                    const combinedArray = new Uint8Array(modbusRequest.length + ch8a.length);
                    combinedArray.set(modbusRequest, 0);
                    combinedArray.set(ch8a, modbusRequest.length);
                    console.log(combinedArray);
                    this.serial.write(combinedArray)
                    .then(() => this.readResponse())
                    .then(async (resp) => {
                        let response = new Uint8Array(resp);
                        
                        console.log(resp);
                        let info = new InfoGET();

                        // Exclude the last two bytes
                        const dataToCheck = response.subarray(0, response.length - 2);

                        // Calculate CRC16_2 on the remaining data
                        const calculatedCRC = CRC16_2(dataToCheck);

                        // Get the last two bytes
                        const lastTwoBytes = response.subarray(response.length - 2);
                        // Check if the calculated CRC matches the last two bytes
                        const isCRCValid = calculatedCRC === (lastTwoBytes[0] + (lastTwoBytes[1] << 8));
                        console.log(isCRCValid);
                        if (isCRCValid)
                        {
                            // 01 03 1A 00 04 FE F9 03 32 03 14 FF FF FF FF 11 B6 11 0F FF FF FF FF 00 00 03 E8 13 88 C6 3B (31 bytes)
                            info.blVersion = (response[2] >> 4) + '.' + (response[2] & 0x0F);
                            info.revision = (response[3] << 8) | (response[4] );
                            info.temperature = (response[5] << 8) | (response[6] );
                            info.inp0 = (response[15] << 8) | (response[16] );
                            info.inp1 = (response[17] << 8) | (response[18] );
                            info.source = (response[23] << 8) | (response[24] );
                            info.range_min = (response[25] << 8) | (response[26] );
                            info.range_max = (response[27] << 8) | (response[28] );
                            info.c_value = (response[33] << 8) | (response[34] );
                            info.saturation = (response[35] << 8) | (response[36] );
                            info.hue_start = (response[37] << 8) | (response[38] );
                            info.hue_end = (response[39] << 8) | (response[40] );
                            info.backlight_value = (response[43] << 8) | (response[44] );
                            info.backlight_saturation = (response[45] << 8) | (response[46] );
                            info.backlight_hue = (response[47] << 8) | (response[48] );
                            console.log(info);
                        }
                        resolve(info);
                    })
                    .catch(reject);
                }
                else
                {
                    this.serial.write(u8a([CMD_GET, 0xFF ^ CMD_GET]))
                    .then(() => this.readResponse())
                    .then(async (resp) => {
                        let response = new Uint8Array(resp);
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdGET');
                        }

                        // if (response.length === 1) { // TODO stm8 sends the bytes with delay. Always or on in reply mode only?
                        //     let res = await this.readResponse();
                        //     response[1] = res[0];
                        //     res = await this.readResponse(); // bl version
                        //     response[2] = res[0];
                        //     for (let i = 0; i <= response[1]; i++) {
                        //         res = await this.readResponse();
                        //         response[3 + i] = res[0];
                        //     }
                        // }

                        while (response.length === 1 || response.length < response[1] + 4) {
                            let res = await this.readResponse();
                            response = new Uint8Array([
                                ...response,
                                ...res
                            ]);
                        }

                        let info = new InfoGET();
                        info.blVersion = (response[2] >> 4) + '.' + (response[2] & 0x0F);
                        for (let i = 0; i < response[1]; i++) {
                            info.commands.push(response[3 + i]);
                        }
                        this.commands = info.commands;
                        if (info.getFamily() === 'STM32') {
                            this.writeBlockSize = MAX_WRITE_BLOCK_SIZE_STM32;
                            this.ewrLoadState = EwrLoadState.LOADED;
                        } else {
                            this.writeBlockSize = MAX_WRITE_BLOCK_SIZE_STM8;
                        }
                        resolve(info);
                    })
                    .catch(reject);
                }
            });
        }

        /**
         * Execute GO command
         * @param {number} address Memory address to start code execution
         * @returns {Promise}
         */
        async cmdGO(address) {
            return new Promise((resolve, reject) => {
                let addressFrame;

                if (!Number.isInteger(address)) {
                    reject(new Error('Invalid address parameter'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                addressFrame = tools.num2a(address, 4);
                addressFrame.push(this.calcChecksum(addressFrame, false));

                this.serial.write(u8a([CMD_GO, 0xFF ^ CMD_GO]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK CMD GO');
                        }
                        return this.serial.write(u8a(addressFrame));
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while CMD GO');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute single READ command
         * @param {number} address Memory address to read from
         * @param bytesCount Number of bytes to read
         * @returns {Promise}
         */
        async cmdREAD(address, bytesCount) {
            return new Promise((resolve, reject) => {
                if (this.modbusEnabled)
                {
                    resolve(u8a([0]));
                }
                else
                {
                    let addressFrame;

                    if (!Number.isInteger(address) || address < 0) {
                        reject(new Error('Invalid address parameter'));
                        return;
                    }

                    if (!Number.isInteger(bytesCount) || bytesCount <= 0 || bytesCount > this.readBlockSize) {
                        reject(new Error('Invalid bytesCount parameter'));
                        return;
                    }

                    if (!this.serial.isOpen()) {
                        reject(new Error('Connection must be established before sending commands'));
                        return;
                    }

                    addressFrame = tools.num2a(address, 4);
                    console.log('AF'+u8a(addressFrame));
                    addressFrame.push(this.calcChecksum(addressFrame, false));
                    console.log('with Checksum'+u8a(addressFrame));
                    this.serial.write(u8a([CMD_READ, 0xFF ^ CMD_READ]))
                        .then(() => this.readResponse())
                        .then(response => {
                            if (response[0] !== ACK) {
                                throw new Error('Unexpected response while ACK cmdREAD');
                            }
                            console.log(u8a(addressFrame));
                            return this.serial.write(u8a(addressFrame));
                        })
                        .then(() => this.readResponse())
                        .then(response => {
                            if (response[0] !== ACK) {
                                throw new Error('Unexpected response while ACK cmdREAD address '+response[0]);
                            }
                            // The number of bytes to be read -1 (0 <= N <= 255)
                            return this.serial.write(u8a([bytesCount - 1, (bytesCount - 1) ^ 0xFF]));
                        })
                        .then(() => this.readResponse())
                        .then(async (response) => {
                            if (response[0] !== ACK) {
                                throw new Error('Unexpected response while ACK cmdREAD response');
                            }

                            while (response.length < 1+bytesCount) {
                                let res = await this.readResponse();
                                response = new Uint8Array([
                                    ...response,
                                    ...res
                                ]);
                            }

                            if (this.replyMode) {
                                for (let i = 0; i < bytesCount; i++) {
                                    await this.readResponse(); // read and ignore
                                }
                            }
                            resolve(response.slice(1));
                        })
                        .catch(reject);
                    }            
            });
        }

        /**
         * Execute Write Unprotect command
         * STM32 only
         * @returns {Promise}
         */
        async cmdWPUN() {
            return new Promise((resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (this.commands.indexOf(CMD_WPUN) === -1) {
                    reject(new Error('Write Unprotect command is not supported by the current target'));
                    return;
                }

                this.serial.write(u8a([CMD_WPUN, 0xFF ^ CMD_WPUN]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK CMD_WPUN');
                        }
                        return this.readResponse();
                    })
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while CMD_WPUN');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute Readout Unprotect command
         * STM32 only
         * @returns {Promise}
         */
        async cmdRPUN() {
            return new Promise((resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (this.commands.indexOf(CMD_RDU_PRM) === -1) {
                    reject(new Error('Readout Unprotect command is not supported by the current target'));
                    return;
                }

                this.serial.write(u8a([CMD_RDU_PRM, 0xFF ^ CMD_RDU_PRM]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK CMD_RDU_PRM');
                        }
                        return this.readResponse();
                    })
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK CMD_RDU_PRM');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute single WRITE command
         * @param {Uint8Array} data Data to write
         * @param {number} address Address to write at
         * @returns {Promise}
         */
        async cmdWRITE(data, address) {
            return new Promise(async (resolve, reject) => {
                if (!(data instanceof Uint8Array)) {
                    reject(new Error('Missinf data to write'));
                    return;
                }

                if (!Number.isInteger(address) || address < 0) {
                    reject(new Error('Invalid address parameter'));
                    return;
                }

                if (data.length > this.writeBlockSize) {
                    reject(new Error('Data is too big, use write()'));
                    return;
                }

                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (this.ewrLoadState == EwrLoadState.NOT_LOADED) {
                    try {
                        await this.sendEWR();
                    } catch (e) {
                        reject(e);
                        return;
                    }
                }

                // Frame: number of bytes to be written (1 byte), the data (N + 1 bytes) (multiple of 4) and checksum
                let checksum = this.calcChecksum(data, true);
                let frame = new Uint8Array(data.length + 2);
                frame[0] = [data.length - 1]; //
                frame.set(data, 1);
                frame[frame.length - 1] = checksum;

                let addressFrame = tools.num2a(address, 4);
                addressFrame.push(this.calcChecksum(addressFrame, false));

                this.serial.write(u8a([CMD_WRITE, 0xFF ^ CMD_WRITE]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdWRITE');
                        }
                        return this.serial.write(u8a(addressFrame));
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdWRITE read');
                        }
                        return this.serial.write(frame);
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdWRITE 2');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute Get ID command
         * STM32 only
         */
        async cmdGID() {
            return new Promise((resolve, reject) => {
                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (this.commands.indexOf(CMD_GID) === -1) {
                    reject(new Error('GET ID command is not supported by the current target'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                this.serial.write(u8a([CMD_GID, 0xFF ^ CMD_GID]))
                    .then(() => this.readResponse())
                    .then(async (response) => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdGID');
                        }

                        while (response.length === 1 || response.length < response[1] + 4) {
                            let res = await this.readResponse();
                            response = new Uint8Array([
                                ...response,
                                ...res
                            ]);
                        }
                        
                        let pid = '0x' + tools.b2hexstr(response[2]) + tools.b2hexstr(response[3]);
                        resolve(pid);
                    })
                    .catch(reject);
            });
        }

        /**
         * Get Version & Read Protection Status command
         * STM32 only
         * @returns {Promise<InfoGV>}
         */
        async cmdGV() {
            return new Promise((resolve, reject) => {
                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (this.commands.indexOf(CMD_GV) === -1) {
                    reject(new Error('Get Version & Read Protection Status command is not supported by the current target'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                this.serial.write(u8a([CMD_GV, 0xFF ^ CMD_GV]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response while ACK cmdGV');
                        }

                        let info = new InfoGV();
                        info.blVersion = (result[1] >> 4) + '.' + (result[1] & 0x0F);
                        info.countRPenabled = result[2];
                        info.countRPdisabled = result[3];
                        resolve(info);
                    })
                    .catch(reject);
            });
        }

        /**
         * Serial read wrapper for single response with automatic echo mode
         * @private
         * @returns {Promise}
         */
        async readResponse() {
            return new Promise((resolve, reject) => {
                let result = null;
                this.serial.read()
                    .then(response => {
                        result = response;
                        if (this.replyMode) {
                            return this.serial.write(u8a([result[0]]));
                        }
                        return Promise.resolve();
                    })
                    .then(() => {
                        resolve(result);
                    })
                    .catch(reject);
            });
        }

        /**
         * Writes erase_write_routines for STM8 A/S to RAM. All erase/write operations won't work without them
         * @private
         */
        async sendEWR() {
            return new Promise(async (resolve, reject) => {
                if (!this.ewRoutines) {
                    if (!this.stm8RoutinesFile) {
                        reject(new Error('Select your device first by calling setDevice'));
                        return;
                    }

                    logger.log('Loading Erase-Write-Routines ' + this.stm8RoutinesFile);
                    this.ewRoutines = await fetch(this.stm8RoutinesFile)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Failed fetching ' + this.stm8RoutinesFile);
                            }
                            return response.arrayBuffer();
                        })
                        .then(buffer => {
                            return new Uint8Array(buffer);
                        })
                        .catch(reject);
                }

                this.ewrLoadState = EwrLoadState.LOADING;
                logger.log('Sending Erase-Write-Routines to the device...');
                this.write(this.ewRoutines, STM8_WRITE_CODE_ADDRESS)
                    .then(() => {
                        this.ewrLoadState = EwrLoadState.LOADED;
                        logger.log('Erase-Write-Routines loaded');
                        resolve();
                    })
                    .catch(error => {
                        this.ewrLoadState = EwrLoadState.NOT_LOADED;
                        reject(error);
                    });
            });
        }

        /**
         * Activate the ROM bootloader
         * @private
         * @returns {Promise}
         */
        async activateBootloader() {
            return new Promise((resolve, reject) => {
                if (this.modbusEnabled)
                {
                    logger.log('Using MODBUS.');
                    resolve();
                }
                else
                {
                    logger.log('Activating bootloader...');
                    logger.log('Using '+settings.mcutype + ' mode');
                    if (!this.serial.isOpen()) {
                        reject(new Error('Port must be opened before activating the bootloader'));
                        return;
                    }
                    

                    let synchr_byte = (settings.mcutype=="Artery") ? SYNCHR_ARTERY : SYNCHR;
                    this.enterBootMode()
                        .then(() => {
                            logger.log('Writing sync byte.');
                            this.serial.write(u8a([synchr_byte]));
                        })
                        .then(() => {
                            logger.log('Waiting for response...');
                            let res = this.serial.readWithTimeout(1000);
                            return res;
                        })
                        .then(response => {
                            if (response[0] === ACK) {
                                if (this.replyMode) {
                                    logger.log('Sending ACK.');
                                    return this.serial.write(u8a([ACK]));
                                }
                                return Promise.resolve();
                            } else {
                                throw new Error('Unexpected response for sync byte. Check device family');
                            }
                        })
                        .then(() => {
                            logger.log('Bootloader is ready for commands');
                            resolve();
                        })
                        .catch(error => 
                        {
                            console.log("Rejected with error");
                            console.log(error);
                            reject(error);
                        });
                }
            });
        }

        /**
         * Resets the target by toggling a control pin defined in RTS_PIN
         * @private
         * @returns {Promise}
         */
         async enterBootMode() {
            return new Promise((resolve, reject) => {
                logger.log('Enter boot mode target...');
                let signal = {};

                if (!this.serial.isOpen()) {
                    reject(new Error('Port must be opened for device reset'));
                    return;
                }

        // def boot(a: float, b: float) -> None:
            // ser.dtr = 0
            // ser.rts = 1
            // time.sleep(a)
            // ser.dtr = 1
            // ser.rts = 0
            // time.sleep(b)
            // ser.dtr = 0

                signal[DTR_PIN] = PIN_HIGH; //boot=1
                signal[RTS_PIN] = PIN_LOW; //reset=0
                this.serial.control(signal)
                    .then(() => new Promise(resolve => setTimeout(resolve, 500)))
                    .then(() => {
                        signal[DTR_PIN] = PIN_HIGH; //boot=1
                        signal[RTS_PIN] = PIN_HIGH; //reset=1
                        return this.serial.control(signal);
                    })
                    .then(() => new Promise(resolve => setTimeout(resolve, 500)))
                    .then(() => {
                        signal[DTR_PIN] = PIN_LOW; //boot=0
                        signal[RTS_PIN] = PIN_HIGH; //reset=1
                        return this.serial.control(signal);
                    })
                    .then(() => {
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Resets the target by toggling a control pin defined in RTS_PIN
         * @private
         * @returns {Promise}
         */
        async resetTarget() {
            return new Promise((resolve, reject) => {
                logger.log('Resetting target...');
                let signal = {};

                if (!this.serial.isOpen()) {
                    reject(new Error('Port must be opened for device reset'));
                    return;
                }

                signal[RTS_PIN] = PIN_LOW; //RESET=0
                this.serial.control(signal)
                    .then(() => {
                        logger.log('Resetting...');
                        setTimeout(resolve, 200);
                    })
                    .then(() => {
                        signal[RTS_PIN] = PIN_HIGH; //RESET=1
                        return this.serial.control(signal);
                    })
                    .then(() => {
                        // wait for device init
                        logger.log('Reset done. Wait for init.');
                        this.ewrLoadState = EwrLoadState.NOT_LOADED;
                        setTimeout(resolve, 200);
                    })
                    .catch(reject);
            });
        }

        /**
         * Calcualtes the checksum (XOR) of the byte array.
         * @private
         * @param data Byte Array to calculate the checksum for.
         * @param {boolean} wLength If true takes the length of the array into the account (used for data write)
         * @returns {number} Calculated checksum
         */
        calcChecksum(data, wLength) {
            let result = 0;

            for (let i = 0; i < data.length; i += 1) {
                result = result ^ data[i];
            }

            if (wLength) {
                result = result ^ (data.length - 1);
            }

            return result;
        }
    }

    /* src\App.svelte generated by Svelte v3.50.1 */

    function create_if_block_4(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1_value = /*selectedFile*/ ctx[4].name + "";
    	let t1;
    	let div1_intro;

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text("File: ");
    			t1 = text(t1_value);
    			attr(div0, "class", "notification is-info py-2");
    			attr(div1, "class", "container is-fluid is-paddingless");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, t0);
    			append(div0, t1);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*selectedFile*/ 16 && t1_value !== (t1_value = /*selectedFile*/ ctx[4].name + "")) set_data(t1, t1_value);
    		},
    		i(local) {
    			if (!div1_intro) {
    				add_render_callback(() => {
    					div1_intro = create_in_transition(div1, fade, {});
    					div1_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div1);
    		}
    	};
    }

    // (753:4) {#if error}
    function create_if_block_3(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let div1_intro;
    	let div1_outro;
    	let current;

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text("Error: ");
    			t1 = text(/*error*/ ctx[9]);
    			attr(div0, "class", "notification is-danger");
    			attr(div1, "class", "container is-fluid is-paddingless");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, t0);
    			append(div0, t1);
    			current = true;
    		},
    		p(ctx, dirty) {
    			if (!current || dirty[0] & /*error*/ 512) set_data(t1, /*error*/ ctx[9]);
    		},
    		i(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (div1_outro) div1_outro.end(1);
    				div1_intro = create_in_transition(div1, fade, {});
    				div1_intro.start();
    			});

    			current = true;
    		},
    		o(local) {
    			if (div1_intro) div1_intro.invalidate();
    			div1_outro = create_out_transition(div1, fade, {});
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			if (detaching && div1_outro) div1_outro.end();
    		}
    	};
    }

    // (1038:4) {#if showPortDialog}
    function create_if_block_2(ctx) {
    	let portdialog;
    	let current;
    	portdialog = new PortDialog({});
    	portdialog.$on("close", /*close_handler*/ ctx[32]);
    	portdialog.$on("selected_port", /*onPortSelected*/ ctx[15]);

    	return {
    		c() {
    			create_component(portdialog.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(portdialog, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(portdialog.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(portdialog.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(portdialog, detaching);
    		}
    	};
    }

    // (1044:4) {#if showSettingsDialog}
    function create_if_block_1(ctx) {
    	let settingsdialog;
    	let current;
    	settingsdialog = new SettingsDialog({});
    	settingsdialog.$on("close", /*close_handler_1*/ ctx[33]);

    	return {
    		c() {
    			create_component(settingsdialog.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(settingsdialog, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(settingsdialog.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(settingsdialog.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(settingsdialog, detaching);
    		}
    	};
    }

    // (1048:4) {#if !navigator.serial}
    function create_if_block(ctx) {
    	let notsupporteddialog;
    	let current;
    	notsupporteddialog = new NotSupportedDialog({});

    	return {
    		c() {
    			create_component(notsupporteddialog.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(notsupporteddialog, target, anchor);
    			current = true;
    		},
    		i(local) {
    			if (current) return;
    			transition_in(notsupporteddialog.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(notsupporteddialog.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(notsupporteddialog, detaching);
    		}
    	};
    }

    function create_fragment(ctx) {
    	let div131;
    	let div7;
    	let div0;
    	let h1;
    	let t2;
    	let a0;
    	let span1;
    	let t3;
    	let span2;
    	let t4;
    	let span3;
    	let a0_class_value;
    	let t5;
    	let div6;
    	let div4;
    	let a1;
    	let div1;
    	let label;
    	let input0;
    	let t6;
    	let span4;
    	let t7;
    	let span5;
    	let t9;
    	let a2;
    	let span6;
    	let i1;
    	let i1_class_value;
    	let t10;
    	let span7;
    	let t11_value = (/*isConnected*/ ctx[1] ? 'Disconnect' : 'Connect') + "";
    	let t11;
    	let t12;
    	let a3;
    	let t15;
    	let a4;
    	let t18;
    	let a5;
    	let t21;
    	let a6;
    	let t24;
    	let a7;
    	let t27;
    	let a8;
    	let t30;
    	let div3;
    	let div2;
    	let select0;
    	let option0;
    	let option1;
    	let t33;
    	let div5;
    	let a9;
    	let span20;
    	let t34;
    	let span21;

    	let t35_value = (/*selectedPort*/ ctx[5]
    	? /*selectedPort*/ ctx[5].name
    	: 'Select port') + "";

    	let t35;
    	let div6_class_value;
    	let t36;
    	let t37;
    	let t38;
    	let div130;
    	let div129;
    	let div44;
    	let div43;
    	let p0;
    	let t40;
    	let div14;
    	let div10;
    	let t42;
    	let div13;
    	let div12;
    	let div11;

    	let t43_value = (/*deviceInfo*/ ctx[0].family == 'STM32'
    	? '32-bit'
    	: '8-bit') + "";

    	let t43;
    	let t44;
    	let div21;
    	let div17;
    	let t46;
    	let div20;
    	let div19;
    	let div18;
    	let t47_value = /*deviceInfo*/ ctx[0].bl + "";
    	let t47;
    	let t48;
    	let div28;
    	let div24;
    	let t50;
    	let div27;
    	let div26;
    	let div25;
    	let t51_value = /*deviceInfo*/ ctx[0].pid + "";
    	let t51;
    	let t52;
    	let div35;
    	let div31;
    	let t54;
    	let div34;
    	let div33;
    	let div32;
    	let t55_value = /*deviceInfo*/ ctx[0].serial_num + "";
    	let t55;
    	let t56;
    	let div42;
    	let div38;
    	let t58;
    	let div41;
    	let div40;
    	let div39;
    	let select1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let option6;
    	let t64;
    	let div46;
    	let div45;
    	let p1;
    	let t66;
    	let pre;
    	let t67;
    	let t68;
    	let div128;
    	let div127;
    	let p2;
    	let t70;
    	let div53;
    	let div49;
    	let t72;
    	let div52;
    	let div51;
    	let div50;
    	let t73_value = /*deviceInfo*/ ctx[0].revision + "";
    	let t73;
    	let t74;
    	let div60;
    	let div56;
    	let t76;
    	let div59;
    	let div58;
    	let div57;
    	let t77_value = /*deviceInfo*/ ctx[0].temperature + "";
    	let t77;
    	let t78;
    	let div67;
    	let div63;
    	let t80;
    	let div66;
    	let div65;
    	let div64;
    	let t81_value = /*deviceInfo*/ ctx[0].inp0 + "";
    	let t81;
    	let t82;
    	let div74;
    	let div70;
    	let t84;
    	let div73;
    	let div72;
    	let div71;
    	let t85_value = /*deviceInfo*/ ctx[0].inp1 + "";
    	let t85;
    	let t86;
    	let div81;
    	let div77;
    	let t88;
    	let div80;
    	let div79;
    	let div78;
    	let t89_value = /*deviceInfo*/ ctx[0].source + "";
    	let t89;
    	let t90;
    	let div86;
    	let t93;
    	let div91;
    	let t96;
    	let div96;
    	let t99;
    	let div101;
    	let t102;
    	let div106;
    	let t105;
    	let div111;
    	let t108;
    	let div116;
    	let t111;
    	let div121;
    	let t114;
    	let div126;
    	let t117;
    	let t118;
    	let t119;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*selectedFile*/ ctx[4] && create_if_block_4(ctx);
    	let if_block1 = /*error*/ ctx[9] && create_if_block_3(ctx);
    	let if_block2 = /*showPortDialog*/ ctx[7] && create_if_block_2(ctx);
    	let if_block3 = /*showSettingsDialog*/ ctx[8] && create_if_block_1(ctx);
    	let if_block4 = !navigator.serial && create_if_block();

    	return {
    		c() {
    			div131 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.innerHTML = `IV-Flasher<span id="subtitle" class="is-size-6 svelte-1ei71ab">serial</span>`;
    			t2 = space();
    			a0 = element("a");
    			span1 = element("span");
    			t3 = space();
    			span2 = element("span");
    			t4 = space();
    			span3 = element("span");
    			t5 = space();
    			div6 = element("div");
    			div4 = element("div");
    			a1 = element("a");
    			div1 = element("div");
    			label = element("label");
    			input0 = element("input");
    			t6 = space();
    			span4 = element("span");
    			span4.innerHTML = `<i class="fa fa-folder-open"></i>`;
    			t7 = space();
    			span5 = element("span");
    			span5.textContent = "Open File";
    			t9 = space();
    			a2 = element("a");
    			span6 = element("span");
    			i1 = element("i");
    			t10 = space();
    			span7 = element("span");
    			t11 = text(t11_value);
    			t12 = space();
    			a3 = element("a");

    			a3.innerHTML = `<span class="icon"><i class="fa fa-eraser"></i></span> 
                    <span>Full Erase</span>`;

    			t15 = space();
    			a4 = element("a");

    			a4.innerHTML = `<span class="icon"><i class="fas fa-pen"></i></span> 
                    <span>Flash</span>`;

    			t18 = space();
    			a5 = element("a");

    			a5.innerHTML = `<span class="icon"><i class="fa fa-play"></i></span> 
                    <span>Flash &amp; Go</span>`;

    			t21 = space();
    			a6 = element("a");

    			a6.innerHTML = `<span class="icon"><i class="fa fa-cog"></i></span> 
                    <span>Settings</span>`;

    			t24 = space();
    			a7 = element("a");

    			a7.innerHTML = `<span class="icon"><i class="fa fa-car"></i></span> 
                    <span id="getDataLabel">Get data</span>`;

    			t27 = space();
    			a8 = element("a");

    			a8.innerHTML = `<span class="icon"><i class="fa fa-car"></i></span> 
                    <span id="sendDataLabel">Send data</span>`;

    			t30 = space();
    			div3 = element("div");
    			div2 = element("div");
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "Artery";
    			option1 = element("option");
    			option1.textContent = "STM32";
    			t33 = space();
    			div5 = element("div");
    			a9 = element("a");
    			span20 = element("span");
    			span20.innerHTML = `<i class="fas fa-plug"></i>`;
    			t34 = space();
    			span21 = element("span");
    			t35 = text(t35_value);
    			t36 = space();
    			if (if_block0) if_block0.c();
    			t37 = space();
    			if (if_block1) if_block1.c();
    			t38 = space();
    			div130 = element("div");
    			div129 = element("div");
    			div44 = element("div");
    			div43 = element("div");
    			p0 = element("p");
    			p0.textContent = "Device Info";
    			t40 = space();
    			div14 = element("div");
    			div10 = element("div");
    			div10.innerHTML = `<div class="level-item"><div class="label">Family:</div></div>`;
    			t42 = space();
    			div13 = element("div");
    			div12 = element("div");
    			div11 = element("div");
    			t43 = text(t43_value);
    			t44 = space();
    			div21 = element("div");
    			div17 = element("div");
    			div17.innerHTML = `<div class="level-item"><div class="label">Bootloader:</div></div>`;
    			t46 = space();
    			div20 = element("div");
    			div19 = element("div");
    			div18 = element("div");
    			t47 = text(t47_value);
    			t48 = space();
    			div28 = element("div");
    			div24 = element("div");
    			div24.innerHTML = `<div class="level-item"><div class="label">Product ID:</div></div>`;
    			t50 = space();
    			div27 = element("div");
    			div26 = element("div");
    			div25 = element("div");
    			t51 = text(t51_value);
    			t52 = space();
    			div35 = element("div");
    			div31 = element("div");
    			div31.innerHTML = `<div class="level-item"><div class="label">Serial number:</div></div>`;
    			t54 = space();
    			div34 = element("div");
    			div33 = element("div");
    			div32 = element("div");
    			t55 = text(t55_value);
    			t56 = space();
    			div42 = element("div");
    			div38 = element("div");
    			div38.innerHTML = `<div class="level-item"><div class="label">STM8 type:</div></div>`;
    			t58 = space();
    			div41 = element("div");
    			div40 = element("div");
    			div39 = element("div");
    			select1 = element("select");
    			option2 = element("option");
    			option2.textContent = "Select device...\r\n                                        ";
    			option3 = element("option");
    			option3.textContent = "STM8 S/A 32K";
    			option4 = element("option");
    			option4.textContent = "STM8 S/A 128K\r\n                                        ";
    			option5 = element("option");
    			option5.textContent = "STM8 S/A 256K\r\n                                        ";
    			option6 = element("option");
    			option6.textContent = "STM8 L";
    			t64 = space();
    			div46 = element("div");
    			div45 = element("div");
    			p1 = element("p");
    			p1.textContent = "Log Messages";
    			t66 = space();
    			pre = element("pre");
    			t67 = text(/*logs*/ ctx[6]);
    			t68 = space();
    			div128 = element("div");
    			div127 = element("div");
    			p2 = element("p");
    			p2.textContent = "Sensors data";
    			t70 = space();
    			div53 = element("div");
    			div49 = element("div");
    			div49.innerHTML = `<div class="level-item"><div class="label">Revision:</div></div>`;
    			t72 = space();
    			div52 = element("div");
    			div51 = element("div");
    			div50 = element("div");
    			t73 = text(t73_value);
    			t74 = space();
    			div60 = element("div");
    			div56 = element("div");
    			div56.innerHTML = `<div class="level-item"><div class="label">Temperature:</div></div>`;
    			t76 = space();
    			div59 = element("div");
    			div58 = element("div");
    			div57 = element("div");
    			t77 = text(t77_value);
    			t78 = space();
    			div67 = element("div");
    			div63 = element("div");
    			div63.innerHTML = `<div class="level-item"><div class="label">Input 0, V:</div></div>`;
    			t80 = space();
    			div66 = element("div");
    			div65 = element("div");
    			div64 = element("div");
    			t81 = text(t81_value);
    			t82 = space();
    			div74 = element("div");
    			div70 = element("div");
    			div70.innerHTML = `<div class="level-item"><div class="label">Input 1, V:</div></div>`;
    			t84 = space();
    			div73 = element("div");
    			div72 = element("div");
    			div71 = element("div");
    			t85 = text(t85_value);
    			t86 = space();
    			div81 = element("div");
    			div77 = element("div");
    			div77.innerHTML = `<div class="level-item"><div class="label">Source:</div></div>`;
    			t88 = space();
    			div80 = element("div");
    			div79 = element("div");
    			div78 = element("div");
    			t89 = text(t89_value);
    			t90 = space();
    			div86 = element("div");

    			div86.innerHTML = `<div class="level-left"><div class="level-item"><output class="label" for="sliderRangeMin" id="sliderRangeMinTooltip">50</output></div></div> 
                        <div class="level-right"><div class="level-item"><input id="sliderRangeMin" class="slider" min="0" max="12000" value="0" step="100" type="range"/></div></div>`;

    			t93 = space();
    			div91 = element("div");

    			div91.innerHTML = `<div class="level-left"><div class="level-item"><output class="label" for="sliderRangeMax" id="sliderRangeMaxTooltip">50</output></div></div> 
                        <div class="level-right"><div class="level-item"><input id="sliderRangeMax" class="slider" min="0" max="30000" value="0" step="100" type="range"/></div></div>`;

    			t96 = space();
    			div96 = element("div");

    			div96.innerHTML = `<div class="level-left"><div class="level-item"><output class="label" for="sliderHStart" id="sliderHStartTooltip">50</output></div></div> 
                        <div class="level-right"><div class="level-item"><input id="sliderHStart" class="slider" min="0" max="255" value="0" step="1" type="range"/></div></div>`;

    			t99 = space();
    			div101 = element("div");

    			div101.innerHTML = `<div class="level-left"><div class="level-item"><output class="label" for="sliderHEnd" id="sliderHEndTooltip">50</output></div></div> 
                        <div class="level-right"><div class="level-item"><input id="sliderHEnd" class="slider" min="0" max="255" value="0" step="1" type="range"/></div></div>`;

    			t102 = space();
    			div106 = element("div");

    			div106.innerHTML = `<div class="level-left"><div class="level-item"><output class="label" for="sliderS" id="sliderSTooltip">50</output></div></div> 
                        <div class="level-right"><div class="level-item"><input id="sliderS" class="slider" min="0" max="255" value="0" step="1" type="range"/></div></div>`;

    			t105 = space();
    			div111 = element("div");

    			div111.innerHTML = `<div class="level-left"><div class="level-item"><output class="label" for="sliderV" id="sliderVTooltip">50</output></div></div> 
                        <div class="level-right"><div class="level-item"><input id="sliderV" class="slider" min="0" max="255" value="0" step="1" type="range"/></div></div>`;

    			t108 = space();
    			div116 = element("div");

    			div116.innerHTML = `<div class="level-left"><div class="level-item"><output class="label" for="sliderHBl" id="sliderHBlTooltip">50</output></div></div> 
                        <div class="level-right"><div class="level-item"><input id="sliderHBl" class="slider" min="0" max="255" value="0" step="1" type="range"/></div></div>`;

    			t111 = space();
    			div121 = element("div");

    			div121.innerHTML = `<div class="level-left"><div class="level-item"><output class="label" for="sliderSBl" id="sliderSBlTooltip">50</output></div></div> 
                        <div class="level-right"><div class="level-item"><input id="sliderSBl" class="slider" min="0" max="255" value="0" step="1" type="range"/></div></div>`;

    			t114 = space();
    			div126 = element("div");

    			div126.innerHTML = `<div class="level-left"><div class="level-item"><output class="label" for="sliderVBl" id="sliderVBlTooltip">50</output></div></div> 
                        <div class="level-right"><div class="level-item"><input id="sliderVBl" class="slider" min="0" max="255" value="0" step="1" type="range"/></div></div>`;

    			t117 = space();
    			if (if_block2) if_block2.c();
    			t118 = space();
    			if (if_block3) if_block3.c();
    			t119 = space();
    			if (if_block4) if_block4.c();
    			attr(h1, "class", "navbar-item is-size-5 mr-3 pt-1");
    			attr(span1, "aria-hidden", "true");
    			attr(span2, "aria-hidden", "true");
    			attr(span3, "aria-hidden", "true");
    			attr(a0, "role", "button");
    			attr(a0, "class", a0_class_value = "navbar-burger burger " + (/*burgerActive*/ ctx[3] ? 'is-active' : ''));
    			attr(a0, "aria-label", "menu");
    			attr(a0, "aria-expanded", "false");
    			attr(a0, "data-target", "blpnavbar");
    			attr(div0, "class", "navbar-brand");
    			attr(input0, "class", "file-input");
    			attr(input0, "type", "file");
    			attr(input0, "accept", ".s19,.hex,.ihx,.bin");
    			attr(input0, "name", "file");
    			attr(span4, "class", "icon");
    			attr(span5, "class", "file-label");
    			attr(label, "class", "file-label");
    			attr(div1, "class", "file");
    			attr(a1, "class", "navbar-item");
    			attr(i1, "class", i1_class_value = "fa " + (/*isConnected*/ ctx[1] ? 'fa-unlink' : 'fa-link'));
    			attr(span6, "class", "icon");
    			attr(a2, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a2, "disabled", /*isConnecting*/ ctx[12] || !/*selectedPort*/ ctx[5]);
    			attr(a3, "class", "navbar-item");
    			toggle_class(a3, "is-hidden", !/*cmdsAllowed*/ ctx[10] || /*settings*/ ctx[2]._modbus);
    			attr(a4, "class", "navbar-item");
    			toggle_class(a4, "is-hidden", !/*selectedFile*/ ctx[4] || !/*cmdsAllowed*/ ctx[10] || /*settings*/ ctx[2]._modbus);
    			attr(a5, "class", "navbar-item");
    			toggle_class(a5, "is-hidden", !/*selectedFile*/ ctx[4] || !/*cmdsAllowed*/ ctx[10] || /*settings*/ ctx[2]._modbus);
    			attr(a6, "class", "navbar-item");
    			attr(a7, "class", "navbar-item");
    			toggle_class(a7, "is-hidden", !/*settings*/ ctx[2]._modbus || !/*isConnected*/ ctx[1]);
    			attr(a8, "class", "navbar-item");
    			toggle_class(a8, "is-hidden", !/*settings*/ ctx[2]._modbus || !/*isConnected*/ ctx[1]);
    			option0.__value = "Artery";
    			option0.value = option0.__value;
    			option1.__value = "STM32";
    			option1.value = option1.__value;
    			attr(select0, "id", "mcuType");
    			if (/*settings*/ ctx[2].mcutype === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[31].call(select0));
    			attr(div2, "class", "select");
    			attr(div3, "class", "navbar-item");
    			attr(div4, "class", "navbar-start");
    			attr(span20, "class", "icon");
    			attr(a9, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a9, "disabled", !/*isDisconnected*/ ctx[11]);
    			attr(div5, "class", "navbar-end");
    			attr(div6, "id", "blpnavbar");
    			attr(div6, "class", div6_class_value = "navbar-menu " + (/*burgerActive*/ ctx[3] ? 'is-active' : ''));
    			attr(div7, "class", "navbar has-shadow");
    			attr(p0, "class", "title is-5");
    			attr(div10, "class", "level-left");
    			attr(div11, "class", "value");
    			attr(div12, "class", "level-item");
    			attr(div13, "class", "level-right");
    			attr(div14, "class", "level is-mobile");
    			attr(div17, "class", "level-left");
    			attr(div18, "class", "value");
    			attr(div19, "class", "level-item");
    			attr(div20, "class", "level-right");
    			attr(div21, "class", "level is-mobile");
    			attr(div24, "class", "level-left");
    			attr(div25, "class", "value");
    			attr(div26, "class", "level-item");
    			attr(div27, "class", "level-right");
    			attr(div28, "class", "level is-mobile");
    			attr(div31, "class", "level-left");
    			attr(div32, "class", "value");
    			attr(div33, "class", "level-item");
    			attr(div34, "class", "level-right");
    			attr(div35, "class", "level is-mobile");
    			attr(div38, "class", "level-left");
    			option2.__value = "-1";
    			option2.value = option2.__value;
    			option2.selected = true;
    			option3.__value = "32";
    			option3.value = option3.__value;
    			option4.__value = "128";
    			option4.value = option4.__value;
    			option5.__value = "256";
    			option5.value = option5.__value;
    			option6.__value = "0";
    			option6.value = option6.__value;
    			attr(select1, "id", "devices");
    			attr(div39, "class", "select value");
    			attr(div40, "class", "level-item");
    			attr(div41, "class", "level-right");
    			attr(div42, "class", "level is-mobile");
    			toggle_class(div42, "is-hidden", /*deviceInfo*/ ctx[0].family !== 'STM8');
    			attr(div43, "class", "box");
    			attr(div43, "id", "devinfo");
    			attr(div44, "class", "column is-narrow");
    			set_style(div44, "min-width", "360px");
    			attr(p1, "class", "title is-5");
    			attr(div45, "class", "box");
    			attr(div46, "class", "column");
    			attr(p2, "class", "title is-5");
    			attr(div49, "class", "level-left");
    			attr(div50, "class", "value");
    			attr(div51, "class", "level-item");
    			attr(div52, "class", "level-right");
    			attr(div53, "class", "level is-mobile");
    			attr(div56, "class", "level-left");
    			attr(div57, "class", "value");
    			attr(div58, "class", "level-item");
    			attr(div59, "class", "level-right");
    			attr(div60, "class", "level is-mobile");
    			attr(div63, "class", "level-left");
    			attr(div64, "class", "value");
    			attr(div65, "class", "level-item");
    			attr(div66, "class", "level-right");
    			attr(div67, "class", "level is-mobile");
    			attr(div70, "class", "level-left");
    			attr(div71, "class", "value");
    			attr(div72, "class", "level-item");
    			attr(div73, "class", "level-right");
    			attr(div74, "class", "level is-mobile");
    			attr(div77, "class", "level-left");
    			attr(div78, "class", "value");
    			attr(div79, "class", "level-item");
    			attr(div80, "class", "level-right");
    			attr(div81, "class", "level is-mobile");
    			attr(div86, "class", "level is-mobile");
    			attr(div91, "class", "level is-mobile");
    			attr(div96, "class", "level is-mobile");
    			attr(div101, "class", "level is-mobile");
    			attr(div106, "class", "level is-mobile");
    			attr(div111, "class", "level is-mobile");
    			attr(div116, "class", "level is-mobile");
    			attr(div121, "class", "level is-mobile");
    			attr(div126, "class", "level is-mobile");
    			attr(div127, "class", "box");
    			attr(div127, "id", "devinfo");
    			attr(div128, "class", "column is-narrow");
    			set_style(div128, "min-width", "360px");
    			attr(div129, "class", "columns");
    			attr(div130, "class", "container is-fluid mt-4");
    			attr(div131, "id", "app");
    		},
    		m(target, anchor) {
    			insert(target, div131, anchor);
    			append(div131, div7);
    			append(div7, div0);
    			append(div0, h1);
    			append(div0, t2);
    			append(div0, a0);
    			append(a0, span1);
    			append(a0, t3);
    			append(a0, span2);
    			append(a0, t4);
    			append(a0, span3);
    			append(div7, t5);
    			append(div7, div6);
    			append(div6, div4);
    			append(div4, a1);
    			append(a1, div1);
    			append(div1, label);
    			append(label, input0);
    			append(label, t6);
    			append(label, span4);
    			append(label, t7);
    			append(label, span5);
    			append(div4, t9);
    			append(div4, a2);
    			append(a2, span6);
    			append(span6, i1);
    			append(a2, t10);
    			append(a2, span7);
    			append(span7, t11);
    			append(div4, t12);
    			append(div4, a3);
    			append(div4, t15);
    			append(div4, a4);
    			append(div4, t18);
    			append(div4, a5);
    			append(div4, t21);
    			append(div4, a6);
    			append(div4, t24);
    			append(div4, a7);
    			append(div4, t27);
    			append(div4, a8);
    			append(div4, t30);
    			append(div4, div3);
    			append(div3, div2);
    			append(div2, select0);
    			append(select0, option0);
    			append(select0, option1);
    			select_option(select0, /*settings*/ ctx[2].mcutype);
    			append(div6, t33);
    			append(div6, div5);
    			append(div5, a9);
    			append(a9, span20);
    			append(a9, t34);
    			append(a9, span21);
    			append(span21, t35);
    			append(div131, t36);
    			if (if_block0) if_block0.m(div131, null);
    			append(div131, t37);
    			if (if_block1) if_block1.m(div131, null);
    			append(div131, t38);
    			append(div131, div130);
    			append(div130, div129);
    			append(div129, div44);
    			append(div44, div43);
    			append(div43, p0);
    			append(div43, t40);
    			append(div43, div14);
    			append(div14, div10);
    			append(div14, t42);
    			append(div14, div13);
    			append(div13, div12);
    			append(div12, div11);
    			append(div11, t43);
    			append(div43, t44);
    			append(div43, div21);
    			append(div21, div17);
    			append(div21, t46);
    			append(div21, div20);
    			append(div20, div19);
    			append(div19, div18);
    			append(div18, t47);
    			append(div43, t48);
    			append(div43, div28);
    			append(div28, div24);
    			append(div28, t50);
    			append(div28, div27);
    			append(div27, div26);
    			append(div26, div25);
    			append(div25, t51);
    			append(div43, t52);
    			append(div43, div35);
    			append(div35, div31);
    			append(div35, t54);
    			append(div35, div34);
    			append(div34, div33);
    			append(div33, div32);
    			append(div32, t55);
    			append(div43, t56);
    			append(div43, div42);
    			append(div42, div38);
    			append(div42, t58);
    			append(div42, div41);
    			append(div41, div40);
    			append(div40, div39);
    			append(div39, select1);
    			append(select1, option2);
    			append(select1, option3);
    			append(select1, option4);
    			append(select1, option5);
    			append(select1, option6);
    			append(div129, t64);
    			append(div129, div46);
    			append(div46, div45);
    			append(div45, p1);
    			append(div45, t66);
    			append(div45, pre);
    			append(pre, t67);
    			append(div129, t68);
    			append(div129, div128);
    			append(div128, div127);
    			append(div127, p2);
    			append(div127, t70);
    			append(div127, div53);
    			append(div53, div49);
    			append(div53, t72);
    			append(div53, div52);
    			append(div52, div51);
    			append(div51, div50);
    			append(div50, t73);
    			append(div127, t74);
    			append(div127, div60);
    			append(div60, div56);
    			append(div60, t76);
    			append(div60, div59);
    			append(div59, div58);
    			append(div58, div57);
    			append(div57, t77);
    			append(div127, t78);
    			append(div127, div67);
    			append(div67, div63);
    			append(div67, t80);
    			append(div67, div66);
    			append(div66, div65);
    			append(div65, div64);
    			append(div64, t81);
    			append(div127, t82);
    			append(div127, div74);
    			append(div74, div70);
    			append(div74, t84);
    			append(div74, div73);
    			append(div73, div72);
    			append(div72, div71);
    			append(div71, t85);
    			append(div127, t86);
    			append(div127, div81);
    			append(div81, div77);
    			append(div81, t88);
    			append(div81, div80);
    			append(div80, div79);
    			append(div79, div78);
    			append(div78, t89);
    			append(div127, t90);
    			append(div127, div86);
    			append(div127, t93);
    			append(div127, div91);
    			append(div127, t96);
    			append(div127, div96);
    			append(div127, t99);
    			append(div127, div101);
    			append(div127, t102);
    			append(div127, div106);
    			append(div127, t105);
    			append(div127, div111);
    			append(div127, t108);
    			append(div127, div116);
    			append(div127, t111);
    			append(div127, div121);
    			append(div127, t114);
    			append(div127, div126);
    			append(div131, t117);
    			if (if_block2) if_block2.m(div131, null);
    			append(div131, t118);
    			if (if_block3) if_block3.m(div131, null);
    			append(div131, t119);
    			if (if_block4) if_block4.m(div131, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(a0, "click", /*onBurgerClick*/ ctx[14]),
    					listen(input0, "change", /*onOpenFile*/ ctx[16]),
    					listen(a2, "click", /*onConnect*/ ctx[20]),
    					listen(a3, "click", /*onErase*/ ctx[21]),
    					listen(a4, "click", /*click_handler*/ ctx[27]),
    					listen(a5, "click", /*click_handler_1*/ ctx[28]),
    					listen(a6, "click", /*onSettings*/ ctx[22]),
    					listen(a7, "click", /*click_handler_2*/ ctx[29]),
    					listen(a8, "click", /*click_handler_3*/ ctx[30]),
    					listen(select0, "change", /*select0_change_handler*/ ctx[31]),
    					listen(a9, "click", /*onSelectPort*/ ctx[13]),
    					listen(select1, "change", /*onStm8Select*/ ctx[23])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (!current || dirty[0] & /*burgerActive*/ 8 && a0_class_value !== (a0_class_value = "navbar-burger burger " + (/*burgerActive*/ ctx[3] ? 'is-active' : ''))) {
    				attr(a0, "class", a0_class_value);
    			}

    			if (!current || dirty[0] & /*isConnected*/ 2 && i1_class_value !== (i1_class_value = "fa " + (/*isConnected*/ ctx[1] ? 'fa-unlink' : 'fa-link'))) {
    				attr(i1, "class", i1_class_value);
    			}

    			if ((!current || dirty[0] & /*isConnected*/ 2) && t11_value !== (t11_value = (/*isConnected*/ ctx[1] ? 'Disconnect' : 'Connect') + "")) set_data(t11, t11_value);

    			if (!current || dirty[0] & /*isConnecting, selectedPort*/ 4128) {
    				toggle_class(a2, "disabled", /*isConnecting*/ ctx[12] || !/*selectedPort*/ ctx[5]);
    			}

    			if (!current || dirty[0] & /*cmdsAllowed, settings*/ 1028) {
    				toggle_class(a3, "is-hidden", !/*cmdsAllowed*/ ctx[10] || /*settings*/ ctx[2]._modbus);
    			}

    			if (!current || dirty[0] & /*selectedFile, cmdsAllowed, settings*/ 1044) {
    				toggle_class(a4, "is-hidden", !/*selectedFile*/ ctx[4] || !/*cmdsAllowed*/ ctx[10] || /*settings*/ ctx[2]._modbus);
    			}

    			if (!current || dirty[0] & /*selectedFile, cmdsAllowed, settings*/ 1044) {
    				toggle_class(a5, "is-hidden", !/*selectedFile*/ ctx[4] || !/*cmdsAllowed*/ ctx[10] || /*settings*/ ctx[2]._modbus);
    			}

    			if (!current || dirty[0] & /*settings, isConnected*/ 6) {
    				toggle_class(a7, "is-hidden", !/*settings*/ ctx[2]._modbus || !/*isConnected*/ ctx[1]);
    			}

    			if (!current || dirty[0] & /*settings, isConnected*/ 6) {
    				toggle_class(a8, "is-hidden", !/*settings*/ ctx[2]._modbus || !/*isConnected*/ ctx[1]);
    			}

    			if (dirty[0] & /*settings*/ 4) {
    				select_option(select0, /*settings*/ ctx[2].mcutype);
    			}

    			if ((!current || dirty[0] & /*selectedPort*/ 32) && t35_value !== (t35_value = (/*selectedPort*/ ctx[5]
    			? /*selectedPort*/ ctx[5].name
    			: 'Select port') + "")) set_data(t35, t35_value);

    			if (!current || dirty[0] & /*isDisconnected*/ 2048) {
    				toggle_class(a9, "disabled", !/*isDisconnected*/ ctx[11]);
    			}

    			if (!current || dirty[0] & /*burgerActive*/ 8 && div6_class_value !== (div6_class_value = "navbar-menu " + (/*burgerActive*/ ctx[3] ? 'is-active' : ''))) {
    				attr(div6, "class", div6_class_value);
    			}

    			if (/*selectedFile*/ ctx[4]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*selectedFile*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div131, t37);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*error*/ ctx[9]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*error*/ 512) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div131, t38);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t43_value !== (t43_value = (/*deviceInfo*/ ctx[0].family == 'STM32'
    			? '32-bit'
    			: '8-bit') + "")) set_data(t43, t43_value);

    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t47_value !== (t47_value = /*deviceInfo*/ ctx[0].bl + "")) set_data(t47, t47_value);
    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t51_value !== (t51_value = /*deviceInfo*/ ctx[0].pid + "")) set_data(t51, t51_value);
    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t55_value !== (t55_value = /*deviceInfo*/ ctx[0].serial_num + "")) set_data(t55, t55_value);

    			if (!current || dirty[0] & /*deviceInfo*/ 1) {
    				toggle_class(div42, "is-hidden", /*deviceInfo*/ ctx[0].family !== 'STM8');
    			}

    			if (!current || dirty[0] & /*logs*/ 64) set_data(t67, /*logs*/ ctx[6]);
    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t73_value !== (t73_value = /*deviceInfo*/ ctx[0].revision + "")) set_data(t73, t73_value);
    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t77_value !== (t77_value = /*deviceInfo*/ ctx[0].temperature + "")) set_data(t77, t77_value);
    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t81_value !== (t81_value = /*deviceInfo*/ ctx[0].inp0 + "")) set_data(t81, t81_value);
    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t85_value !== (t85_value = /*deviceInfo*/ ctx[0].inp1 + "")) set_data(t85, t85_value);
    			if ((!current || dirty[0] & /*deviceInfo*/ 1) && t89_value !== (t89_value = /*deviceInfo*/ ctx[0].source + "")) set_data(t89, t89_value);

    			if (/*showPortDialog*/ ctx[7]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*showPortDialog*/ 128) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div131, t118);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*showSettingsDialog*/ ctx[8]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*showSettingsDialog*/ 256) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div131, t119);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div131);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    const DISCONNECTED = 'disconnected';
    const CONNECTING = 'connecting';
    const CONNECTED = 'connected';

    function updateSliderValue(sl, val) {
    	sl.value = val;
    }

    function updateCaptions() {
    	var sliderRangeMin = document.getElementById('sliderRangeMin');
    	var sliderRangeMinOut = document.querySelector('output[for="sliderRangeMin"]');
    	var sliderRangeMax = document.getElementById('sliderRangeMax');
    	var sliderRangeMaxOut = document.querySelector('output[for="sliderRangeMax"]');
    	var sliderHStart = document.getElementById('sliderHStart');
    	var sliderHStartOut = document.querySelector('output[for="sliderHStart"]');
    	var sliderHEnd = document.getElementById('sliderHEnd');
    	var sliderHEndOut = document.querySelector('output[for="sliderHEnd"]');
    	var sliderS = document.getElementById('sliderS');
    	var sliderSOut = document.querySelector('output[for="sliderS"]');
    	var sliderV = document.getElementById('sliderV');
    	var sliderVOut = document.querySelector('output[for="sliderV"]');
    	var sliderHBl = document.getElementById('sliderHBl');
    	var sliderHBlOut = document.querySelector('output[for="sliderHBl"]');
    	var sliderSBl = document.getElementById('sliderSBl');
    	var sliderSBlOut = document.querySelector('output[for="sliderSBl"]');
    	var sliderVBl = document.getElementById('sliderVBl');
    	var sliderVBlOut = document.querySelector('output[for="sliderVBl"]');
    	updateSliderOutput(sliderRangeMinOut, sliderRangeMin, "Range Min(V): ");
    	updateSliderOutput(sliderRangeMaxOut, sliderRangeMax, "Range Max(V): ");
    	updateSliderOutput(sliderHStartOut, sliderHStart, "Hue Start: ");
    	updateSliderOutput(sliderHEndOut, sliderHEnd, "Hue End: ");
    	updateSliderOutput(sliderSOut, sliderS, "C.Sat: ");
    	updateSliderOutput(sliderVOut, sliderV, "C.Val: ");
    	updateSliderOutput(sliderHBlOut, sliderHBl, "Bl.C.Hue: ");
    	updateSliderOutput(sliderSBlOut, sliderSBl, "Bl.C.Sat: ");
    	updateSliderOutput(sliderVBlOut, sliderVBl, "Bl.C.Val: ");
    }

    function updateSliderOutput(el, sl, txt) {
    	el.textContent = txt + sl.value;
    }

    function instance($$self, $$props, $$invalidate) {
    	let isConnected;
    	let isConnecting;
    	let isDisconnected;
    	let cmdsAllowed;
    	let burgerActive = false;
    	let selectedFile = null;
    	let selectedPort = null;
    	let isGetDataActive = false;
    	let isSendDataActive = false;
    	let logs = '';
    	let showPortDialog = false;
    	let showSettingsDialog = false;
    	let connectionState = DISCONNECTED;
    	let error = null;
    	let stmApi = null;
    	let parNum = 0;

    	let deviceInfo = {
    		family: '-',
    		bl: '-',
    		pid: '-',
    		serial_num: 0,
    		commands: [],
    		temperature: 999,
    		inp0: 0,
    		inp1: 0,
    		source: 0,
    		revision: 999,
    		range_start: 0,
    		range_end: 0,
    		hue_start: 0,
    		hue_end: 0,
    		saturation: 0,
    		c_value: 0,
    		backlight_value: 0,
    		backlight_saturation: 0,
    		backlight_hue: 0
    	};

    	let stm8selected = false;
    	let sending = false;

    	logger.registerLogger({
    		log(...args) {
    			log(args[0]);
    		}
    	});

    	function onSelectPort() {
    		$$invalidate(9, error = null);
    		$$invalidate(7, showPortDialog = true);
    	}

    	function onBurgerClick() {
    		$$invalidate(3, burgerActive = !burgerActive);
    	}

    	function log(message) {
    		$$invalidate(6, logs += message + '\n');
    	}

    	function onPortSelected(event) {
    		$$invalidate(9, error = null);
    		$$invalidate(5, selectedPort = event.detail);
    		let serial = new WebSerial(selectedPort);

    		serial.onConnect = () => {
    			
    		};

    		serial.onDisconnect = () => {
    			$$invalidate(26, sending = false);
    			$$invalidate(24, connectionState = DISCONNECTED);
    		}; //logs = '';

    		stmApi = new STMApi(serial);
    	}

    	function onOpenFile(event) {
    		$$invalidate(9, error = null);
    		$$invalidate(4, selectedFile = event.target.files[0]);
    	}

    	function modbusSetParameters() {
    		if (isSendDataActive && isConnected && settings._modbus) {
    			$$invalidate(0, deviceInfo.family = "IV", deviceInfo);
    			var sliderRangeMin = document.getElementById('sliderRangeMin');
    			var sliderRangeMax = document.getElementById('sliderRangeMax');
    			var sliderHStart = document.getElementById('sliderHStart');
    			var sliderHEnd = document.getElementById('sliderHEnd');
    			var sliderS = document.getElementById('sliderS');
    			var sliderV = document.getElementById('sliderV');
    			var sliderHBl = document.getElementById('sliderHBl');
    			var sliderSBl = document.getElementById('sliderSBl');
    			var sliderVBl = document.getElementById('sliderVBl');
    			$$invalidate(0, deviceInfo.range_start = sliderRangeMin.value * 1, deviceInfo);
    			$$invalidate(0, deviceInfo.range_end = sliderRangeMax.value * 1, deviceInfo);
    			$$invalidate(0, deviceInfo.hue_start = sliderHStart.value * 1, deviceInfo);
    			$$invalidate(0, deviceInfo.hue_end = sliderHEnd.value * 1, deviceInfo);
    			$$invalidate(0, deviceInfo.c_value = sliderV.value * 1, deviceInfo);
    			$$invalidate(0, deviceInfo.saturation = sliderS.value * 1, deviceInfo);
    			$$invalidate(0, deviceInfo.backlight_value = sliderVBl.value * 1, deviceInfo);
    			$$invalidate(0, deviceInfo.backlight_hue = sliderHBl.value * 1, deviceInfo);
    			$$invalidate(0, deviceInfo.backlight_saturation = sliderSBl.value * 1, deviceInfo);
    			console.log('color value:' + sliderS.value);
    			if (parNum == 0) stmApi.cmdModbusWRITEReg(11, deviceInfo.range_start); else if (parNum == 1) stmApi.cmdModbusWRITEReg(12, deviceInfo.range_end); else if (parNum == 2) stmApi.cmdModbusWRITEReg(15, deviceInfo.c_value); else if (parNum == 3) stmApi.cmdModbusWRITEReg(16, deviceInfo.saturation); else if (parNum == 4) stmApi.cmdModbusWRITEReg(17, deviceInfo.hue_start); else if (parNum == 5) stmApi.cmdModbusWRITEReg(18, deviceInfo.hue_end); else if (parNum == 6) stmApi.cmdModbusWRITEReg(20, deviceInfo.backlight_value); else if (parNum == 7) stmApi.cmdModbusWRITEReg(21, deviceInfo.backlight_saturation); else if (parNum == 8) stmApi.cmdModbusWRITEReg(22, deviceInfo.backlight_hue); else if (parNum == 9) stmApi.cmdModbusWRITEReg(0xABCD, 0xABCD);
    			parNum += 1;
    			if (parNum == 10) parNum = 0;
    		} /*stmApi.cmdModbusWRITEReg(11,deviceInfo.range_start)
    .then(()=>{
        stmApi.cmdModbusWRITEReg(12,deviceInfo.range_end);
    })
    .then(()=>{
        stmApi.cmdModbusWRITEReg(15,deviceInfo.c_value);
    })
    .then(()=>{
        stmApi.cmdModbusWRITEReg(16,deviceInfo.saturation);
    })
    .then(()=>{
        stmApi.cmdModbusWRITEReg(17,deviceInfo.hue_start);
    })
    .then(()=>{
        stmApi.cmdModbusWRITEReg(18,deviceInfo.hue_end);
    })
    .then(()=>{
        stmApi.cmdModbusWRITEReg(20,deviceInfo.backlight_value);
    })
    .then(()=>{
        stmApi.cmdModbusWRITEReg(21,deviceInfo.backlight_saturation);
    })
    .then(()=>{
        stmApi.cmdModbusWRITEReg(22,deviceInfo.backlight_hue);
    })
    .then(()=>{
        stmApi.cmdModbusWRITEReg(0xABCD,0xABCD);
    });*/
    	}

    	function modbusGetDataTimer() {
    		if (isGetDataActive && settings._modbus) {
    			stmApi.cmdGET().then(info => {
    				$$invalidate(0, deviceInfo.bl = info.blVersion, deviceInfo);
    				$$invalidate(0, deviceInfo.commands = info.commands, deviceInfo);
    				console.log("Setting data");

    				if (!settings._modbus) {
    					$$invalidate(0, deviceInfo.family = info.getFamily(), deviceInfo);

    					if (deviceInfo.family === 'STM32') {
    						//deviceInfo.family = '32-bit'
    						return stmApi.cmdGID();
    					} else {
    						return Promise.resolve('-');
    					}
    				} else {
    					$$invalidate(0, deviceInfo.family = "IV", deviceInfo);
    					$$invalidate(0, deviceInfo.inp0 = info.inp0, deviceInfo);
    					$$invalidate(0, deviceInfo.inp1 = info.inp1, deviceInfo);
    					$$invalidate(0, deviceInfo.revision = info.revision, deviceInfo);
    					$$invalidate(0, deviceInfo.temperature = info.temperature, deviceInfo);
    					$$invalidate(0, deviceInfo.range_start = info.range_min, deviceInfo);
    					$$invalidate(0, deviceInfo.range_end = info.range_max, deviceInfo);
    					$$invalidate(0, deviceInfo.hue_start = info.hue_start, deviceInfo);
    					$$invalidate(0, deviceInfo.hue_end = info.hue_end, deviceInfo);
    					$$invalidate(0, deviceInfo.c_value = info.c_value, deviceInfo);
    					$$invalidate(0, deviceInfo.saturation = info.saturation, deviceInfo);
    					$$invalidate(0, deviceInfo.backlight_value = info.backlight_value, deviceInfo);
    					$$invalidate(0, deviceInfo.backlight_hue = info.backlight_hue, deviceInfo);
    					$$invalidate(0, deviceInfo.backlight_saturation = info.backlight_saturation, deviceInfo);
    					updateSliders();
    					return Promise.resolve('IV Modbus');
    				}
    			}).catch(err => {
    				log(err);
    				console.log(err);

    				if (err != undefined) {
    					$$invalidate(9, error = err.message);
    				}
    			});
    		}
    	}

    	function onToggleGetData(go) {
    		const dataLabel = document.getElementById("getDataLabel");

    		if (isGetDataActive) {
    			// If it's currently active, change to "Get data"
    			dataLabel.textContent = "Get data";
    		} else {
    			// If it's not active, change to "Stop get data"
    			dataLabel.textContent = "Stop get data";
    		}

    		// Toggle the state for the next click
    		isGetDataActive = !isGetDataActive;
    	}

    	function onToggleSendData(go) {
    		const dataLabel = document.getElementById("sendDataLabel");

    		if (isSendDataActive) {
    			// If it's currently active, change to "Get data"
    			dataLabel.textContent = "Send data";
    		} else {
    			// If it's not active, change to "Stop get data"
    			dataLabel.textContent = "Stop send data";
    		}

    		// Toggle the state for the next click
    		isSendDataActive = !isSendDataActive;
    	}

    	function onFlash(go) {
    		$$invalidate(9, error = null);
    		$$invalidate(26, sending = true);
    		log('Reading content of the file ' + selectedFile.name);

    		tools.readFile(selectedFile).then(async content => {
    			log('Parsing content of the file');
    			const ext = tools.extension(selectedFile.name);
    			let startAddress;
    			let records;

    			if (ext === 's19') {
    				records = tools.parseSRec(true, stmApi.writeBlockSize, content);
    			} else if (ext === 'hex' || ext === 'ihx') {
    				records = tools.parseHex(true, stmApi.writeBlockSize, content);
    			} else if (ext === 'bin') {
    				startAddress = parseInt(settings.startAddress);

    				records = [
    					{
    						type: 'data',
    						data: new Uint8Array(content),
    						address: startAddress
    					}
    				];
    			}

    			for (let i = 0; i < records.length; i++) {
    				let rec = records[i];

    				if (rec.type === 'data') {
    					let before_log = logs;

    					await stmApi.write(rec.data, rec.address, (i, blocksCount) => {
    						$$invalidate(6, logs = before_log + 'Writing block ' + (i + 1) + '/' + blocksCount + '\n');
    					});
    				} else if (rec.type === 'start') {
    					log('Start address detected: 0x' + rec.address.toString(16));
    					startAddress = rec.address;
    				}
    			}

    			if (go) {
    				startAddress = startAddress || parseInt(settings.startAddress);
    				log('Starting code execution');
    				await stmApi.cmdGO(startAddress);
    				stmApi.disconnect();
    				$$invalidate(24, connectionState = DISCONNECTED);
    			}

    			$$invalidate(26, sending = false);
    		}).catch(err => {
    			$$invalidate(26, sending = false);
    			$$invalidate(9, error = err.message);
    		});
    	}

    	function onConnect() {
    		$$invalidate(0, deviceInfo = {
    			family: '-',
    			bl: '-',
    			pid: '-',
    			serial_num: 0,
    			commands: [],
    			temperature: 999,
    			inp0: 0,
    			inp1: 0,
    			source: 0,
    			revision: 999,
    			range_start: 0,
    			range_end: 0,
    			hue_start: 0,
    			hue_end: 0,
    			saturation: 0,
    			c_value: 0,
    			backlight_value: 0,
    			backlight_saturation: 0,
    			backlight_hue: 0
    		});

    		if (connectionState === DISCONNECTED) {
    			$$invalidate(24, connectionState = CONNECTING);
    			$$invalidate(9, error = null);

    			stmApi.connect({
    				replyMode: settings.replyMode,
    				baudrate: settings.baudrate,
    				mcutype: settings.mcuType,
    				modbus: settings._modbus
    			}).then(() => {
    				$$invalidate(24, connectionState = CONNECTED);
    				return stmApi.cmdGET();
    			}).then(info => {
    				$$invalidate(0, deviceInfo.bl = info.blVersion, deviceInfo);
    				$$invalidate(0, deviceInfo.commands = info.commands, deviceInfo);

    				if (!settings._modbus) {
    					$$invalidate(0, deviceInfo.family = info.getFamily(), deviceInfo);

    					if (deviceInfo.family === 'STM32') {
    						//deviceInfo.family = '32-bit'
    						return stmApi.cmdGID();
    					} else {
    						return Promise.resolve('-');
    					}
    				} else {
    					$$invalidate(0, deviceInfo.family = "IV", deviceInfo);
    					$$invalidate(0, deviceInfo.inp0 = info.inp0 / 1000, deviceInfo);
    					$$invalidate(0, deviceInfo.inp1 = info.inp1 / 1000, deviceInfo);
    					$$invalidate(0, deviceInfo.revision = info.revision, deviceInfo);
    					$$invalidate(0, deviceInfo.temperature = info.temperature, deviceInfo);
    					return Promise.resolve('IV Modbus');
    				}
    			}).then(pid => {
    				$$invalidate(0, deviceInfo.pid = pid, deviceInfo);
    				updateCaptions();
    			}).then(() => {
    				return stmApi.cmdREAD(0x1ffff7e8, 12);
    			}).then(data => {
    				$$invalidate(0, deviceInfo.serial_num = "0x" + data.map(byte => byte.toString(16).padStart(2, '0')).join(''), deviceInfo);
    				return Promise.resolve();
    			}).then(() => {
    				if (settings._modbus) {
    					log("Modbus enabled");
    				} else {
    					log("Modbus not enabled");
    				}
    			}).catch(err => {
    				log(err);
    				console.log(err);

    				if (err != undefined) {
    					$$invalidate(9, error = err.message);
    				}

    				$$invalidate(24, connectionState = DISCONNECTED);
    			});
    		} else {
    			stmApi.disconnect().catch(err => {
    				if (err != undefined) {
    					$$invalidate(9, error = err.message);
    				}

    				console.log(err);
    			});
    		}
    	}

    	function onErase() {
    		$$invalidate(9, error = null);
    		$$invalidate(26, sending = true);
    		log('Erasing flash...');

    		stmApi.eraseAll().then(() => {
    			log('Flash erased');
    			$$invalidate(26, sending = false);
    		}).catch(err => {
    			$$invalidate(26, sending = false);
    			$$invalidate(9, error = err.message);
    		});
    	}

    	function onSettings() {
    		$$invalidate(9, error = null);
    		$$invalidate(8, showSettingsDialog = true);
    	}

    	function onStm8Select(event) {
    		let value = event.target.value;
    		$$invalidate(25, stm8selected = value !== '-1');

    		stmApi.setDevice({
    			blVersion: deviceInfo.bl,
    			flash: stm8selected ? value : null
    		});
    	}

    	function updateSliders() {
    		var sliderRangeMin = document.getElementById('sliderRangeMin');
    		var sliderRangeMax = document.getElementById('sliderRangeMax');
    		var sliderHStart = document.getElementById('sliderHStart');
    		var sliderHEnd = document.getElementById('sliderHEnd');
    		var sliderS = document.getElementById('sliderS');
    		var sliderV = document.getElementById('sliderV');
    		var sliderHBl = document.getElementById('sliderHBl');
    		var sliderSBl = document.getElementById('sliderSBl');
    		var sliderVBl = document.getElementById('sliderVBl');
    		updateSliderValue(sliderRangeMin, deviceInfo.range_start);
    		updateSliderValue(sliderRangeMax, deviceInfo.range_end);
    		updateSliderValue(sliderHStart, deviceInfo.hue_start);
    		updateSliderValue(sliderHEnd, deviceInfo.hue_end);
    		updateSliderValue(sliderS, deviceInfo.saturation);
    		updateSliderValue(sliderV, deviceInfo.c_value);
    		updateSliderValue(sliderHBl, deviceInfo.backlight_hue);
    		updateSliderValue(sliderSBl, deviceInfo.backlight_saturation);
    		updateSliderValue(sliderVBl, deviceInfo.backlight_value);
    		updateCaptions();
    	}

    	onMount(() => {
    		// Get the slider and output elements
    		var sliderRangeMin = document.getElementById('sliderRangeMin');

    		var sliderRangeMinOut = document.querySelector('output[for="sliderRangeMin"]');
    		var sliderRangeMax = document.getElementById('sliderRangeMax');
    		var sliderRangeMaxOut = document.querySelector('output[for="sliderRangeMax"]');
    		var sliderHStart = document.getElementById('sliderHStart');
    		var sliderHStartOut = document.querySelector('output[for="sliderHStart"]');
    		var sliderHEnd = document.getElementById('sliderHEnd');
    		var sliderHEndOut = document.querySelector('output[for="sliderHEnd"]');
    		var sliderS = document.getElementById('sliderS');
    		var sliderSOut = document.querySelector('output[for="sliderS"]');
    		var sliderV = document.getElementById('sliderV');
    		var sliderVOut = document.querySelector('output[for="sliderV"]');
    		var sliderHBl = document.getElementById('sliderHBl');
    		var sliderHBlOut = document.querySelector('output[for="sliderHBl"]');
    		var sliderSBl = document.getElementById('sliderSBl');
    		var sliderSBlOut = document.querySelector('output[for="sliderSBl"]');
    		var sliderVBl = document.getElementById('sliderVBl');
    		var sliderVBlOut = document.querySelector('output[for="sliderVBl"]');

    		// Add an event listener to detect changes in the slider value
    		sliderRangeMin.addEventListener('input', function () {
    			// Update the output caption with the current slider value
    			updateSliderOutput(sliderRangeMinOut, sliderRangeMin, "Range Min(V): ");
    		});

    		// Add an event listener to detect changes in the slider value
    		sliderRangeMax.addEventListener('input', function () {
    			// Update the output caption with the current slider value
    			updateSliderOutput(sliderRangeMaxOut, sliderRangeMax, "Range Max(V): ");
    		});

    		// Add an event listener to detect changes in the slider value
    		sliderHStart.addEventListener('input', function () {
    			// Update the output caption with the current slider value
    			updateSliderOutput(sliderHStartOut, sliderHStart, "Hue Start: ");
    		});

    		// Add an event listener to detect changes in the slider value
    		sliderHEnd.addEventListener('input', function () {
    			// Update the output caption with the current slider value
    			updateSliderOutput(sliderHEndOut, sliderHEnd, "Hue End: ");
    		});

    		// Add an event listener to detect changes in the slider value
    		sliderS.addEventListener('input', function () {
    			// Update the output caption with the current slider value
    			updateSliderOutput(sliderSOut, sliderS, "C.Sat: ");
    		});

    		// Add an event listener to detect changes in the slider value
    		sliderV.addEventListener('input', function () {
    			// Update the output caption with the current slider value
    			updateSliderOutput(sliderVOut, sliderV, "C.Val: ");
    		});

    		// Add an event listener to detect changes in the slider value
    		sliderHBl.addEventListener('input', function () {
    			// Update the output caption with the current slider value
    			updateSliderOutput(sliderHBlOut, sliderHBl, "Bl.C.Hue: ");
    		});

    		// Add an event listener to detect changes in the slider value
    		sliderSBl.addEventListener('input', function () {
    			// Update the output caption with the current slider value
    			updateSliderOutput(sliderSBlOut, sliderSBl, "Bl.C.Sat: ");
    		});

    		// Add an event listener to detect changes in the slider value
    		sliderVBl.addEventListener('input', function () {
    			// Update the output caption with the current slider value
    			updateSliderOutput(sliderVBlOut, sliderVBl, "Bl.C.Val: ");
    		});

    		updateCaptions();
    		setInterval(modbusGetDataTimer, 1000);
    		setInterval(modbusSetParameters, 500);
    	});

    	const click_handler = () => onFlash(false);
    	const click_handler_1 = () => onFlash(true);
    	const click_handler_2 = () => onToggleGetData();
    	const click_handler_3 = () => onToggleSendData();

    	function select0_change_handler() {
    		settings.mcutype = select_value(this);
    		$$invalidate(2, settings);
    	}

    	const close_handler = () => $$invalidate(7, showPortDialog = false);
    	const close_handler_1 = () => $$invalidate(8, showSettingsDialog = false);

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*connectionState*/ 16777216) {
    			$$invalidate(1, isConnected = connectionState === CONNECTED);
    		}

    		if ($$self.$$.dirty[0] & /*connectionState*/ 16777216) {
    			$$invalidate(12, isConnecting = connectionState === CONNECTING);
    		}

    		if ($$self.$$.dirty[0] & /*connectionState*/ 16777216) {
    			$$invalidate(11, isDisconnected = connectionState === DISCONNECTED);
    		}

    		if ($$self.$$.dirty[0] & /*isConnected, sending, deviceInfo, stm8selected*/ 100663299) {
    			$$invalidate(10, cmdsAllowed = isConnected && !sending && (deviceInfo.family === 'STM32' || deviceInfo.family === 'STM8' && stm8selected));
    		}
    	};

    	return [
    		deviceInfo,
    		isConnected,
    		settings,
    		burgerActive,
    		selectedFile,
    		selectedPort,
    		logs,
    		showPortDialog,
    		showSettingsDialog,
    		error,
    		cmdsAllowed,
    		isDisconnected,
    		isConnecting,
    		onSelectPort,
    		onBurgerClick,
    		onPortSelected,
    		onOpenFile,
    		onToggleGetData,
    		onToggleSendData,
    		onFlash,
    		onConnect,
    		onErase,
    		onSettings,
    		onStm8Select,
    		connectionState,
    		stm8selected,
    		sending,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		select0_change_handler,
    		close_handler,
    		close_handler_1
    	];
    }

    class App extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance, create_fragment, safe_not_equal, {}, null, [-1, -1]);
    	}
    }

    const app = new App({
    	target: document.body
    });

    return app;

})();
