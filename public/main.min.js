var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
        return style.sheet;
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.wholeText !== data)
            text.data = data;
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            managed_styles.forEach(info => {
                const { ownerNode } = info.stylesheet;
                // there is no ownerNode if it runs on jsdom.
                if (ownerNode)
                    detach(ownerNode);
            });
            managed_styles.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    const REPLY_MODE = 'reply_mode';
    const BAUDRATE = 'baudrate';
    const START_ADDRESS = 'start_address';

    class Settings {
        constructor() {
            this._replyMode = localStorage.getItem(REPLY_MODE) === "true" || false;
            this._baudrate = localStorage.getItem(BAUDRATE) || "9600";
            this._startAddress = localStorage.getItem(START_ADDRESS) || "0x8000000";
        }

        set replyMode(reply) {
            this._replyMode = reply;
            this.commit();
        }

        get replyMode() {
            return this._replyMode;
        }

        set baudrate(baudrate) {
            this._baudrate = baudrate;
            this.commit();
        }

        get baudrate() {
            return this._baudrate;
        }

        get startAddress() {
            return this._startAddress;
        }

        set startAddress(address) {
            this._startAddress = address;
            this.commit();
        }

        commit() {
            localStorage.setItem(REPLY_MODE, this._replyMode);
            localStorage.setItem(BAUDRATE, this._baudrate);
            localStorage.setItem(START_ADDRESS, this._startAddress);
        }
    }

    const settings = new Settings();

    class Logger {
        constructor() {
            this.allLogger = [];
        }

        registerLogger(logger) {
            this.allLogger.push(logger);
        }

        log(...args) {
            this.allLogger.forEach((logger) => {
                logger.log.apply(null, args);
            });
        }
    }

    const logger = new Logger();

    /* src\PortDialog.svelte generated by Svelte v3.50.1 */

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (54:12) {#each devices as dev, i}
    function create_each_block(ctx) {
    	let div5;
    	let div4;
    	let div3;
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let span1;
    	let t1_value = /*dev*/ ctx[9] + "";
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[5](/*i*/ ctx[11]);
    	}

    	return {
    		c() {
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.innerHTML = `<span class="icon"><i class="fa fa-plug"></i></span>`;
    			t0 = space();
    			div1 = element("div");
    			span1 = element("span");
    			t1 = text(t1_value);
    			attr(div0, "class", "level-item");
    			attr(div1, "class", "level-item");
    			attr(div2, "class", "level-left");
    			attr(div3, "class", "level");
    			attr(div4, "class", "card-content");
    			attr(div5, "class", "card");
    			attr(div5, "tabindex", /*i*/ ctx[11]);
    		},
    		m(target, anchor) {
    			insert(target, div5, anchor);
    			append(div5, div4);
    			append(div4, div3);
    			append(div3, div2);
    			append(div2, div0);
    			append(div2, t0);
    			append(div2, div1);
    			append(div1, span1);
    			append(span1, t1);

    			if (!mounted) {
    				dispose = listen(div5, "click", click_handler);
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*devices*/ 1 && t1_value !== (t1_value = /*dev*/ ctx[9] + "")) set_data(t1, t1_value);
    		},
    		d(detaching) {
    			if (detaching) detach(div5);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (71:12) {#if ports.length === 0}
    function create_if_block$1(ctx) {
    	let div2;

    	return {
    		c() {
    			div2 = element("div");
    			div2.innerHTML = `<div class="card-content"><div>No paired ports detected</div></div>`;
    			attr(div2, "class", "card");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    		}
    	};
    }

    function create_fragment$3(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let header;
    	let p;
    	let t2;
    	let button0;
    	let t3;
    	let section;
    	let t4;
    	let t5;
    	let footer;
    	let button1;
    	let mounted;
    	let dispose;
    	let each_value = /*devices*/ ctx[0];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	let if_block = /*ports*/ ctx[1].length === 0 && create_if_block$1();

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			header = element("header");
    			p = element("p");
    			p.textContent = "Paired Ports";
    			t2 = space();
    			button0 = element("button");
    			t3 = space();
    			section = element("section");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			if (if_block) if_block.c();
    			t5 = space();
    			footer = element("footer");
    			button1 = element("button");
    			button1.textContent = "Pair new\r\n                port";
    			attr(div0, "class", "modal-background");
    			attr(p, "class", "modal-card-title");
    			attr(button0, "class", "delete");
    			attr(button0, "aria-label", "close");
    			attr(header, "class", "modal-card-head");
    			attr(section, "class", "modal-card-body is-paddingless");
    			attr(button1, "class", "button is-success");
    			attr(footer, "class", "modal-card-foot");
    			attr(div1, "class", "modal-card");
    			attr(div2, "class", "modal is-active svelte-1njnz7e");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			append(div2, t0);
    			append(div2, div1);
    			append(div1, header);
    			append(header, p);
    			append(header, t2);
    			append(header, button0);
    			append(div1, t3);
    			append(div1, section);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(section, null);
    			}

    			append(section, t4);
    			if (if_block) if_block.m(section, null);
    			append(div1, t5);
    			append(div1, footer);
    			append(footer, button1);

    			if (!mounted) {
    				dispose = [
    					listen(button0, "click", /*onOkClick*/ ctx[2]),
    					listen(button1, "click", /*onDetectNew*/ ctx[4])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*onPortSelected, devices*/ 9) {
    				each_value = /*devices*/ ctx[0];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(section, t4);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*ports*/ ctx[1].length === 0) {
    				if (if_block) ; else {
    					if_block = create_if_block$1();
    					if_block.c();
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div2);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$2($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	const close = () => dispatch('close');
    	let devices = [];
    	let ports = [];

    	async function getPaired() {
    		$$invalidate(1, ports = await navigator.serial.getPorts());

    		$$invalidate(0, devices = ports.map(port => {
    			let info = port.getInfo();
    			let name = 'Serial Port';

    			if (info.usbProductId && info.usbVendorId) {
    				name += ' (usb:0x' + info.usbVendorId.toString(16) + ':0x' + info.usbProductId.toString(16) + ')';
    			}

    			port.name = 'Serial Port';
    			return name;
    		}));
    	}

    	function onOkClick() {
    		close();
    	}

    	function onPortSelected(index) {
    		dispatch('selected_port', ports[index]);
    		close();
    	}

    	function onDetectNew() {
    		navigator.serial.requestPort().then(getPaired);
    	}

    	onMount(getPaired);
    	const click_handler = i => onPortSelected(i);
    	return [devices, ports, onOkClick, onPortSelected, onDetectNew, click_handler];
    }

    class PortDialog extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$2, create_fragment$3, safe_not_equal, {});
    	}
    }

    /* src\SettingsDialog.svelte generated by Svelte v3.50.1 */

    function create_fragment$2(ctx) {
    	let div11;
    	let div0;
    	let t0;
    	let div10;
    	let header;
    	let p0;
    	let t2;
    	let button;
    	let t3;
    	let section;
    	let div3;
    	let label0;
    	let t5;
    	let div2;
    	let div1;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let option6;
    	let t13;
    	let div5;
    	let label1;
    	let t15;
    	let div4;
    	let input0;
    	let t16;
    	let p1;
    	let t18;
    	let div9;
    	let div6;
    	let label2;
    	let input1;
    	let t19;
    	let t20;
    	let div8;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			div11 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div10 = element("div");
    			header = element("header");
    			p0 = element("p");
    			p0.textContent = "Settings";
    			t2 = space();
    			button = element("button");
    			t3 = space();
    			section = element("section");
    			div3 = element("div");
    			label0 = element("label");
    			label0.textContent = "Baud rate:";
    			t5 = space();
    			div2 = element("div");
    			div1 = element("div");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "4800";
    			option1 = element("option");
    			option1.textContent = "9600";
    			option2 = element("option");
    			option2.textContent = "19200";
    			option3 = element("option");
    			option3.textContent = "38400";
    			option4 = element("option");
    			option4.textContent = "57600";
    			option5 = element("option");
    			option5.textContent = "115200";
    			option6 = element("option");
    			option6.textContent = "250000";
    			t13 = space();
    			div5 = element("div");
    			label1 = element("label");
    			label1.textContent = "Address in flash for\r\n                    code:";
    			t15 = space();
    			div4 = element("div");
    			input0 = element("input");
    			t16 = space();
    			p1 = element("p");
    			p1.textContent = "If the selected file does not provide the starting address,\r\n                    this address will be used to write the code at. In most\r\n                    cases this is the starting address of the flash memory\r\n                    (STM32: 0x8000000 and STM8: 0x8000).";
    			t18 = space();
    			div9 = element("div");
    			div6 = element("div");
    			label2 = element("label");
    			input1 = element("input");
    			t19 = text(" Use Reply mode (STM8)");
    			t20 = space();
    			div8 = element("div");

    			div8.innerHTML = `<div>Some STM8 device interfaces require &quot;reply&quot; mode for
                        serial communication. See UM0560 for details. Uncheck
                        for STM32.</div>`;

    			attr(div0, "class", "modal-background");
    			attr(p0, "class", "modal-card-title");
    			attr(button, "class", "delete");
    			attr(button, "aria-label", "close");
    			attr(header, "class", "modal-card-head");
    			attr(label0, "class", "label");
    			attr(label0, "for", "baudList");
    			option0.__value = "4800";
    			option0.value = option0.__value;
    			option1.__value = "9600";
    			option1.value = option1.__value;
    			option2.__value = "19200";
    			option2.value = option2.__value;
    			option3.__value = "38400";
    			option3.value = option3.__value;
    			option4.__value = "57600";
    			option4.value = option4.__value;
    			option5.__value = "115200";
    			option5.value = option5.__value;
    			option6.__value = "250000";
    			option6.value = option6.__value;
    			attr(select, "id", "baudList");
    			if (/*settings*/ ctx[0].baudrate === void 0) add_render_callback(() => /*select_change_handler*/ ctx[2].call(select));
    			attr(div1, "class", "select");
    			attr(div2, "class", "control");
    			attr(div3, "class", "field");
    			attr(label1, "class", "label");
    			attr(label1, "for", "startingAddress");
    			attr(input0, "id", "startingAddress");
    			attr(input0, "class", "input");
    			attr(input0, "type", "text");
    			attr(input0, "placeholder", "Start address in flash");
    			attr(div4, "class", "control");
    			attr(p1, "class", "help");
    			attr(div5, "class", "field");
    			attr(input1, "type", "checkbox");
    			attr(label2, "class", "checkbox");
    			attr(div6, "class", "control");
    			attr(div8, "class", "help");
    			attr(div9, "class", "field");
    			attr(section, "class", "modal-card-body");
    			attr(div10, "class", "modal-card");
    			attr(div11, "class", "modal is-active");
    		},
    		m(target, anchor) {
    			insert(target, div11, anchor);
    			append(div11, div0);
    			append(div11, t0);
    			append(div11, div10);
    			append(div10, header);
    			append(header, p0);
    			append(header, t2);
    			append(header, button);
    			append(div10, t3);
    			append(div10, section);
    			append(section, div3);
    			append(div3, label0);
    			append(div3, t5);
    			append(div3, div2);
    			append(div2, div1);
    			append(div1, select);
    			append(select, option0);
    			append(select, option1);
    			append(select, option2);
    			append(select, option3);
    			append(select, option4);
    			append(select, option5);
    			append(select, option6);
    			select_option(select, /*settings*/ ctx[0].baudrate);
    			append(section, t13);
    			append(section, div5);
    			append(div5, label1);
    			append(div5, t15);
    			append(div5, div4);
    			append(div4, input0);
    			set_input_value(input0, /*settings*/ ctx[0].startAddress);
    			append(div5, t16);
    			append(div5, p1);
    			append(section, t18);
    			append(section, div9);
    			append(div9, div6);
    			append(div6, label2);
    			append(label2, input1);
    			input1.checked = /*settings*/ ctx[0].replyMode;
    			append(label2, t19);
    			append(div9, t20);
    			append(div9, div8);

    			if (!mounted) {
    				dispose = [
    					listen(button, "click", /*onOkClick*/ ctx[1]),
    					listen(select, "change", /*select_change_handler*/ ctx[2]),
    					listen(input0, "input", /*input0_input_handler*/ ctx[3]),
    					listen(input1, "change", /*input1_change_handler*/ ctx[4])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*settings*/ 1) {
    				select_option(select, /*settings*/ ctx[0].baudrate);
    			}

    			if (dirty & /*settings*/ 1 && input0.value !== /*settings*/ ctx[0].startAddress) {
    				set_input_value(input0, /*settings*/ ctx[0].startAddress);
    			}

    			if (dirty & /*settings*/ 1) {
    				input1.checked = /*settings*/ ctx[0].replyMode;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div11);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$1($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	const close = () => dispatch('close');

    	function onOkClick() {
    		close();
    	}

    	function select_change_handler() {
    		settings.baudrate = select_value(this);
    		$$invalidate(0, settings);
    	}

    	function input0_input_handler() {
    		settings.startAddress = this.value;
    		$$invalidate(0, settings);
    	}

    	function input1_change_handler() {
    		settings.replyMode = this.checked;
    		$$invalidate(0, settings);
    	}

    	return [
    		settings,
    		onOkClick,
    		select_change_handler,
    		input0_input_handler,
    		input1_change_handler
    	];
    }

    class SettingsDialog extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1, create_fragment$2, safe_not_equal, {});
    	}
    }

    /* src\NotSupportedDialog.svelte generated by Svelte v3.50.1 */

    function create_fragment$1(ctx) {
    	let div2;

    	return {
    		c() {
    			div2 = element("div");

    			div2.innerHTML = `<div class="modal-background"></div> 
    <div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Browser not supported</p></header> 
        <section class="modal-card-body"><p>Your browser does not support Web Serial API. Check the <a href="https://github.com/Gamadril/stm-serial-flasher">documentation</a> for more info.</p></section></div>`;

    			attr(div2, "class", "modal is-active svelte-1njnz7e");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div2);
    		}
    	};
    }

    class NotSupportedDialog extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, null, create_fragment$1, safe_not_equal, {});
    	}
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    class Serial {
        constructor() {
            this.init();
        }

        init() {
        }

        /**
         * Check if a connection is opened.
         */
        isOpen() {
            return false;
        }

        /**
         * Open the serial port
         * @param {Object} port Port object
         */
        open(port) {
        }

        /**
         * Close the current connection
         */
        close() {
        }

        /**
         * Read data from the serial port
         */
        read() {
        }

        /**
         * Writes data to serial port
         * @param {Uint8Array} data Data to send.
         */
        write(data) {
        }

        /**
         * Set the control signals of the current connection
         * @param {dtr:boolean, rts:boolean} lineParams signal parameters
         */
        control(lineParams) {
        }

        onConnect() {       
        }

        onDisconnect() {
        }
    }

    function info(msg) {
        console.info('[WebSerial] ' + msg);
    }

    class WebSerial extends Serial {
        constructor(port) {
            super();
            if (!(port instanceof SerialPort)) {
                throw new Error('Expected a SerialPort object');
            }
            this._port = port;
            this._reader = null;
            this._writer = null;
        }

        init() {
            navigator.serial.onconnect = this.onConnect.bind(this);
            navigator.serial.ondisconnect = this.onDisconnect.bind(this);
        }

        /**
         * Check if a connection is opened.
         */
        isOpen() {
            return this._writer !== null;
        }

        /**
         * Open the serial port
         * @param {Object} parameter Parameter
         */
        open(parameter) {
            return new Promise((resolve, reject) => {
                info('-> open ' + JSON.stringify(parameter));
                this._port.open(parameter)
                    .then(() => {
                        this._reader = this._port.readable.getReader();
                        this._writer = this._port.writable.getWriter();
                        info('<- open');
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Close the current connection
         */
        close() {
            return new Promise((resolve, reject) => {
                info('-> close');
                this._reader.cancel();
                this._writer.close();
                Promise.all([this._reader.closed, this._writer.closed])
                    .then(() => this._port.close())
                    .then(() => {
                        this._reader = null;
                        this._writer = null;
                        info('<- close');
                        this.onDisconnect();
                        resolve();
                    })
                    .catch((err) => {
                        this._reader = null;
                        this._writer = null;
                        info('<- close reject');
                        reject(err);
                    });
            });
        }

        /**
         * Read data from the serial port
         */
        read() {
            return new Promise(async (resolve, reject) => {
                info('-> read');

                this._reader.read()
                    .then((result) => {
                        console.debug(result);
                        resolve(result.value);
                    })
                    .catch(reject);
            });
        }

        /**
         * Writes data to serial port
         * @param {Uint8Array} data Data to send.
         */
        write(data) {
            return new Promise((resolve, reject) => {
                info('-> write');
                console.debug(data);
                this._writer.write(data.buffer)
                    .then(resolve)
                    .catch(reject);
            });
        }

        /**
         * Set the control signals of the current connection
         * @param {dtr:boolean, rts:boolean} lineParams signal parameters
         */
        control(lineParams) {
            return new Promise((resolve, reject) => {
                info('-> control');
                console.debug(lineParams);
                this._port.setSignals(lineParams)
                    .then(() => {
                        resolve();
                    })
                    .catch(reject);
            });
        }
    }

    const tools = {
        /**
         * Parses the content of a s19 file
         * @param {boolean} combine Set to true to combine the data into packages
         * @param {number} blockSize Size of the block to combine data to
         * @param {string} fileContent Content of the s19 file
         * @returns {Array} Array of single records
         * @throws Error
         */
        parseSRec: function (combine, blockSize, fileContent) {
            var lines, i, line, record, checksum, records = [], type, addrLength;

            lines = fileContent.split("\n");
            for (i = 0; i < lines.length; i++) {
                line = lines[i];

                if (line.length === 0) { // skip empty lines
                    continue;
                } else if (line.charAt(0) !== 'S') {
                    throw new Error('Invalid SRecord file format')
                }

                record = {};
                type = parseInt(line.substr(1, 1), 10);
                record.type = null;
                if (type === 1) {
                    addrLength = 4;
                    record.type = 'data';
                } else if (type === 3) {
                    addrLength = 8;
                    record.type = 'data';
                } else if (type === 9) {
                    addrLength = 4;
                    record.type = 'start';
                } else if (type === 7) {
                    addrLength = 8;
                    record.type = 'start';
                } else {
                    continue;
                }
                record.length = parseInt(line.substr(2, 2), 16);
                record.address = parseInt(line.substr(4, addrLength), 16);
                record.data = this.hexstr2uintarray(line.substr(4 + addrLength, (record.length - 3) * 2));
                record.checksum = parseInt(line.substr(-2), 16);

                checksum = (this.sum(this.hexstr2uintarray(line.substring(2, line.length - 2))) & 0xFF) ^ 0xFF;

                if (checksum !== record.checksum) {
                    throw new Error('Checksum in line ' + (i + 1) + ' does not match');
                }

                records.push(record);
            }

            if (combine) {
                records = this.packRecords(records, blockSize);
            }

            return records;
        },

        /**
         * Parses the content of a hex file
         * @param {boolean} combine Set to true to combine the data into packages
         * @param {number} blockSize Size of the block to combine data to
         * @param {string} fileContent Content of the hex file
         * @returns {Array} Array of single records
         * @throws Error
         */
        parseHex: function (combine, blockSize, fileContent) {
            var lines, i, line, record, checksum, records = [], type, base = 0;

            lines = fileContent.split("\n");
            for (i = 0; i < lines.length; i++) {
                line = lines[i];

                if (line.length === 0) { // skip empty lines
                    continue;
                } else if (line.charAt(0) !== ':') {
                    throw new Error('Invalid HEX file format');
                }

                record = {};
                type = parseInt(line.substr(7, 2), 16);
                record.length = parseInt(line.substr(1, 2), 16);
                record.address = parseInt(line.substr(3, 4), 16);
                if (base > 0) {
                    record.address += base;
                }

                record.data = this.hexstr2uintarray(line.substr(9, record.length * 2));
                record.checksum = parseInt(line.substr(-2), 16);

                checksum = this.sum(this.hexstr2uintarray(line.substr(1))) % 256;

                if (checksum !== 0) {
                    throw new Error('Checksum in line ' + (i + 1) + ' does not match');
                }

                record.type = null;
                if (type === 0) {
                    record.type = 'data';
                    records.push(record);
                } else if (type === 4) {
                    base = record.data[0] << 24;
                    base += record.data[1] << 16;
                } else if (type === 5) {
                    record.type = 'start';
                    record.address = parseInt(line.substr(9, record.length * 2), 16);
                    records.push(record);
                }
            }

            if (combine) {
                records = this.packRecords(records, blockSize);
            }

            return records;
        },

        /**
         * Parses the content of a bin file. Actually splits binary data into records
         * @param {number} blockSize Size of the block to split data into
         * @param {ArrayBuffer} fileContent Content of the bin file
         * @returns {Array} Array of single records
         * @throws Error
         */
        parseBin: function (blockSize, fileContent) {
            let records = [];
            let nrRecords = Math.ceil(fileContent.byteLength / blockSize);

            for (let i = 0; i < nrRecords; i++) {
                let start = i * blockSize;
                let end = start + blockSize;
                let chunk = new Uint8Array(fileContent.slice(start, end));
                let record = {
                    data: chunk,
                    type: 'data'
                };
                records.push(record);
            }
            return records;
        },

        /**
         * @private
         * @param {Array} records Array of records to combine
         * @param {number} blockSize Size of the block to combine data to
         * @returns {Array} New recombined records
         */
        packRecords: function (records, blockSize) {
            var record, newRecord, result = [], startAddress, offset = 0, dataBuffer;

            var minAddress = function (records) {
                var record, i, result = -1;

                for (i = 0; i < records.length; i++) {
                    record = records[i];

                    if (result === -1 || result > record.address) {
                        result = record.address;
                    }
                }

                return result;
            };

            var findRecord = function (address) {
                var i;

                for (i = 0; i < records.length; i++) {
                    if (records[i].address === address && records[i].type === 'data') {
                        return records[i];
                    }
                }

                return null;
            };

            var findStartRecord = function () {
                var i;

                for (i = 0; i < records.length; i++) {
                    if (records[i].type === 'start') {
                        return records[i];
                    }
                }

                return null;
            };

            while (true) {
                newRecord = {
                    type: 'data'
                };

                record = findStartRecord();
                if (record) {
                    result.push(record);
                    records.splice(records.indexOf(record), 1);
                    continue;
                }

                startAddress = minAddress(records);

                if (startAddress === -1) {
                    break;
                }

                newRecord.address = startAddress;
                dataBuffer = new Uint8Array(blockSize);

                while ((record = findRecord(startAddress + offset)) !== null) {
                    if (offset + record.data.length > blockSize) {
                        break;
                    } else {
                        dataBuffer.set(record.data, offset);
                        records.splice(records.indexOf(record), 1);
                        offset += record.data.length;
                    }
                }

                if (offset < blockSize) {
                    dataBuffer = dataBuffer.subarray(0, offset);
                }

                offset = 0;
                newRecord.data = dataBuffer;

                result.push(newRecord);
            }

            return result;
        },

        /**
         * Returns the number of data records
         * @param {Array} records Array of records
         * @returns {number} Number of daa records
         */
        countData: function (records) {
            var i, result = 0;
            for (i = 0; i < records.length; i++) {
                if (records[i].type === 'data') {
                    result++;
                }
            }
            return result;
        },

        /**
         * Extracts the extension of a filename
         * @param {string} fileName Name of the file
         * @returns {string} Extension or null if file has no extension
         */
        extension: function (fileName) {
            var result = null, dotIndex = fileName.lastIndexOf('.');

            if (dotIndex !== -1) {
                result = fileName.substr(dotIndex + 1);
            }

            return result;
        },

        /**
         * Calculate the sum of bytes in the array
         * @private
         * @param {Uint8Array} array Array
         * @returns {number} Sum of all values in the array
         */
        sum: function (array) {
            return array.reduce((a, b) => a + b, 0);
        },

        /**
         * Convert a HEX string to Uint8Array
         * @private
         * @param {string} str String
         * @returns {Uint8Array} Result
         */
        hexstr2uintarray: function (str) {
            var result = new Uint8Array(str.length / 2);
            for (var i = 0; i < str.length / 2; i++) {
                result[i] = parseInt(str.substr(i * 2, 2), 16);
            }
            return result;
        },

        /**
         * Convert a string to ArrayBuffer
         * @private
         * @param {string} str String to convert
         * @returns {ArrayBuffer} Result
         */
        str2ab: function (str) {
            var buf = new ArrayBuffer(str.length);
            var bufView = new Uint8Array(buf);
            for (var i = 0; i < str.length; i++) {
                bufView[i] = str.charCodeAt(i);
            }
            return buf;
        },

        /**
         * Convert an array to ArrayBuffer
         * @private
         * @param array
         * @returns {ArrayBuffer} Result
         */
        a2ab: function (array) {
            var buf = new ArrayBuffer(array.length);
            var bufView = new Uint8Array(buf);
            for (var i = 0; i < array.length; i++) {
                bufView[i] = array[i];
            }
            return buf;
        },

        /**
         * Convert ArrayBuffer to array
         * @private
         * @param buffer
         * @returns {Uint8Array}
         */
        ab2a: function (buffer) {
            return new Uint8Array(buffer);
        },

        /**
         * Convert ArrayBuffer to string
         * @private
         * @param {ArrayBuffer} buffer Buffer to convert
         * @returns {string}
         */
        ab2hexstr: function (buffer) {
            var ua = new Uint8Array(buffer);
            var str = "";
            for (var i = 0; i < ua.length; i++) {
                str += this.b2hexstr(ua[i]);
            }
            return str;
        },

        /**
         * Convert byte to hexstr.
         * @param {number} byte Byte to convert
         */
        b2hexstr: function (byte) {
            return ("00" + byte.toString(16)).substr(-2);
        },

        /**
         * @private
         * @param buffer
         * @returns {string}
         */
        ab2str: function (buffer) {
            return String.fromCharCode.apply(null, new Uint8Array(buffer));
        },

        /**
         * @private
         * @param number
         * @param arraySize
         * @returns {Array}
         */
        num2a: function (number, arraySize) {
            var i, temp = number, result = [];

            for (i = 0; i < arraySize; i++) {
                result.unshift(temp & 0xFF);
                temp = temp >> 8;
            }

            return result;
        },

        /**
         * Convert an Uint8Array to array
         * @private
         * @param uiArray
         * @returns {Array}
         */
        uia2a: function (uiArray) {
            var i, result = [];

            for (i = 0; i < uiArray.length; i++) {
                result.push(uiArray[i]);
            }

            return result;
        },

        /**
         * Read the content of the file as text
         * @param {File} file 
         */
        readFile(file) {
            return new Promise((resolve, reject) => {
                let reader = new FileReader();
                reader.onload = () => {
                    resolve(reader.result);
                };
                reader.onerror = () => {
                    reject(reader.error);
                };
                if (file.name.endsWith('.bin')) {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file);
                }
            });
        }
    };

    const MAX_WRITE_BLOCK_SIZE_STM32 = 256;
    const MAX_READ_BLOCK_SIZE = 256;
    const MAX_WRITE_BLOCK_SIZE_STM8 = 128;

    // use control signals to trigger bootloader activation and device hardware reset
    // false = pin hight, true = pin low
    const RTS_PIN = "requestToSend";
    const DTR_PIN = "dataTerminalReady"; // STM32
    const PIN_HIGH = false;
    const PIN_LOW = true;

    const SYNCHR = 0x7F;
    const ACK = 0x79;

    const CMD_GET = 0x00;
    const CMD_GV = 0x01;
    // GET ID command used to identify the STM family. If it's present it's STM32, STM8 otherwise
    const CMD_GID = 0x02;
    const CMD_READ = 0x11;
    const CMD_GO = 0x21;
    const CMD_WRITE = 0x31;
    const CMD_ERASE = 0x43;
    const CMD_EXTENDED_ERASE = 0x44;
    const CMD_WPUN = 0x73;
    const CMD_RDU_PRM = 0x92;

    // Address for erase_write_routines for STM8 S/A
    const STM8_WRITE_CODE_ADDRESS = 0xA0;

    const EwrLoadState = Object.freeze({
        NOT_LOADED: Symbol("not_loaded"),
        LOADING: Symbol("loading"),
        LOADED: Symbol("loaded")
    });

    function u8a(array) {
        return new Uint8Array(array);
    }

    class InfoGV {
        constructor() {
            // Bootloader version
            this.blVersion = null;
            // Number of times the read protection was disabled
            this.countRPdisabled = -1;
            // Number of times the read protection was enabled
            this.countRPenabled = -1;
        }
    }

    class InfoGET {
        constructor() {
            // Bootloader version
            this.blVersion = null;
            // List of supported commands
            this.commands = [];
        }

        getFamily() {
            return this.commands.indexOf(CMD_GID) === -1 ? 'STM8' : 'STM32';
        }
    }

    class STMApi {
        constructor(serial) {
            if (!serial) {
                throw new Error('Serial port object not provided');
            }
            this.serial = serial;
            // reply mode which is necessary for some STM8 MCUs
            this.replyMode = false;
            // Indicates if the STM8 erase_write_routines are already loaded
            this.ewrLoadState = EwrLoadState.NOT_LOADED;
            // max: STM8 = 128, STM32 = 256. must be mutliple of 4
            this.writeBlockSize = MAX_WRITE_BLOCK_SIZE_STM8;
            this.readBlockSize = MAX_READ_BLOCK_SIZE;
            // list of supported commands by the target
            this.commands = [];
            // name of the stm8 routines file
            this.stm8RoutinesFile = null;
        }

        /**
         * Initializes erase_write_routines for STM8 S/A
         * @param {flash:"0"|"32"|"128"|"256", blVersion:string} device Flash size of the target MCU
         */
        setDevice(device) {
            this.ewrLoadState = EwrLoadState.NOT_LOADED;

            if (!device.blVersion || !device.flash) {
                return;
            }

            if (device.flash === '0') { // STM8 L
                this.ewrLoadState = EwrLoadState.LOADED;
                return;
            } else if (device.flash !== '32' && device.flash !== '128' && device.flash !== '256') {
                throw new Error('Unsupported device selected: ' + device);
            }

            this.stm8RoutinesFile = 'res/stm8_routines/E_W_ROUTINEs_' + device.flash + 'K_ver_' + device.blVersion + '.bin';
        }

        /**
         * Connect to the target by resetting it and activating the ROM bootloader
         * @param {object} params
         * @returns {Promise}
         */
        async connect(params) {
            this.ewrLoadState = EwrLoadState.NOT_LOADED;
            return new Promise((resolve, reject) => {
                logger.log('Connecting with baudrate ' + params.baudrate + ' and reply mode ' + (params.replyMode ? 'on' : 'off'));
                if (this.serial.isOpen()) {
                    reject(new Error('Port already opened'));
                    return;
                }

                this.replyMode = params.replyMode || false;

                this.serial.open({
                    baudRate: parseInt(params.baudrate, 10),
                    parity: this.replyMode ? 'none' : 'even'
                })
                    .then(() => {
                        // set init state of the NRST pin to high
                        // for stm32 set the BOOT0 pin to low.
                        let signal = {};
                        signal[RTS_PIN] = PIN_HIGH;
                        signal[DTR_PIN] = PIN_HIGH;
                        return this.serial.control(signal);
                    })
                    .then(() => this.activateBootloader())
                    .then(resolve)
                    .catch(reject);
            });
        }

        /**
         * Close current connection. Before closing serial connection disable bootloader and reset target
         * @returns {Promise}
         */
        async disconnect() {
            return new Promise((resolve, reject) => {
                let signal = {};
                signal[DTR_PIN] = PIN_HIGH;
                signal[RTS_PIN] = PIN_HIGH;
                this.serial.control(signal)
                    .then(() => this.resetTarget())
                    .then(() => this.serial.close())
                    .then(resolve)
                    .catch(reject);
            });

        }

        /**
         * Write data to memory. If the data exceeds the max frame size it will be splitted and sent in chunks automatically
         * @param {Uint8Array} data Data to write
         * @param {number} address Address to write at
         * @param {Function} onProgress Callback to notify progress
         * @returns {Promise}
         */
        async write(data, address, onProgress) {
            return new Promise(async (resolve, reject) => {
                logger.log('Writing ' + data.length + ' bytes to flash at address 0x' + address.toString(16) + ' using ' + this.writeBlockSize + ' bytes chunks');
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                let blocksCount = Math.ceil(data.byteLength / this.writeBlockSize);

                let offset = 0;
                let blocks = [];
                for (let i = 0; i < blocksCount; i++) {
                    let block = {};

                    if (i < blocksCount - 1) {
                        block.data = data.subarray(offset, offset + this.writeBlockSize);
                    } else {
                        block.data = data.subarray(offset);
                    }
                    offset += block.data.length;
                    blocks.push(block);
                }

                for (let i = 0; i < blocks.length; i++) {
                    let block = blocks[i];
                    try {
                        //logger.log('Writing block ' + (i + 1) + '/' + blocksCount);
                        if (onProgress) {
                            onProgress(i, blocksCount);
                        }
                        await this.cmdWRITE(block.data, address + i * this.writeBlockSize);
                    } catch (e) {
                        reject(e);
                        return;
                    }
                }
                logger.log('Finished writing');
                resolve();
            });
        }

        /**
         * Do a full erase of the flash
         * @returns {Promise}
         */
        async eraseAll() {
            return new Promise(async (resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (this.ewrLoadState == EwrLoadState.NOT_LOADED) {
                    try {
                        await this.sendEWR();
                    } catch (e) {
                        reject(e);
                        return;
                    }
                }

                let eraseCmd, eraseFlash;
                if (this.commands.indexOf(CMD_ERASE) !== -1) {
                    eraseCmd = [CMD_ERASE, 0xFF ^ CMD_ERASE];
                    eraseFlash = [0xFF, 0x00];
                } else if (this.commands.indexOf(CMD_EXTENDED_ERASE) !== -1) {
                    eraseCmd = [CMD_EXTENDED_ERASE, 0xFF ^ CMD_EXTENDED_ERASE];
                    eraseFlash = [0xFF, 0xFF, 0x00];
                } else {
                    reject(new Error('No erase command found'));
                    return;
                }

                this.serial.write(u8a(eraseCmd))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        return this.serial.write(u8a(eraseFlash));
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Executes GET command
         * @returns {Promise<InfoGET>}
         */
        async cmdGET() {
            return new Promise((resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                this.serial.write(u8a([CMD_GET, 0xFF ^ CMD_GET]))
                    .then(() => this.readResponse())
                    .then(async (resp) => {
                        let response = new Uint8Array(resp);
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }

                        // if (response.length === 1) { // TODO stm8 sends the bytes with delay. Always or on in reply mode only?
                        //     let res = await this.readResponse();
                        //     response[1] = res[0];
                        //     res = await this.readResponse(); // bl version
                        //     response[2] = res[0];
                        //     for (let i = 0; i <= response[1]; i++) {
                        //         res = await this.readResponse();
                        //         response[3 + i] = res[0];
                        //     }
                        // }

                        while (response.length === 1 || response.length < response[1] + 4) {
                            let res = await this.readResponse();
                            response = new Uint8Array([
                                ...response,
                                ...res
                            ]);
                        }

                        let info = new InfoGET();
                        info.blVersion = (response[2] >> 4) + '.' + (response[2] & 0x0F);
                        for (let i = 0; i < response[1]; i++) {
                            info.commands.push(response[3 + i]);
                        }
                        this.commands = info.commands;
                        if (info.getFamily() === 'STM32') {
                            this.writeBlockSize = MAX_WRITE_BLOCK_SIZE_STM32;
                            this.ewrLoadState = EwrLoadState.LOADED;
                        } else {
                            this.writeBlockSize = MAX_WRITE_BLOCK_SIZE_STM8;
                        }
                        resolve(info);
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute GO command
         * @param {number} address Memory address to start code execution
         * @returns {Promise}
         */
        async cmdGO(address) {
            return new Promise((resolve, reject) => {
                let addressFrame;

                if (!Number.isInteger(address)) {
                    reject(new Error('Invalid address parameter'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                addressFrame = tools.num2a(address, 4);
                addressFrame.push(this.calcChecksum(addressFrame, false));

                this.serial.write(u8a([CMD_GO, 0xFF ^ CMD_GO]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        return this.serial.write(u8a(addressFrame));
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute single READ command
         * @param {number} address Memory address to read from
         * @param bytesCount Number of bytes to read
         * @returns {Promise}
         */
        async cmdREAD(address, bytesCount) {
            return new Promise((resolve, reject) => {
                let addressFrame;

                if (!Number.isInteger(address) || address < 0) {
                    reject(new Error('Invalid address parameter'));
                    return;
                }

                if (!Number.isInteger(bytesCount) || bytesCount <= 0 || bytesCount > this.readBlockSize) {
                    reject(new Error('Invalid bytesCount parameter'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                addressFrame = tools.num2a(address, 4);
                addressFrame.push(this.calcChecksum(addressFrame, false));

                this.serial.write(u8a([CMD_READ, 0xFF ^ CMD_READ]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        return this.serial.write(u8a(addressFrame));
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        // The number of bytes to be read -1 (0 <= N <= 255)
                        return this.serial.write(u8a([bytesCount - 1, (bytesCount - 1) ^ 0xFF]));
                    })
                    .then(() => this.readResponse())
                    .then(async (response) => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }

                        if (this.replyMode) {
                            for (let i = 0; i < bytesCount; i++) {
                                await this.readResponse(); // read and ignore
                            }
                        }
                        resolve(result.subarray(1));
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute Write Unprotect command
         * STM32 only
         * @returns {Promise}
         */
        async cmdWPUN() {
            return new Promise((resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (this.commands.indexOf(CMD_WPUN) === -1) {
                    reject(new Error('Write Unprotect command is not supported by the current target'));
                    return;
                }

                this.serial.write(u8a([CMD_WPUN, 0xFF ^ CMD_WPUN]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        return this.readResponse();
                    })
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute Readout Unprotect command
         * STM32 only
         * @returns {Promise}
         */
        async cmdRPUN() {
            return new Promise((resolve, reject) => {
                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (this.commands.indexOf(CMD_RDU_PRM) === -1) {
                    reject(new Error('Readout Unprotect command is not supported by the current target'));
                    return;
                }

                this.serial.write(u8a([CMD_RDU_PRM, 0xFF ^ CMD_RDU_PRM]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        return this.readResponse();
                    })
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute single WRITE command
         * @param {Uint8Array} data Data to write
         * @param {number} address Address to write at
         * @returns {Promise}
         */
        async cmdWRITE(data, address) {
            return new Promise(async (resolve, reject) => {
                if (!(data instanceof Uint8Array)) {
                    reject(new Error('Missinf data to write'));
                    return;
                }

                if (!Number.isInteger(address) || address < 0) {
                    reject(new Error('Invalid address parameter'));
                    return;
                }

                if (data.length > this.writeBlockSize) {
                    reject(new Error('Data is too big, use write()'));
                    return;
                }

                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                if (this.ewrLoadState == EwrLoadState.NOT_LOADED) {
                    try {
                        await this.sendEWR();
                    } catch (e) {
                        reject(e);
                        return;
                    }
                }

                // Frame: number of bytes to be written (1 byte), the data (N + 1 bytes) (multiple of 4) and checksum
                let checksum = this.calcChecksum(data, true);
                let frame = new Uint8Array(data.length + 2);
                frame[0] = [data.length - 1]; //
                frame.set(data, 1);
                frame[frame.length - 1] = checksum;

                let addressFrame = tools.num2a(address, 4);
                addressFrame.push(this.calcChecksum(addressFrame, false));

                this.serial.write(u8a([CMD_WRITE, 0xFF ^ CMD_WRITE]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        return this.serial.write(u8a(addressFrame));
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        return this.serial.write(frame);
                    })
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Execute Get ID command
         * STM32 only
         */
        async cmdGID() {
            return new Promise((resolve, reject) => {
                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (this.commands.indexOf(CMD_GID) === -1) {
                    reject(new Error('GET ID command is not supported by the current target'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                this.serial.write(u8a([CMD_GID, 0xFF ^ CMD_GID]))
                    .then(() => this.readResponse())
                    .then(async (response) => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }

                        while (response.length === 1 || response.length < response[1] + 4) {
                            let res = await this.readResponse();
                            response = new Uint8Array([
                                ...response,
                                ...res
                            ]);
                        }

                        let pid = '0x' + tools.b2hexstr(response[2]) + tools.b2hexstr(response[3]);
                        resolve(pid);
                    })
                    .catch(reject);
            });
        }

        /**
         * Get Version & Read Protection Status command
         * STM32 only
         * @returns {Promise<InfoGV>}
         */
        async cmdGV() {
            return new Promise((resolve, reject) => {
                if (!this.commands.length) {
                    reject(new Error('Execute GET command first'));
                    return;
                }

                if (this.commands.indexOf(CMD_GV) === -1) {
                    reject(new Error('Get Version & Read Protection Status command is not supported by the current target'));
                    return;
                }

                if (!this.serial.isOpen()) {
                    reject(new Error('Connection must be established before sending commands'));
                    return;
                }

                this.serial.write(u8a([CMD_GV, 0xFF ^ CMD_GV]))
                    .then(() => this.readResponse())
                    .then(response => {
                        if (response[0] !== ACK) {
                            throw new Error('Unexpected response');
                        }

                        let info = new InfoGV();
                        info.blVersion = (result[1] >> 4) + '.' + (result[1] & 0x0F);
                        info.countRPenabled = result[2];
                        info.countRPdisabled = result[3];
                        resolve(info);
                    })
                    .catch(reject);
            });
        }

        /**
         * Serial read wrapper for single response with automatic echo mode
         * @private
         * @returns {Promise}
         */
        async readResponse() {
            return new Promise((resolve, reject) => {
                let result = null;
                this.serial.read()
                    .then(response => {
                        result = response;
                        if (this.replyMode) {
                            return this.serial.write(u8a([result[0]]));
                        }
                        return Promise.resolve();
                    })
                    .then(() => {
                        resolve(result);
                    })
                    .catch(reject);
            });
        }

        /**
         * Writes erase_write_routines for STM8 A/S to RAM. All erase/write operations won't work without them
         * @private
         */
        async sendEWR() {
            return new Promise(async (resolve, reject) => {
                if (!this.ewRoutines) {
                    if (!this.stm8RoutinesFile) {
                        reject(new Error('Select your device first by calling setDevice'));
                        return;
                    }

                    logger.log('Loading Erase-Write-Routines ' + this.stm8RoutinesFile);
                    this.ewRoutines = await fetch(this.stm8RoutinesFile)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Failed fetching ' + this.stm8RoutinesFile);
                            }
                            return response.arrayBuffer();
                        })
                        .then(buffer => {
                            return new Uint8Array(buffer);
                        })
                        .catch(reject);
                }

                this.ewrLoadState = EwrLoadState.LOADING;
                logger.log('Sending Erase-Write-Routines to the device...');
                this.write(this.ewRoutines, STM8_WRITE_CODE_ADDRESS)
                    .then(() => {
                        this.ewrLoadState = EwrLoadState.LOADED;
                        logger.log('Erase-Write-Routines loaded');
                        resolve();
                    })
                    .catch(error => {
                        this.ewrLoadState = EwrLoadState.NOT_LOADED;
                        reject(error);
                    });
            });
        }

        /**
         * Activate the ROM bootloader
         * @private
         * @returns {Promise}
         */
        async activateBootloader() {
            return new Promise((resolve, reject) => {
                logger.log('Activating bootloader...');
                if (!this.serial.isOpen()) {
                    reject(new Error('Port must be opened before activating the bootloader'));
                    return;
                }

                this.enterBootMode()
                    .then(() => this.serial.write(u8a([SYNCHR])))
                    .then(() => this.serial.read())
                    .then(response => {
                        if (response[0] === ACK) {
                            if (this.replyMode) {
                                return this.serial.write(u8a([ACK]));
                            }
                            return Promise.resolve();
                        } else {
                            throw new Error('Unexpected response');
                        }
                    })
                    .then(() => {
                        logger.log('Bootloader is ready for commands');
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Resets the target by toggling a control pin defined in RTS_PIN
         * @private
         * @returns {Promise}
         */
         async enterBootMode() {
            return new Promise((resolve, reject) => {
                logger.log('Enter boot mode target...');
                let signal = {};

                if (!this.serial.isOpen()) {
                    reject(new Error('Port must be opened for device reset'));
                    return;
                }

        // def boot(a: float, b: float) -> None:
            // ser.dtr = 0
            // ser.rts = 1
            // time.sleep(a)
            // ser.dtr = 1
            // ser.rts = 0
            // time.sleep(b)
            // ser.dtr = 0

                signal[DTR_PIN] = PIN_HIGH;
                signal[RTS_PIN] = PIN_LOW;
                this.serial.control(signal)
                    .then(() => new Promise(resolve => setTimeout(resolve, 200)))
                    .then(() => {
                        signal[DTR_PIN] = PIN_LOW;
                        signal[RTS_PIN] = PIN_HIGH;
                        return this.serial.control(signal);
                    })
                    .then(() => new Promise(resolve => setTimeout(resolve, 200)))
                    .then(() => {
                        signal[DTR_PIN] = PIN_HIGH;
                        return this.serial.control(signal);
                    })
                    .then(() => {
                        resolve();
                    })
                    .catch(reject);
            });
        }

        /**
         * Resets the target by toggling a control pin defined in RTS_PIN
         * @private
         * @returns {Promise}
         */
        async resetTarget() {
            return new Promise((resolve, reject) => {
                logger.log('Resetting target...');
                let signal = {};

                if (!this.serial.isOpen()) {
                    reject(new Error('Port must be opened for device reset'));
                    return;
                }

                signal[RTS_PIN] = PIN_LOW;
                this.serial.control(signal)
                    .then(() => {
                        signal[RTS_PIN] = PIN_HIGH;
                        return this.serial.control(signal);
                    })
                    .then(() => {
                        // wait for device init
                        logger.log('Reset done. Wait for init.');
                        this.ewrLoadState = EwrLoadState.NOT_LOADED;
                        setTimeout(resolve, 200);
                    })
                    .catch(reject);
            });
        }

        /**
         * Calcualtes the checksum (XOR) of the byte array.
         * @private
         * @param data Byte Array to calculate the checksum for.
         * @param {boolean} wLength If true takes the length of the array into the account (used for data write)
         * @returns {number} Calculated checksum
         */
        calcChecksum(data, wLength) {
            let result = 0;

            for (let i = 0; i < data.length; i += 1) {
                result = result ^ data[i];
            }

            if (wLength) {
                result = result ^ (data.length - 1);
            }

            return result;
        }
    }

    /* src\App.svelte generated by Svelte v3.50.1 */

    function create_if_block_4(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1_value = /*selectedFile*/ ctx[3].name + "";
    	let t1;
    	let div1_intro;

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text("File: ");
    			t1 = text(t1_value);
    			attr(div0, "class", "notification is-info py-2");
    			attr(div1, "class", "container is-fluid is-paddingless");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, t0);
    			append(div0, t1);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*selectedFile*/ 8 && t1_value !== (t1_value = /*selectedFile*/ ctx[3].name + "")) set_data(t1, t1_value);
    		},
    		i(local) {
    			if (!div1_intro) {
    				add_render_callback(() => {
    					div1_intro = create_in_transition(div1, fade, {});
    					div1_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div1);
    		}
    	};
    }

    // (333:4) {#if error}
    function create_if_block_3(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let div1_intro;
    	let div1_outro;
    	let current;

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text("Error: ");
    			t1 = text(/*error*/ ctx[8]);
    			attr(div0, "class", "notification is-danger");
    			attr(div1, "class", "container is-fluid is-paddingless");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, t0);
    			append(div0, t1);
    			current = true;
    		},
    		p(ctx, dirty) {
    			if (!current || dirty & /*error*/ 256) set_data(t1, /*error*/ ctx[8]);
    		},
    		i(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (div1_outro) div1_outro.end(1);
    				div1_intro = create_in_transition(div1, fade, {});
    				div1_intro.start();
    			});

    			current = true;
    		},
    		o(local) {
    			if (div1_intro) div1_intro.invalidate();
    			div1_outro = create_out_transition(div1, fade, {});
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			if (detaching && div1_outro) div1_outro.end();
    		}
    	};
    }

    // (421:4) {#if showPortDialog}
    function create_if_block_2(ctx) {
    	let portdialog;
    	let current;
    	portdialog = new PortDialog({});
    	portdialog.$on("close", /*close_handler*/ ctx[26]);
    	portdialog.$on("selected_port", /*onPortSelected*/ ctx[14]);

    	return {
    		c() {
    			create_component(portdialog.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(portdialog, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(portdialog.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(portdialog.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(portdialog, detaching);
    		}
    	};
    }

    // (427:4) {#if showSettingsDialog}
    function create_if_block_1(ctx) {
    	let settingsdialog;
    	let current;
    	settingsdialog = new SettingsDialog({});
    	settingsdialog.$on("close", /*close_handler_1*/ ctx[27]);

    	return {
    		c() {
    			create_component(settingsdialog.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(settingsdialog, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(settingsdialog.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(settingsdialog.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(settingsdialog, detaching);
    		}
    	};
    }

    // (431:4) {#if !navigator.serial}
    function create_if_block(ctx) {
    	let notsupporteddialog;
    	let current;
    	notsupporteddialog = new NotSupportedDialog({});

    	return {
    		c() {
    			create_component(notsupporteddialog.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(notsupporteddialog, target, anchor);
    			current = true;
    		},
    		i(local) {
    			if (current) return;
    			transition_in(notsupporteddialog.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(notsupporteddialog.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(notsupporteddialog, detaching);
    		}
    	};
    }

    function create_fragment(ctx) {
    	let div40;
    	let div5;
    	let div0;
    	let h1;
    	let t2;
    	let a0;
    	let span1;
    	let t3;
    	let span2;
    	let t4;
    	let span3;
    	let a0_class_value;
    	let t5;
    	let div4;
    	let div2;
    	let a1;
    	let div1;
    	let label;
    	let input;
    	let t6;
    	let span4;
    	let t7;
    	let span5;
    	let t9;
    	let a2;
    	let span6;
    	let i1;
    	let i1_class_value;
    	let t10;
    	let span7;
    	let t11_value = (/*isConnected*/ ctx[1] ? 'Disconnect' : 'Connect') + "";
    	let t11;
    	let t12;
    	let a3;
    	let t15;
    	let a4;
    	let t18;
    	let a5;
    	let t21;
    	let a6;
    	let t24;
    	let div3;
    	let a7;
    	let span16;
    	let t25;
    	let span17;

    	let t26_value = (/*selectedPort*/ ctx[4]
    	? /*selectedPort*/ ctx[4].name
    	: 'Select port') + "";

    	let t26;
    	let div4_class_value;
    	let t27;
    	let t28;
    	let t29;
    	let div39;
    	let div38;
    	let div35;
    	let div34;
    	let p0;
    	let t31;
    	let div12;
    	let div8;
    	let t33;
    	let div11;
    	let div10;
    	let div9;
    	let t34_value = /*deviceInfo*/ ctx[0].family + "";
    	let t34;
    	let t35;
    	let div19;
    	let div15;
    	let t37;
    	let div18;
    	let div17;
    	let div16;
    	let t38_value = /*deviceInfo*/ ctx[0].bl + "";
    	let t38;
    	let t39;
    	let div26;
    	let div22;
    	let t41;
    	let div25;
    	let div24;
    	let div23;
    	let t42_value = /*deviceInfo*/ ctx[0].pid + "";
    	let t42;
    	let t43;
    	let div33;
    	let div29;
    	let t45;
    	let div32;
    	let div31;
    	let div30;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let t51;
    	let div37;
    	let div36;
    	let p1;
    	let t53;
    	let pre;
    	let t54;
    	let t55;
    	let t56;
    	let t57;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*selectedFile*/ ctx[3] && create_if_block_4(ctx);
    	let if_block1 = /*error*/ ctx[8] && create_if_block_3(ctx);
    	let if_block2 = /*showPortDialog*/ ctx[6] && create_if_block_2(ctx);
    	let if_block3 = /*showSettingsDialog*/ ctx[7] && create_if_block_1(ctx);
    	let if_block4 = !navigator.serial && create_if_block();

    	return {
    		c() {
    			div40 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.innerHTML = `Web-STM-Flasher<span id="subtitle" class="is-size-6 svelte-1ei71ab">serial</span>`;
    			t2 = space();
    			a0 = element("a");
    			span1 = element("span");
    			t3 = space();
    			span2 = element("span");
    			t4 = space();
    			span3 = element("span");
    			t5 = space();
    			div4 = element("div");
    			div2 = element("div");
    			a1 = element("a");
    			div1 = element("div");
    			label = element("label");
    			input = element("input");
    			t6 = space();
    			span4 = element("span");
    			span4.innerHTML = `<i class="fa fa-folder-open"></i>`;
    			t7 = space();
    			span5 = element("span");
    			span5.textContent = "Open File";
    			t9 = space();
    			a2 = element("a");
    			span6 = element("span");
    			i1 = element("i");
    			t10 = space();
    			span7 = element("span");
    			t11 = text(t11_value);
    			t12 = space();
    			a3 = element("a");

    			a3.innerHTML = `<span class="icon"><i class="fa fa-eraser"></i></span> 
                    <span>Full Erase</span>`;

    			t15 = space();
    			a4 = element("a");

    			a4.innerHTML = `<span class="icon"><i class="fas fa-pen"></i></span> 
                    <span>Flash</span>`;

    			t18 = space();
    			a5 = element("a");

    			a5.innerHTML = `<span class="icon"><i class="fa fa-play"></i></span> 
                    <span>Flash &amp; Go</span>`;

    			t21 = space();
    			a6 = element("a");

    			a6.innerHTML = `<span class="icon"><i class="fa fa-cog"></i></span> 
                    <span>Settings</span>`;

    			t24 = space();
    			div3 = element("div");
    			a7 = element("a");
    			span16 = element("span");
    			span16.innerHTML = `<i class="fas fa-plug"></i>`;
    			t25 = space();
    			span17 = element("span");
    			t26 = text(t26_value);
    			t27 = space();
    			if (if_block0) if_block0.c();
    			t28 = space();
    			if (if_block1) if_block1.c();
    			t29 = space();
    			div39 = element("div");
    			div38 = element("div");
    			div35 = element("div");
    			div34 = element("div");
    			p0 = element("p");
    			p0.textContent = "Device Info";
    			t31 = space();
    			div12 = element("div");
    			div8 = element("div");
    			div8.innerHTML = `<div class="level-item"><div class="label">Family:</div></div>`;
    			t33 = space();
    			div11 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			t34 = text(t34_value);
    			t35 = space();
    			div19 = element("div");
    			div15 = element("div");
    			div15.innerHTML = `<div class="level-item"><div class="label">Bootloader:</div></div>`;
    			t37 = space();
    			div18 = element("div");
    			div17 = element("div");
    			div16 = element("div");
    			t38 = text(t38_value);
    			t39 = space();
    			div26 = element("div");
    			div22 = element("div");
    			div22.innerHTML = `<div class="level-item"><div class="label">Product ID:</div></div>`;
    			t41 = space();
    			div25 = element("div");
    			div24 = element("div");
    			div23 = element("div");
    			t42 = text(t42_value);
    			t43 = space();
    			div33 = element("div");
    			div29 = element("div");
    			div29.innerHTML = `<div class="level-item"><div class="label">STM8 type:</div></div>`;
    			t45 = space();
    			div32 = element("div");
    			div31 = element("div");
    			div30 = element("div");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Select device...\r\n                                        ";
    			option1 = element("option");
    			option1.textContent = "STM8 S/A 32K";
    			option2 = element("option");
    			option2.textContent = "STM8 S/A 128K\r\n                                        ";
    			option3 = element("option");
    			option3.textContent = "STM8 S/A 256K\r\n                                        ";
    			option4 = element("option");
    			option4.textContent = "STM8 L";
    			t51 = space();
    			div37 = element("div");
    			div36 = element("div");
    			p1 = element("p");
    			p1.textContent = "Log Messages";
    			t53 = space();
    			pre = element("pre");
    			t54 = text(/*logs*/ ctx[5]);
    			t55 = space();
    			if (if_block2) if_block2.c();
    			t56 = space();
    			if (if_block3) if_block3.c();
    			t57 = space();
    			if (if_block4) if_block4.c();
    			attr(h1, "class", "navbar-item is-size-5 mr-3 pt-1");
    			attr(span1, "aria-hidden", "true");
    			attr(span2, "aria-hidden", "true");
    			attr(span3, "aria-hidden", "true");
    			attr(a0, "role", "button");
    			attr(a0, "class", a0_class_value = "navbar-burger burger " + (/*burgerActive*/ ctx[2] ? 'is-active' : ''));
    			attr(a0, "aria-label", "menu");
    			attr(a0, "aria-expanded", "false");
    			attr(a0, "data-target", "blpnavbar");
    			attr(div0, "class", "navbar-brand");
    			attr(input, "class", "file-input");
    			attr(input, "type", "file");
    			attr(input, "accept", ".s19,.hex,.ihx,.bin");
    			attr(input, "name", "file");
    			attr(span4, "class", "icon");
    			attr(span5, "class", "file-label");
    			attr(label, "class", "file-label");
    			attr(div1, "class", "file");
    			attr(a1, "class", "navbar-item");
    			attr(i1, "class", i1_class_value = "fa " + (/*isConnected*/ ctx[1] ? 'fa-unlink' : 'fa-link'));
    			attr(span6, "class", "icon");
    			attr(a2, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a2, "disabled", /*isConnecting*/ ctx[11] || !/*selectedPort*/ ctx[4]);
    			attr(a3, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a3, "disabled", !/*cmdsAllowed*/ ctx[9]);
    			attr(a4, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a4, "disabled", !/*selectedFile*/ ctx[3] || !/*cmdsAllowed*/ ctx[9]);
    			attr(a5, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a5, "disabled", !/*selectedFile*/ ctx[3] || !/*cmdsAllowed*/ ctx[9]);
    			attr(a6, "class", "navbar-item");
    			attr(div2, "class", "navbar-start");
    			attr(span16, "class", "icon");
    			attr(a7, "class", "navbar-item svelte-1ei71ab");
    			toggle_class(a7, "disabled", !/*isDisconnected*/ ctx[10]);
    			attr(div3, "class", "navbar-end");
    			attr(div4, "id", "blpnavbar");
    			attr(div4, "class", div4_class_value = "navbar-menu " + (/*burgerActive*/ ctx[2] ? 'is-active' : ''));
    			attr(div5, "class", "navbar has-shadow");
    			attr(p0, "class", "title is-5");
    			attr(div8, "class", "level-left");
    			attr(div9, "class", "value");
    			attr(div10, "class", "level-item");
    			attr(div11, "class", "level-right");
    			attr(div12, "class", "level is-mobile");
    			attr(div15, "class", "level-left");
    			attr(div16, "class", "value");
    			attr(div17, "class", "level-item");
    			attr(div18, "class", "level-right");
    			attr(div19, "class", "level is-mobile");
    			attr(div22, "class", "level-left");
    			attr(div23, "class", "value");
    			attr(div24, "class", "level-item");
    			attr(div25, "class", "level-right");
    			attr(div26, "class", "level is-mobile");
    			attr(div29, "class", "level-left");
    			option0.__value = "-1";
    			option0.value = option0.__value;
    			option0.selected = true;
    			option1.__value = "32";
    			option1.value = option1.__value;
    			option2.__value = "128";
    			option2.value = option2.__value;
    			option3.__value = "256";
    			option3.value = option3.__value;
    			option4.__value = "0";
    			option4.value = option4.__value;
    			attr(select, "id", "devices");
    			attr(div30, "class", "select value");
    			attr(div31, "class", "level-item");
    			attr(div32, "class", "level-right");
    			attr(div33, "class", "level is-mobile");
    			toggle_class(div33, "is-hidden", /*deviceInfo*/ ctx[0].family !== 'STM8');
    			attr(div34, "class", "box");
    			attr(div34, "id", "devinfo");
    			attr(div35, "class", "column is-narrow");
    			set_style(div35, "min-width", "360px");
    			attr(p1, "class", "title is-5");
    			attr(div36, "class", "box");
    			attr(div37, "class", "column");
    			attr(div38, "class", "columns");
    			attr(div39, "class", "container is-fluid mt-4");
    			attr(div40, "id", "app");
    		},
    		m(target, anchor) {
    			insert(target, div40, anchor);
    			append(div40, div5);
    			append(div5, div0);
    			append(div0, h1);
    			append(div0, t2);
    			append(div0, a0);
    			append(a0, span1);
    			append(a0, t3);
    			append(a0, span2);
    			append(a0, t4);
    			append(a0, span3);
    			append(div5, t5);
    			append(div5, div4);
    			append(div4, div2);
    			append(div2, a1);
    			append(a1, div1);
    			append(div1, label);
    			append(label, input);
    			append(label, t6);
    			append(label, span4);
    			append(label, t7);
    			append(label, span5);
    			append(div2, t9);
    			append(div2, a2);
    			append(a2, span6);
    			append(span6, i1);
    			append(a2, t10);
    			append(a2, span7);
    			append(span7, t11);
    			append(div2, t12);
    			append(div2, a3);
    			append(div2, t15);
    			append(div2, a4);
    			append(div2, t18);
    			append(div2, a5);
    			append(div2, t21);
    			append(div2, a6);
    			append(div4, t24);
    			append(div4, div3);
    			append(div3, a7);
    			append(a7, span16);
    			append(a7, t25);
    			append(a7, span17);
    			append(span17, t26);
    			append(div40, t27);
    			if (if_block0) if_block0.m(div40, null);
    			append(div40, t28);
    			if (if_block1) if_block1.m(div40, null);
    			append(div40, t29);
    			append(div40, div39);
    			append(div39, div38);
    			append(div38, div35);
    			append(div35, div34);
    			append(div34, p0);
    			append(div34, t31);
    			append(div34, div12);
    			append(div12, div8);
    			append(div12, t33);
    			append(div12, div11);
    			append(div11, div10);
    			append(div10, div9);
    			append(div9, t34);
    			append(div34, t35);
    			append(div34, div19);
    			append(div19, div15);
    			append(div19, t37);
    			append(div19, div18);
    			append(div18, div17);
    			append(div17, div16);
    			append(div16, t38);
    			append(div34, t39);
    			append(div34, div26);
    			append(div26, div22);
    			append(div26, t41);
    			append(div26, div25);
    			append(div25, div24);
    			append(div24, div23);
    			append(div23, t42);
    			append(div34, t43);
    			append(div34, div33);
    			append(div33, div29);
    			append(div33, t45);
    			append(div33, div32);
    			append(div32, div31);
    			append(div31, div30);
    			append(div30, select);
    			append(select, option0);
    			append(select, option1);
    			append(select, option2);
    			append(select, option3);
    			append(select, option4);
    			append(div38, t51);
    			append(div38, div37);
    			append(div37, div36);
    			append(div36, p1);
    			append(div36, t53);
    			append(div36, pre);
    			append(pre, t54);
    			append(div40, t55);
    			if (if_block2) if_block2.m(div40, null);
    			append(div40, t56);
    			if (if_block3) if_block3.m(div40, null);
    			append(div40, t57);
    			if (if_block4) if_block4.m(div40, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(a0, "click", /*onBurgerClick*/ ctx[13]),
    					listen(input, "change", /*onOpenFile*/ ctx[15]),
    					listen(a2, "click", /*onConnect*/ ctx[17]),
    					listen(a3, "click", /*onErase*/ ctx[18]),
    					listen(a4, "click", /*click_handler*/ ctx[24]),
    					listen(a5, "click", /*click_handler_1*/ ctx[25]),
    					listen(a6, "click", /*onSettings*/ ctx[19]),
    					listen(a7, "click", /*onSelectPort*/ ctx[12]),
    					listen(select, "change", /*onStm8Select*/ ctx[20])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (!current || dirty & /*burgerActive*/ 4 && a0_class_value !== (a0_class_value = "navbar-burger burger " + (/*burgerActive*/ ctx[2] ? 'is-active' : ''))) {
    				attr(a0, "class", a0_class_value);
    			}

    			if (!current || dirty & /*isConnected*/ 2 && i1_class_value !== (i1_class_value = "fa " + (/*isConnected*/ ctx[1] ? 'fa-unlink' : 'fa-link'))) {
    				attr(i1, "class", i1_class_value);
    			}

    			if ((!current || dirty & /*isConnected*/ 2) && t11_value !== (t11_value = (/*isConnected*/ ctx[1] ? 'Disconnect' : 'Connect') + "")) set_data(t11, t11_value);

    			if (!current || dirty & /*isConnecting, selectedPort*/ 2064) {
    				toggle_class(a2, "disabled", /*isConnecting*/ ctx[11] || !/*selectedPort*/ ctx[4]);
    			}

    			if (!current || dirty & /*cmdsAllowed*/ 512) {
    				toggle_class(a3, "disabled", !/*cmdsAllowed*/ ctx[9]);
    			}

    			if (!current || dirty & /*selectedFile, cmdsAllowed*/ 520) {
    				toggle_class(a4, "disabled", !/*selectedFile*/ ctx[3] || !/*cmdsAllowed*/ ctx[9]);
    			}

    			if (!current || dirty & /*selectedFile, cmdsAllowed*/ 520) {
    				toggle_class(a5, "disabled", !/*selectedFile*/ ctx[3] || !/*cmdsAllowed*/ ctx[9]);
    			}

    			if ((!current || dirty & /*selectedPort*/ 16) && t26_value !== (t26_value = (/*selectedPort*/ ctx[4]
    			? /*selectedPort*/ ctx[4].name
    			: 'Select port') + "")) set_data(t26, t26_value);

    			if (!current || dirty & /*isDisconnected*/ 1024) {
    				toggle_class(a7, "disabled", !/*isDisconnected*/ ctx[10]);
    			}

    			if (!current || dirty & /*burgerActive*/ 4 && div4_class_value !== (div4_class_value = "navbar-menu " + (/*burgerActive*/ ctx[2] ? 'is-active' : ''))) {
    				attr(div4, "class", div4_class_value);
    			}

    			if (/*selectedFile*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*selectedFile*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div40, t28);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*error*/ ctx[8]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*error*/ 256) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div40, t29);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*deviceInfo*/ 1) && t34_value !== (t34_value = /*deviceInfo*/ ctx[0].family + "")) set_data(t34, t34_value);
    			if ((!current || dirty & /*deviceInfo*/ 1) && t38_value !== (t38_value = /*deviceInfo*/ ctx[0].bl + "")) set_data(t38, t38_value);
    			if ((!current || dirty & /*deviceInfo*/ 1) && t42_value !== (t42_value = /*deviceInfo*/ ctx[0].pid + "")) set_data(t42, t42_value);

    			if (!current || dirty & /*deviceInfo*/ 1) {
    				toggle_class(div33, "is-hidden", /*deviceInfo*/ ctx[0].family !== 'STM8');
    			}

    			if (!current || dirty & /*logs*/ 32) set_data(t54, /*logs*/ ctx[5]);

    			if (/*showPortDialog*/ ctx[6]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*showPortDialog*/ 64) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div40, t56);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*showSettingsDialog*/ ctx[7]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*showSettingsDialog*/ 128) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div40, t57);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div40);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    const DISCONNECTED = 'disconnected';
    const CONNECTING = 'connecting';
    const CONNECTED = 'connected';

    function instance($$self, $$props, $$invalidate) {
    	let isConnected;
    	let isConnecting;
    	let isDisconnected;
    	let cmdsAllowed;
    	let burgerActive = false;
    	let selectedFile = null;
    	let selectedPort = null;
    	let logs = '';
    	let showPortDialog = false;
    	let showSettingsDialog = false;
    	let connectionState = DISCONNECTED;
    	let error = null;
    	let stmApi = null;

    	let deviceInfo = {
    		family: '-',
    		bl: '-',
    		pid: '-',
    		commands: []
    	};

    	let stm8selected = false;
    	let sending = false;

    	logger.registerLogger({
    		log(...args) {
    			log(args[0]);
    		}
    	});

    	function onSelectPort() {
    		$$invalidate(8, error = null);
    		$$invalidate(6, showPortDialog = true);
    	}

    	function onBurgerClick() {
    		$$invalidate(2, burgerActive = !burgerActive);
    	}

    	function log(message) {
    		$$invalidate(5, logs += message + '\n');
    	}

    	function onPortSelected(event) {
    		$$invalidate(8, error = null);
    		$$invalidate(4, selectedPort = event.detail);
    		let serial = new WebSerial(selectedPort);

    		serial.onConnect = () => {
    			
    		};

    		serial.onDisconnect = () => {
    			$$invalidate(23, sending = false);
    			$$invalidate(21, connectionState = DISCONNECTED);
    			$$invalidate(5, logs = '');
    		};

    		stmApi = new STMApi(serial);
    	}

    	function onOpenFile(event) {
    		$$invalidate(8, error = null);
    		$$invalidate(3, selectedFile = event.target.files[0]);
    	}

    	function onFlash(go) {
    		$$invalidate(8, error = null);
    		$$invalidate(23, sending = true);
    		log('Reading content of the file ' + selectedFile.name);

    		tools.readFile(selectedFile).then(async content => {
    			log('Parsing content of the file');
    			const ext = tools.extension(selectedFile.name);
    			let startAddress;
    			let records;

    			if (ext === 's19') {
    				records = tools.parseSRec(true, stmApi.writeBlockSize, content);
    			} else if (ext === 'hex' || ext === 'ihx') {
    				records = tools.parseHex(true, stmApi.writeBlockSize, content);
    			} else if (ext === 'bin') {
    				startAddress = parseInt(settings.startAddress);

    				records = [
    					{
    						type: 'data',
    						data: new Uint8Array(content),
    						address: startAddress
    					}
    				];
    			}

    			for (let i = 0; i < records.length; i++) {
    				let rec = records[i];

    				if (rec.type === 'data') {
    					let before_log = logs;

    					await stmApi.write(rec.data, rec.address, (i, blocksCount) => {
    						$$invalidate(5, logs = before_log + 'Writing block ' + (i + 1) + '/' + blocksCount + '\n');
    					});
    				} else if (rec.type === 'start') {
    					log('Start address detected: 0x' + rec.address.toString(16));
    					startAddress = rec.address;
    				}
    			}

    			if (go) {
    				startAddress = startAddress || parseInt(settings.startAddress);
    				log('Starting code execution');
    				await stmApi.cmdGO(startAddress);
    				stmApi.disconnect();
    			}

    			$$invalidate(23, sending = false);
    		}).catch(err => {
    			$$invalidate(23, sending = false);
    			$$invalidate(8, error = err.message);
    		});
    	}

    	function onConnect() {
    		$$invalidate(0, deviceInfo = {
    			family: '-',
    			bl: '-',
    			pid: '-',
    			commands: []
    		});

    		if (connectionState === DISCONNECTED) {
    			$$invalidate(21, connectionState = CONNECTING);
    			$$invalidate(8, error = null);

    			stmApi.connect({
    				replyMode: settings.replyMode,
    				baudrate: settings.baudrate
    			}).then(() => {
    				$$invalidate(21, connectionState = CONNECTED);
    				return stmApi.cmdGET();
    			}).then(info => {
    				$$invalidate(0, deviceInfo.bl = info.blVersion, deviceInfo);
    				$$invalidate(0, deviceInfo.commands = info.commands, deviceInfo);
    				$$invalidate(0, deviceInfo.family = info.getFamily(), deviceInfo);

    				if (deviceInfo.family === 'STM32') {
    					return stmApi.cmdGID();
    				} else {
    					return Promise.resolve('-');
    				}
    			}).then(pid => {
    				$$invalidate(0, deviceInfo.pid = pid, deviceInfo);
    			}).catch(err => {
    				log(err);
    				$$invalidate(8, error = err.message);
    				$$invalidate(21, connectionState = DISCONNECTED);
    			});
    		} else {
    			stmApi.disconnect().catch(err => {
    				$$invalidate(8, error = err.message);
    			});
    		}
    	}

    	function onErase() {
    		$$invalidate(8, error = null);
    		$$invalidate(23, sending = true);
    		log('Erasing flash...');

    		stmApi.eraseAll().then(() => {
    			log('Flash erased');
    			$$invalidate(23, sending = false);
    		}).catch(err => {
    			$$invalidate(23, sending = false);
    			$$invalidate(8, error = err.message);
    		});
    	}

    	function onSettings() {
    		$$invalidate(8, error = null);
    		$$invalidate(7, showSettingsDialog = true);
    	}

    	function onStm8Select(event) {
    		let value = event.target.value;
    		$$invalidate(22, stm8selected = value !== '-1');

    		stmApi.setDevice({
    			blVersion: deviceInfo.bl,
    			flash: stm8selected ? value : null
    		});
    	}

    	const click_handler = () => onFlash(false);
    	const click_handler_1 = () => onFlash(true);
    	const close_handler = () => $$invalidate(6, showPortDialog = false);
    	const close_handler_1 = () => $$invalidate(7, showSettingsDialog = false);

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*connectionState*/ 2097152) {
    			$$invalidate(1, isConnected = connectionState === CONNECTED);
    		}

    		if ($$self.$$.dirty & /*connectionState*/ 2097152) {
    			$$invalidate(11, isConnecting = connectionState === CONNECTING);
    		}

    		if ($$self.$$.dirty & /*connectionState*/ 2097152) {
    			$$invalidate(10, isDisconnected = connectionState === DISCONNECTED);
    		}

    		if ($$self.$$.dirty & /*isConnected, sending, deviceInfo, stm8selected*/ 12582915) {
    			$$invalidate(9, cmdsAllowed = isConnected && !sending && (deviceInfo.family === 'STM32' || deviceInfo.family === 'STM8' && stm8selected));
    		}
    	};

    	return [
    		deviceInfo,
    		isConnected,
    		burgerActive,
    		selectedFile,
    		selectedPort,
    		logs,
    		showPortDialog,
    		showSettingsDialog,
    		error,
    		cmdsAllowed,
    		isDisconnected,
    		isConnecting,
    		onSelectPort,
    		onBurgerClick,
    		onPortSelected,
    		onOpenFile,
    		onFlash,
    		onConnect,
    		onErase,
    		onSettings,
    		onStm8Select,
    		connectionState,
    		stm8selected,
    		sending,
    		click_handler,
    		click_handler_1,
    		close_handler,
    		close_handler_1
    	];
    }

    class App extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance, create_fragment, safe_not_equal, {});
    	}
    }

    const app = new App({
    	target: document.body
    });

    return app;

})();
